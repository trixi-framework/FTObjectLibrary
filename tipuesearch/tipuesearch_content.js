var tipuesearch = {"pages":[{"title":" FTObjectLibrary ","text":"FTObjectLibrary Overview FTObjectLibrary provides a collection of reference counted Fortran 2003 classes to \n facilitate writing generic object oriented Fortran programs. Reference counting\n is implemented to assist with memory management so that the lifespans of objects\n are properly maintained and are so that objects are deleted only when no other references are made to them. FTObjectLibrary tries, as much as the maturity of Fortran compilers allow, to\n use the new F2003/2008 features to make generic programming possible. The LCD\n for the library is gfortran, and as modern features get implemented in the\n compiler, FTObjectLibrary will be updated to include those features. In the meantime, there\n are a few workarounds that exist in the code. The library includes three categories of classes: Value classes Container classes Error reporting and testing classes Value classes include the base class, FTObject and at the current time, a subclass, FTValue. FTObject is the base class that implements the reference counting mechanism and other functions that should be overridden in subclasses. It the base class for all classes in the FTObjectLibrary library. You will usually not allocate objects of this class. Instead you will create your own subclasses of it that have data and procedures as needed. FTValue is a wrapper class that allows storage of real, integer, character and logical values, which can then be stored in containers. Container classes let you store any subclass of the base class FTObject in them. This makes it easy to store, for instance, a linked list of linked lists, or an array of dictionaries. Included in the library are the following standard container classes: FTStack is a subclass of FTLinkedList that adds the usual push, pop, and peek routines. FTSparseMatrix associates a double index (i,j) to an FTObject. Basically this is a two dimensional sparse matrix of pointers to FTObjects. FTMultiIndexTable associates an integer array keys(:) to an FTObject. Basically this is an m--dimensional sparse matrix of pointers to FTObjects. FTDictionary is an ``associative container'', that associates a string to another FTObject. FTValueDictionary is a subclass of FTDictionary that has additional methods to store and retrieve\nvalues. FTMutableObjectArray is a mutable one-dimensional array class that can store any FTObject FTStringSet is different as it encapsulates set operations like set membership, union, intersection, difference, but only for strings. Although other objects cannot be added to string sets, StringSets can be added to other containers The library also contains classes for testing (FTAssertions, TestSuiteManagerClass) and for reporting errors through the FTException class. Documentation Documentation can be found in the linked pages, and in the user's guide FTObjectLibrary.pdf found in the Docs directory. Examples Examples can be found in the Examples directory and in the Testing directory. The examples include a simple reverse Polish caclulator using a stack, and another showing the use of a linked list. The testing directory includes tests that can be run on the library, which themselves serve as examples of the use of all of the classes. Building the Library The library (.a) can be built with either CMake or default make. CMake To install the FTObjectLibrary with CMake, mkdir build && cd build\ncmake -DCMAKE_INSTALL_PREFIX=/path/to/install ../\nmake\nmake install make cd to the directory \"makeLibrary\" and type make That will create the necessary files in that directory, which can be moved to somewhere else as desired. Developer Info David A. Kopriva Department of Mathematics, The Florida State University","tags":"home","loc":"index.html"},{"title":"MatrixData – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: MatrixData Inherits type~~matrixdata~~InheritsGraph type~matrixdata MatrixData type~ftobject FTObject type~matrixdata->type~ftobject object type~matrixdata->type~ftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables key object Finalization Procedures destructMatrixData Type-Bound Procedures init description printDescription className copy retain isUnreferenced refCount initWithObjectAndKey Components Type Visibility Attributes Name Initial integer, public :: key class( FTObject ), public, POINTER :: object Finalization Procedures final :: destructMatrixData public  subroutine destructMatrixData (self) Arguments Type Intent Optional Attributes Name type( MatrixData ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: printDescription => printFTObjectDescription public  subroutine printFTObjectDescription (self, iUnit) Generic Name: printDescription() Prints a string to unit iUnit that represents the contents of the object. FTObject's\n description simply prints its name. Override this in subclasses to print something\n useful. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self integer :: iUnit procedure, public,  :: className public  function className (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTObject \" ) Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: initWithObjectAndKey public  subroutine initWithObjectAndKey (self, object, key) Arguments Type Intent Optional Attributes Name class( MatrixData ) :: self class( FTObject ), POINTER :: object integer :: key","tags":"","loc":"type/matrixdata.html"},{"title":"FTSparseMatrix – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTSparseMatrix Inherits type~~ftsparsematrix~~InheritsGraph type~ftsparsematrix FTSparseMatrix type~ftlinkedlistiterator FTLinkedListIterator type~ftsparsematrix->type~ftlinkedlistiterator iterator type~ftlinkedlistptr FTLinkedListPtr type~ftsparsematrix->type~ftlinkedlistptr table type~ftobject FTObject type~ftsparsematrix->type~ftobject type~ftlinkedlistiterator->type~ftobject type~ftlinkedlist FTLinkedList type~ftlinkedlistiterator->type~ftlinkedlist list type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlistiterator->type~ftlinkedlistrecord current type~ftlinkedlistptr->type~ftlinkedlist list type~ftlinkedlist->type~ftobject type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables table Finalization Procedures destructSparseMatrix Type-Bound Procedures init description printDescription className copy retain isUnreferenced refCount initWithSize containsKeys addObjectForKeys objectForKeys SparseMatrixSize Components Type Visibility Attributes Name Initial type(FTLinkedListPtr), public, DIMENSION(:), ALLOCATABLE :: table Finalization Procedures final :: destructSparseMatrix public  subroutine destructSparseMatrix (self) Arguments Type Intent Optional Attributes Name type( FTSparseMatrix ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: printDescription => printFTObjectDescription public  subroutine printFTObjectDescription (self, iUnit) Generic Name: printDescription() Prints a string to unit iUnit that represents the contents of the object. FTObject's\n description simply prints its name. Override this in subclasses to print something\n useful. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self integer :: iUnit procedure, public,  :: className public  function className (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTObject \" ) Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: initWithSize => initSparseMatrixWithSize public  subroutine initSparseMatrixWithSize (self, N) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self integer :: N procedure, public,  :: containsKeys => SparseMatrixContainsKeys public  function SparseMatrixContainsKeys (self, i, j) result(r) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self integer :: i integer :: j Return Value logical procedure, public,  :: addObjectForKeys => addObjectToSparseMatrixForKeys public  subroutine addObjectToSparseMatrixForKeys (self, obj, i, j) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self class( FTObject ), POINTER :: obj integer :: i integer :: j procedure, public,  :: objectForKeys => objectInSparseMatrixForKeys public  function objectInSparseMatrixForKeys (self, i, j) result(r) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self integer :: i integer :: j Return Value class( FTObject ), POINTER procedure, public,  :: SparseMatrixSize public  function SparseMatrixSize (self) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self Return Value integer","tags":"","loc":"type/ftsparsematrix.html"},{"title":"FTStack – FTObjectLibrary ","text":"type, public, extends( FTLinkedList ) :: FTStack Inherits type~~ftstack~~InheritsGraph type~ftstack FTStack type~ftlinkedlist FTLinkedList type~ftstack->type~ftlinkedlist type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftobject FTObject type~ftlinkedlist->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables head tail nRecords isCircular_ Type-Bound Procedures copy retain isUnreferenced refCount add remove reverse removeRecord count description allObjects removeAllObjects addObjectsFromList makeCircular isCircular insertObjectAfterRecord insertObjectAfterObject init printDescription className push pop peek Components Type Visibility Attributes Name Initial class( FTLinkedListRecord ), public, POINTER :: head => NULL() class( FTLinkedListRecord ), public, POINTER :: tail => NULL() integer, public :: nRecords logical, public :: isCircular_ Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: add public  subroutine add (self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj procedure, public,  :: remove => removeObject public  subroutine removeObject (self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj procedure, public,  :: reverse => reverseLinkedList public  subroutine reverseLinkedList (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self procedure, public,  :: removeRecord => removeLinkedListRecord public  subroutine removeLinkedListRecord (self, listRecord) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTLinkedListRecord ), POINTER :: listRecord procedure, public,  :: count => numberOfRecords public  function numberOfRecords (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value integer procedure, public,  :: description => FTLinkedListDescription public  function FTLinkedListDescription (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: allObjects => allLinkedListObjects public  function allLinkedListObjects (self) result(array) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value class( FTMutableObjectArray ), POINTER procedure, public,  :: removeAllObjects => removeAllLinkedListObjects public  subroutine removeAllLinkedListObjects (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self procedure, public,  :: addObjectsFromList public  subroutine addObjectsFromList (self, list) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTLinkedList ), POINTER :: list procedure, public,  :: makeCircular public  subroutine makeCircular (self, circular) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self logical :: circular procedure, public,  :: isCircular public  function isCircular (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value logical procedure, public,  :: insertObjectAfterRecord public  subroutine insertObjectAfterRecord (self, obj, after) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj class( FTLinkedListRecord ), POINTER :: after procedure, public,  :: insertObjectAfterObject public  subroutine insertObjectAfterObject (self, obj, after) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj class( FTObject ), POINTER :: after procedure, public,  :: init => initFTStack public  subroutine initFTStack (self) Public, generic name: init() Initialize the stack. Arguments Type Intent Optional Attributes Name class( FTStack ) :: self procedure, public,  :: printDescription => printStackDescription public  subroutine printStackDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTStack ) :: self integer :: iUnit procedure, public,  :: className => stackClassName public  function stackClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTStack \" ) Arguments Type Intent Optional Attributes Name class( FTStack ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public,  :: push public  subroutine push (self, obj) Arguments Type Intent Optional Attributes Name class( FTStack ) :: self class( FTObject ), POINTER :: obj procedure, public,  :: pop public  subroutine pop (self, p) Arguments Type Intent Optional Attributes Name class( FTStack ) :: self class( FTObject ), POINTER :: p procedure, public,  :: peek public  function peek (self) Arguments Type Intent Optional Attributes Name class( FTStack ) :: self Return Value class( FTObject ), POINTER","tags":"","loc":"type/ftstack.html"},{"title":"MultiIndexMatrixData – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: MultiIndexMatrixData Inherits type~~multiindexmatrixdata~~InheritsGraph type~multiindexmatrixdata MultiIndexMatrixData type~ftobject FTObject type~multiindexmatrixdata->type~ftobject object type~multiindexmatrixdata->type~ftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables key object Finalization Procedures destructMultiIndexMatrixData Type-Bound Procedures init description printDescription className copy retain isUnreferenced refCount initWithObjectAndKeys Components Type Visibility Attributes Name Initial integer, public, ALLOCATABLE :: key (:) class( FTObject ), public, POINTER :: object Finalization Procedures final :: destructMultiIndexMatrixData public  subroutine destructMultiIndexMatrixData (self) Arguments Type Intent Optional Attributes Name type( MultiIndexMatrixData ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: printDescription => printFTObjectDescription public  subroutine printFTObjectDescription (self, iUnit) Generic Name: printDescription() Prints a string to unit iUnit that represents the contents of the object. FTObject's\n description simply prints its name. Override this in subclasses to print something\n useful. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self integer :: iUnit procedure, public,  :: className public  function className (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTObject \" ) Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: initWithObjectAndKeys public  subroutine initWithObjectAndKeys (self, object, key) Arguments Type Intent Optional Attributes Name class( MultiIndexMatrixData ) :: self class( FTObject ), POINTER :: object integer :: key (:)","tags":"","loc":"type/multiindexmatrixdata.html"},{"title":"FTMultiIndexTable – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTMultiIndexTable Inherits type~~ftmultiindextable~~InheritsGraph type~ftmultiindextable FTMultiIndexTable type~ftlinkedlist FTLinkedList type~ftmultiindextable->type~ftlinkedlist table type~ftobject FTObject type~ftmultiindextable->type~ftobject type~ftlinkedlist->type~ftobject type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables table Finalization Procedures destructMultiIndexTable Type-Bound Procedures init description className copy retain isUnreferenced refCount initWithSize containsKeys addObjectForKeys objectForKeys printDescription MultiIndexTableSize Components Type Visibility Attributes Name Initial class( FTLinkedList ), public, DIMENSION(:), ALLOCATABLE :: table Finalization Procedures final :: destructMultiIndexTable public  subroutine destructMultiIndexTable (self) Arguments Type Intent Optional Attributes Name type( FTMultiIndexTable ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: className public  function className (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTObject \" ) Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: initWithSize => initMultiIndexTableWithSize public  subroutine initMultiIndexTableWithSize (self, N) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: N procedure, public,  :: containsKeys => MultiIndexTableContainsKeys public  function MultiIndexTableContainsKeys (self, keys) result(r) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: keys (:) Return Value logical procedure, public,  :: addObjectForKeys => addObjectToMultiIndexTableForKeys public  subroutine addObjectToMultiIndexTableForKeys (self, obj, keys) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self class( FTObject ), POINTER :: obj integer :: keys (:) procedure, public,  :: objectForKeys => objectInMultiIndexTableForKeys public  function objectInMultiIndexTableForKeys (self, keys) result(r) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: keys (:) Return Value class( FTObject ), POINTER procedure, public,  :: printDescription => printMultiIndexTableDescription public  subroutine printMultiIndexTableDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: iUnit procedure, public,  :: MultiIndexTableSize public  function MultiIndexTableSize (self) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self Return Value integer","tags":"","loc":"type/ftmultiindextable.html"},{"title":"FTData – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTData Inherits type~~ftdata~~InheritsGraph type~ftdata FTData type~ftobject FTObject type~ftdata->type~ftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Finalization Procedures destructData Type-Bound Procedures init description printDescription copy retain isUnreferenced refCount initWithDataOfType storedData storedDataSize className Finalization Procedures final :: destructData public  subroutine destructData (self) Arguments Type Intent Optional Attributes Name type( FTData ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: printDescription => printFTObjectDescription public  subroutine printFTObjectDescription (self, iUnit) Generic Name: printDescription() Prints a string to unit iUnit that represents the contents of the object. FTObject's\n description simply prints its name. Override this in subclasses to print something\n useful. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self integer :: iUnit procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public :: initWithDataOfType public  subroutine initWithDataOfType (self, genericData, dataType) Arguments Type Intent Optional Attributes Name class( FTData ) :: self character(len=1) :: genericData (:) character(len=*) :: dataType procedure, public :: storedData public  function storedData (self) result(d) Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value character(len=1), POINTER, (:) procedure, public :: storedDataSize public  function storedDataSize (self) Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value integer procedure, public :: className => dataClassName public  function dataClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTData \" ) Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH)","tags":"","loc":"type/ftdata.html"},{"title":"FTLinkedListRecord – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTLinkedListRecord Inherits type~~ftlinkedlistrecord~~InheritsGraph type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous type~ftobject FTObject type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ftlinkedlistrecord~~InheritedByGraph type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous type~ftlinkedlist FTLinkedList type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftlinkedlistiterator FTLinkedListIterator type~ftlinkedlistiterator->type~ftlinkedlistrecord current type~ftlinkedlistiterator->type~ftlinkedlist list type~ftdictionary FTDictionary type~ftdictionary->type~ftlinkedlist entries type~ftlinkedlistptr FTLinkedListPtr type~ftlinkedlistptr->type~ftlinkedlist list type~ftmultiindextable FTMultiIndexTable type~ftmultiindextable->type~ftlinkedlist table type~ftsparsematrix FTSparseMatrix type~ftsparsematrix->type~ftlinkedlistiterator iterator type~ftsparsematrix->type~ftlinkedlistptr table type~ftstack FTStack type~ftstack->type~ftlinkedlist type~ftexception FTException type~ftexception->type~ftdictionary infoDictionary_ type~ftstringset FTStringSet type~ftstringset->type~ftdictionary dict type~ftvaluedictionary FTValueDictionary type~ftvaluedictionary->type~ftdictionary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables recordObject next previous Finalization Procedures destructFTLinkedListRecord Type-Bound Procedures init description copy retain isUnreferenced refCount initWithObject printDescription className Components Type Visibility Attributes Name Initial class( FTObject ), public, POINTER :: recordObject => NULL() class( FTLinkedListRecord ), public, POINTER :: next => NULL() class( FTLinkedListRecord ), public, POINTER :: previous => NULL() Finalization Procedures final :: destructFTLinkedListRecord public  subroutine destructFTLinkedListRecord (self) Arguments Type Intent Optional Attributes Name type( FTLinkedListRecord ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: initWithObject public  subroutine initWithObject (self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedListRecord ) :: self class( FTObject ), POINTER :: obj procedure, public,  :: printDescription => printFTLinkedRecordDescription public recursive subroutine printFTLinkedRecordDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTLinkedListRecord ) :: self integer :: iUnit procedure, public,  :: className => llRecordClassName public  function llRecordClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTLinkedListRecord \" ) Arguments Type Intent Optional Attributes Name class( FTLinkedListRecord ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH)","tags":"","loc":"type/ftlinkedlistrecord.html"},{"title":"FTLinkedList – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTLinkedList Inherits type~~ftlinkedlist~~InheritsGraph type~ftlinkedlist FTLinkedList type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftobject FTObject type~ftlinkedlist->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ftlinkedlist~~InheritedByGraph type~ftlinkedlist FTLinkedList type~ftdictionary FTDictionary type~ftdictionary->type~ftlinkedlist entries type~ftlinkedlistiterator FTLinkedListIterator type~ftlinkedlistiterator->type~ftlinkedlist list type~ftlinkedlistptr FTLinkedListPtr type~ftlinkedlistptr->type~ftlinkedlist list type~ftmultiindextable FTMultiIndexTable type~ftmultiindextable->type~ftlinkedlist table type~ftstack FTStack type~ftstack->type~ftlinkedlist type~ftexception FTException type~ftexception->type~ftdictionary infoDictionary_ type~ftsparsematrix FTSparseMatrix type~ftsparsematrix->type~ftlinkedlistiterator iterator type~ftsparsematrix->type~ftlinkedlistptr table type~ftstringset FTStringSet type~ftstringset->type~ftdictionary dict type~ftvaluedictionary FTValueDictionary type~ftvaluedictionary->type~ftdictionary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables head tail nRecords isCircular_ Finalization Procedures destructFTLinkedList Type-Bound Procedures copy retain isUnreferenced refCount init add remove reverse removeRecord count description printDescription className allObjects removeAllObjects addObjectsFromList makeCircular isCircular insertObjectAfterRecord insertObjectAfterObject Components Type Visibility Attributes Name Initial class( FTLinkedListRecord ), public, POINTER :: head => NULL() class( FTLinkedListRecord ), public, POINTER :: tail => NULL() integer, public :: nRecords logical, public :: isCircular_ Finalization Procedures final :: destructFTLinkedList public  subroutine destructFTLinkedList (self) It is automatically called by release(). Arguments Type Intent Optional Attributes Name type( FTLinkedList ) :: self Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: init => initFTLinkedList public  subroutine initFTLinkedList (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self procedure, public,  :: add public  subroutine add (self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj procedure, public,  :: remove => removeObject public  subroutine removeObject (self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj procedure, public,  :: reverse => reverseLinkedList public  subroutine reverseLinkedList (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self procedure, public,  :: removeRecord => removeLinkedListRecord public  subroutine removeLinkedListRecord (self, listRecord) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTLinkedListRecord ), POINTER :: listRecord procedure, public,  :: count => numberOfRecords public  function numberOfRecords (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value integer procedure, public,  :: description => FTLinkedListDescription public  function FTLinkedListDescription (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: printDescription => printFTLinkedListDescription public recursive subroutine printFTLinkedListDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self integer :: iUnit procedure, public,  :: className => linkedListClassName public  function linkedListClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTLinkedList \" ) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public,  :: allObjects => allLinkedListObjects public  function allLinkedListObjects (self) result(array) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value class( FTMutableObjectArray ), POINTER procedure, public,  :: removeAllObjects => removeAllLinkedListObjects public  subroutine removeAllLinkedListObjects (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self procedure, public,  :: addObjectsFromList public  subroutine addObjectsFromList (self, list) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTLinkedList ), POINTER :: list procedure, public,  :: makeCircular public  subroutine makeCircular (self, circular) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self logical :: circular procedure, public,  :: isCircular public  function isCircular (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value logical procedure, public,  :: insertObjectAfterRecord public  subroutine insertObjectAfterRecord (self, obj, after) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj class( FTLinkedListRecord ), POINTER :: after procedure, public,  :: insertObjectAfterObject public  subroutine insertObjectAfterObject (self, obj, after) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj class( FTObject ), POINTER :: after","tags":"","loc":"type/ftlinkedlist.html"},{"title":"FTLinkedListIterator – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTLinkedListIterator Inherits type~~ftlinkedlistiterator~~InheritsGraph type~ftlinkedlistiterator FTLinkedListIterator type~ftlinkedlist FTLinkedList type~ftlinkedlistiterator->type~ftlinkedlist list type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlistiterator->type~ftlinkedlistrecord current type~ftobject FTObject type~ftlinkedlistiterator->type~ftobject type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftlinkedlist->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ftlinkedlistiterator~~InheritedByGraph type~ftlinkedlistiterator FTLinkedListIterator type~ftsparsematrix FTSparseMatrix type~ftsparsematrix->type~ftlinkedlistiterator iterator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables list current Finalization Procedures destructIterator Type-Bound Procedures description printDescription copy retain isUnreferenced refCount init initWithFTLinkedList isAtEnd object currentRecord linkedList className setLinkedList setToStart moveToNext removeCurrentRecord Components Type Visibility Attributes Name Initial class( FTLinkedList ), public, POINTER :: list => NULL() class( FTLinkedListRecord ), public, POINTER :: current => NULL() Finalization Procedures final :: destructIterator public  subroutine destructIterator (self) Arguments Type Intent Optional Attributes Name type( FTLinkedListIterator ) :: self Type-Bound Procedures procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: printDescription => printFTObjectDescription public  subroutine printFTObjectDescription (self, iUnit) Generic Name: printDescription() Prints a string to unit iUnit that represents the contents of the object. FTObject's\n description simply prints its name. Override this in subclasses to print something\n useful. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self integer :: iUnit procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: init => initEmpty public  subroutine initEmpty (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self procedure, public,  :: initWithFTLinkedList public  subroutine initWithFTLinkedList (self, list) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self class( FTLinkedList ), POINTER :: list procedure, public,  :: isAtEnd => FTLinkedListIsAtEnd public  function FTLinkedListIsAtEnd (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value logical procedure, public,  :: object => FTLinkedListObject public  function FTLinkedListObject (self) result(o) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value class( FTObject ), POINTER procedure, public,  :: currentRecord => FTLinkedListCurrentRecord public  function FTLinkedListCurrentRecord (self) result(o) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value class( FTLinkedListRecord ), POINTER procedure, public,  :: linkedList => returnLinkedList public  function returnLinkedList (self) result(o) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value class( FTLinkedList ), POINTER procedure, public,  :: className => linkedListIteratorClassName public  function linkedListIteratorClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTLinkedListIterator \" ) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public,  :: setLinkedList public  subroutine setLinkedList (self, list) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self class( FTLinkedList ), POINTER :: list procedure, public,  :: setToStart public  subroutine setToStart (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self procedure, public,  :: moveToNext public  subroutine moveToNext (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self procedure, public,  :: removeCurrentRecord public  subroutine removeCurrentRecord (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self","tags":"","loc":"type/ftlinkedlistiterator.html"},{"title":"FTException – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTException Inherits type~~ftexception~~InheritsGraph type~ftexception FTException type~ftdictionary FTDictionary type~ftexception->type~ftdictionary infoDictionary_ type~ftobject FTObject type~ftexception->type~ftobject type~ftdictionary->type~ftobject type~ftlinkedlist FTLinkedList type~ftdictionary->type~ftlinkedlist entries type~ftlinkedlist->type~ftobject type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Finalization Procedures destructException Type-Bound Procedures init description copy retain isUnreferenced refCount initFTException initWarningException initFatalException initAssertionFailureException setInfoDictionary infoDictionary exceptionName severity printDescription className Finalization Procedures final :: destructException public  subroutine destructException (self) The destructor for the class. Do not call this direectly. Call\nthe release() procedure instead Arguments Type Intent Optional Attributes Name type( FTException ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: initFTException public  subroutine initFTException (self, severity, exceptionName, infoDictionary) The main initializer for the class Arguments Type Intent Optional Attributes Name class( FTException ) :: self integer :: severity character(len=*) :: exceptionName class( FTDictionary ), optional, POINTER :: infoDictionary procedure, public,  :: initWarningException public  subroutine initWarningException (self, msg) A convenience initializer for a warning error \nthat includes the key \"message\" in the\ninfoDictionary. Use this initializer as an \nexample of how to write one's own exception. Arguments Type Intent Optional Attributes Name class( FTException ) :: self character(len=*) :: msg procedure, public,  :: initFatalException public  subroutine initFatalException (self, msg) A convenience initializer for a fatal error \nthat includes the key \"message\" in the\ninfoDictionary.Use this initializer as an \nexample of how to write one's own exception. Arguments Type Intent Optional Attributes Name class( FTException ) :: self character(len=*) :: msg procedure, public,  :: initAssertionFailureException public  subroutine initAssertionFailureException (self, msg, expectedValueObject, ObservedValueObject, level) A convenience initializer for an assertion error \nthat includes the keys: -\"message\"\n-\"expectedValue\"\n-\"observedValue\" in the infoDictionary Arguments Type Intent Optional Attributes Name class( FTException ) :: self character(len=*) :: msg class( FTValue ), POINTER :: expectedValueObject class( FTValue ), POINTER :: ObservedValueObject integer :: level procedure, public,  :: setInfoDictionary public  subroutine setInfoDictionary (self, dict) Sets and retains the exception infoDictionary Arguments Type Intent Optional Attributes Name class( FTException ) :: self class( FTDictionary ), POINTER :: dict procedure, public,  :: infoDictionary public  function infoDictionary (self) Returns the exception's infoDictionary. Does\nnot transfer ownership/reference count is \nunchanged. Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value class( FTDictionary ), POINTER procedure, public,  :: exceptionName public  function exceptionName (self) Returns the string representing the name set\nfor the exception. Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value character(len=ERROR_MSG_STRING_LENGTH) procedure, public,  :: severity public  function severity (self) Returns the severity level of the exception. Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value integer procedure, public,  :: printDescription => printFTExceptionDescription public  subroutine printFTExceptionDescription (self, iUnit) A basic printing of the exception and the info\nheld in the infoDicitonary. Arguments Type Intent Optional Attributes Name class( FTException ) :: self integer :: iUnit procedure, public,  :: className => exceptionClassName public  function exceptionClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTException \" ) Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH)","tags":"","loc":"type/ftexception.html"},{"title":"FTObject – FTObjectLibrary ","text":"type, public :: FTObject Inherited by type~~ftobject~~InheritedByGraph type~ftobject FTObject type~ftdata FTData type~ftdata->type~ftobject type~ftdictionary FTDictionary type~ftdictionary->type~ftobject type~ftlinkedlist FTLinkedList type~ftdictionary->type~ftlinkedlist entries type~ftexception FTException type~ftexception->type~ftobject type~ftexception->type~ftdictionary infoDictionary_ type~ftkeyobjectpair FTKeyObjectPair type~ftkeyobjectpair->type~ftobject valueObject type~ftkeyobjectpair->type~ftobject type~ftlinkedlist->type~ftobject type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftlinkedlistiterator FTLinkedListIterator type~ftlinkedlistiterator->type~ftobject type~ftlinkedlistiterator->type~ftlinkedlist list type~ftlinkedlistiterator->type~ftlinkedlistrecord current type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous type~ftmultiindextable FTMultiIndexTable type~ftmultiindextable->type~ftobject type~ftmultiindextable->type~ftlinkedlist table type~ftmutableobjectarray FTMutableObjectArray type~ftmutableobjectarray->type~ftobject type~ftobjectpointerwrapper FTObjectPointerWrapper type~ftmutableobjectarray->type~ftobjectpointerwrapper array type~ftobjectpointerwrapper->type~ftobject object type~ftsparsematrix FTSparseMatrix type~ftsparsematrix->type~ftobject type~ftsparsematrix->type~ftlinkedlistiterator iterator type~ftlinkedlistptr FTLinkedListPtr type~ftsparsematrix->type~ftlinkedlistptr table type~ftstringset FTStringSet type~ftstringset->type~ftobject type~ftstringset->type~ftdictionary dict type~ftvalue FTValue type~ftvalue->type~ftobject type~matrixdata MatrixData type~matrixdata->type~ftobject object type~matrixdata->type~ftobject type~multiindexmatrixdata MultiIndexMatrixData type~multiindexmatrixdata->type~ftobject object type~multiindexmatrixdata->type~ftobject type~ftlinkedlistptr->type~ftlinkedlist list type~ftstack FTStack type~ftstack->type~ftlinkedlist type~ftvaluedictionary FTValueDictionary type~ftvaluedictionary->type~ftdictionary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Finalization Procedures destructFTObject Type-Bound Procedures init description printDescription className copy retain isUnreferenced refCount Finalization Procedures final :: destructFTObject public  subroutine destructFTObject (self) Generic Name: destruct() The destructor for the class. The base class destructor does nothing. Arguments Type Intent Optional Attributes Name type( FTObject ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: printDescription => printFTObjectDescription public  subroutine printFTObjectDescription (self, iUnit) Generic Name: printDescription() Prints a string to unit iUnit that represents the contents of the object. FTObject's\n description simply prints its name. Override this in subclasses to print something\n useful. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self integer :: iUnit procedure, public,  :: className public  function className (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTObject \" ) Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer","tags":"","loc":"type/ftobject.html"},{"title":"FTValueDictionary – FTObjectLibrary ","text":"type, public, extends( FTDictionary ) :: FTValueDictionary Inherits type~~ftvaluedictionary~~InheritsGraph type~ftvaluedictionary FTValueDictionary type~ftdictionary FTDictionary type~ftvaluedictionary->type~ftdictionary type~ftlinkedlist FTLinkedList type~ftdictionary->type~ftlinkedlist entries type~ftobject FTObject type~ftdictionary->type~ftobject type~ftlinkedlist->type~ftobject type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables numberOfEntries isCaseSensitive entries Type-Bound Procedures copy retain isUnreferenced refCount initWithSize init allKeys allObjects addObjectForKey description printDescription objectForKey containsKey COUNT addValueForKey addValueForKey realValueForKey doublePrecisionValueForKey quadValueForKey integerValueForKey stringValueForKey logicalValueForKey className Components Type Visibility Attributes Name Initial integer, public :: numberOfEntries logical, public :: isCaseSensitive type( FTLinkedList ), public, DIMENSION(:), POINTER :: entries => NULL() Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: initWithSize public  subroutine initWithSize (self, sze) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self integer, intent(in) :: sze procedure, public,  :: init public  subroutine init (self) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self procedure, public,  :: allKeys => AllKeys public  function AllKeys (self) result(keys) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=FTDICT_KWD_STRING_LENGTH), POINTER, (:) procedure, public,  :: allObjects => AllObjects public  function AllObjects (self) result(objectArray) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value class( FTMutableObjectArray ), POINTER procedure, public,  :: addObjectForKey public  subroutine addObjectForKey (self, object, key) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self class( FTObject ), POINTER :: object character(len=*) :: key procedure, public,  :: description => FTDictionaryDescription public  function FTDictionaryDescription (self) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=description_character_length) procedure, public,  :: printDescription => printFTDictionaryDescription public recursive subroutine printFTDictionaryDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self integer :: iUnit procedure, public,  :: objectForKey public  function objectForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self character(len=*) :: key Return Value class( FTObject ), POINTER procedure, public,  :: containsKey public  function containsKey (self, key) result(r) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self character(len=*) :: key Return Value logical procedure, public,  :: COUNT public  function COUNT (self) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value integer generic, public :: addValueForKey => addRealValueForKey, addDoublePrecisionValueForKey, addIntegerValueForKey, addStringValueForKey, addLogicalValueForKey public  subroutine addRealValueForKey (self, r, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self real :: r character(len=*) :: key public  subroutine addDoublePrecisionValueForKey (self, r, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self double precision :: r character(len=*) :: key public  subroutine addIntegerValueForKey (self, i, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self integer :: i character(len=*) :: key public  subroutine addStringValueForKey (self, s, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: s character(len=*) :: key public  subroutine addLogicalValueForKey (self, l, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self logical :: l character(len=*) :: key generic, public :: addValueForKey => addQuadValueForKey public  subroutine addQuadValueForKey (self, r, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)) :: r character(len=*) :: key procedure, public,  :: realValueForKey public  function realValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value real procedure, public,  :: doublePrecisionValueForKey public  function doublePrecisionValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value doubleprecision procedure, public,  :: quadValueForKey public  function quadValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value real(kind=selected_real_kind(quad_digits)) procedure, public,  :: integerValueForKey public  function integerValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value integer procedure, public,  :: stringValueForKey public  function stringValueForKey (self, key, requestedLength) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key integer :: requestedLength Return Value character(len=requestedLength) procedure, public,  :: logicalValueForKey public  function logicalValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value logical procedure, public,  :: className => valueDictionaryClassName public  function valueDictionaryClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTValueDictionary \" ) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH)","tags":"","loc":"type/ftvaluedictionary.html"},{"title":"FTKeyObjectPair – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTKeyObjectPair Inherits type~~ftkeyobjectpair~~InheritsGraph type~ftkeyobjectpair FTKeyObjectPair type~ftobject FTObject type~ftkeyobjectpair->type~ftobject valueObject type~ftkeyobjectpair->type~ftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables keyString valueObject Finalization Procedures destructFTKeyObjectPair Type-Bound Procedures init className copy retain isUnreferenced refCount initWithObjectAndKey description printDescription key object Components Type Visibility Attributes Name Initial character(len=FTDICT_KWD_STRING_LENGTH), public :: keyString class( FTObject ), public, POINTER :: valueObject => NULL() Finalization Procedures final :: destructFTKeyObjectPair public  subroutine destructFTKeyObjectPair (self) Arguments Type Intent Optional Attributes Name type( FTKeyObjectPair ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: className public  function className (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTObject \" ) Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: initWithObjectAndKey public  subroutine initWithObjectAndKey (self, v, key) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self class( FTObject ), POINTER :: v character(len=*) :: key procedure, public,  :: description => FTKeyObjectPairDescription public  function FTKeyObjectPairDescription (self) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self Return Value character(len=description_character_length) procedure, public,  :: printDescription => printFTKeyObjectPairDescription public recursive subroutine printFTKeyObjectPairDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self integer :: iUnit procedure, public,  :: key public  function key (self) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self Return Value character(len=ftdict_kwd_string_length) procedure, public,  :: object public  function object (self) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self Return Value class( FTObject ), POINTER","tags":"","loc":"type/ftkeyobjectpair.html"},{"title":"FTDictionary – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTDictionary Inherits type~~ftdictionary~~InheritsGraph type~ftdictionary FTDictionary type~ftlinkedlist FTLinkedList type~ftdictionary->type~ftlinkedlist entries type~ftobject FTObject type~ftdictionary->type~ftobject type~ftlinkedlist->type~ftobject type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ftdictionary~~InheritedByGraph type~ftdictionary FTDictionary type~ftexception FTException type~ftexception->type~ftdictionary infoDictionary_ type~ftstringset FTStringSet type~ftstringset->type~ftdictionary dict type~ftvaluedictionary FTValueDictionary type~ftvaluedictionary->type~ftdictionary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables numberOfEntries isCaseSensitive entries Finalization Procedures destructFTDictionary Type-Bound Procedures copy retain isUnreferenced refCount initWithSize init allKeys allObjects addObjectForKey description printDescription objectForKey containsKey className COUNT Components Type Visibility Attributes Name Initial integer, public :: numberOfEntries logical, public :: isCaseSensitive type( FTLinkedList ), public, DIMENSION(:), POINTER :: entries => NULL() Finalization Procedures final :: destructFTDictionary public  subroutine destructFTDictionary (self) Arguments Type Intent Optional Attributes Name type( FTDictionary ) :: self Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public,  :: initWithSize public  subroutine initWithSize (self, sze) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self integer, intent(in) :: sze procedure, public,  :: init public  subroutine init (self) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self procedure, public,  :: allKeys => AllKeys public  function AllKeys (self) result(keys) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=FTDICT_KWD_STRING_LENGTH), POINTER, (:) procedure, public,  :: allObjects => AllObjects public  function AllObjects (self) result(objectArray) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value class( FTMutableObjectArray ), POINTER procedure, public,  :: addObjectForKey public  subroutine addObjectForKey (self, object, key) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self class( FTObject ), POINTER :: object character(len=*) :: key procedure, public,  :: description => FTDictionaryDescription public  function FTDictionaryDescription (self) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=description_character_length) procedure, public,  :: printDescription => printFTDictionaryDescription public recursive subroutine printFTDictionaryDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self integer :: iUnit procedure, public,  :: objectForKey public  function objectForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self character(len=*) :: key Return Value class( FTObject ), POINTER procedure, public,  :: containsKey public  function containsKey (self, key) result(r) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self character(len=*) :: key Return Value logical procedure, public,  :: className => dictionaryClassName public  function dictionaryClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTDictionary \" ) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public,  :: COUNT public  function COUNT (self) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value integer","tags":"","loc":"type/ftdictionary.html"},{"title":"FTValue – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTValue Inherits type~~ftvalue~~InheritsGraph type~ftvalue FTValue type~ftobject FTObject type~ftvalue->type~ftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Finalization Procedures destructValue Type-Bound Procedures init copy retain isUnreferenced refCount initWithValue initWithValue realValue doublePrecisionValue quadValue stringValue logicalValue integerValue description printDescription className Finalization Procedures final :: destructValue public  subroutine destructValue (self) Public, generic name: destruct() Destructor for the class. Arguments Type Intent Optional Attributes Name type( FTValue ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer generic, public :: initWithValue => initWithReal, initWithDoublePrecision, initWithString, initWithLogical, initWithInteger public  subroutine initWithReal (self, v) Public, generic name: initwithValue() Initialize the value object with a real number Arguments Type Intent Optional Attributes Name class( FTValue ) :: self real :: v public  subroutine initWithDoublePrecision (self, v) Public, generic name: initwithValue() Initialize the value object with a double \nprecision number Arguments Type Intent Optional Attributes Name class( FTValue ) :: self doubleprecision :: v public  subroutine initWithString (self, v) Public, generic name: initwithValue() Initialize the value object with a string Arguments Type Intent Optional Attributes Name class( FTValue ) :: self character(len=*) :: v public  subroutine initWithLogical (self, v) Public, generic name: initwithValue() Initialize the value object with a logical Arguments Type Intent Optional Attributes Name class( FTValue ) :: self logical :: v public  subroutine initWithInteger (self, v) Public, generic name: initwithValue() Initialize the value object with an \ninteger number Arguments Type Intent Optional Attributes Name class( FTValue ) :: self integer :: v generic, public :: initWithValue => initWithQuad public  subroutine initWithQuad (self, v) Public, generic name: initwithValue() Initialize the value object with a quad precision\nnumber Arguments Type Intent Optional Attributes Name class( FTValue ) :: self real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)) :: v procedure, public,  :: realValue public  function realValue (self) Get the real value stored in the object, or convert the value\nin the object to a real if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value real procedure, public,  :: doublePrecisionValue public  function doublePrecisionValue (self) Get the double precision value stored in the object, or convert the value\nin the object to a double precision if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value doubleprecision procedure, public,  :: quadValue public  function quadValue (self) Get the double precision value stored in the object, or convert the value\nin the object to a double precision if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value doubleprecision procedure, public,  :: stringValue public  function stringValue (self, requestedLength) result(s) Get the string value of length requestedLength stored in the object, or \nconvert the value\nin the object to a string of that length if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self integer :: requestedLength Return Value character(len=requestedLength) procedure, public,  :: logicalValue public  function logicalValue (self) Get the logical value stored in the object, or convert the value\nin the object to a logical if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value logical procedure, public,  :: integerValue public  function integerValue (self) Get the integer value stored in the object, or convert the value\nin the object to an integer if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value integer procedure, public,  :: description => FTValueDescription public  function FTValueDescription (self) Returns the description of the value. In this case, it returns the \nstringValue() of the object. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public,  :: printDescription => printValueDescription public  subroutine printValueDescription (self, iUnit) Prints the description of the value to unit iUnit. In this case, it prints the stringValue() of the object. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self integer :: iUnit procedure, public,  :: className => valueClassName public  function valueClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTValue \" ) Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH)","tags":"","loc":"type/ftvalue.html"},{"title":"FTStringSet – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTStringSet Inherits type~~ftstringset~~InheritsGraph type~ftstringset FTStringSet type~ftdictionary FTDictionary type~ftstringset->type~ftdictionary dict type~ftobject FTObject type~ftstringset->type~ftobject type~ftdictionary->type~ftobject type~ftlinkedlist FTLinkedList type~ftdictionary->type~ftlinkedlist entries type~ftlinkedlist->type~ftobject type~ftlinkedlistrecord FTLinkedListRecord type~ftlinkedlist->type~ftlinkedlistrecord head, tail type~ftlinkedlistrecord->type~ftobject recordObject type~ftlinkedlistrecord->type~ftobject type~ftlinkedlistrecord->type~ftlinkedlistrecord next, previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Finalization Procedures destructFTStringSet Type-Bound Procedures init description copy retain isUnreferenced refCount initFTStringSet initWithStrings addString containsString strings unionWithSet intersectionWithSet setFromDifference isEmpty count printDescription className Finalization Procedures final :: destructFTStringSet public  subroutine destructFTStringSet (self) Destructor for the class. This is called automatically when the\nreference count reaches zero. Do not call this yourself on pointers Arguments Type Intent Optional Attributes Name type( FTStringSet ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public :: initFTStringSet public  subroutine initFTStringSet (self, FTStringSetSize) Designated initializer. Initializes the amount of storage, but\nthe FTStringSet remains empty. *Usage\n      CLASS(FTStringSet)  :: FTStringSet\n      integer             :: N = 11\n      logical             :: cs = .true.\n      CALL FTStringSet % initFTStringSet(N) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self integer :: FTStringSetSize procedure, public :: initWithStrings public  subroutine initWithStrings (self, strings) initializer. Initializes the amount of storage from the strings passed Usage\n      CLASS(FTStringSet)  :: FTStringSet\n      CHARACTER(LEN= )    :: strings(:)\n      CALL FTStringSet % initWithStrings(strings) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self character(len=*) :: strings (:) procedure, public :: addString => AddString public  subroutine AddString (self, str) AddString adds a string to the set if it is not already present Usage: CALL set % addString(str) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self character(len=*) :: str procedure, public :: containsString public  function containsString (self, str) containsString returns .TRUE. if the set contains the string, .FALSE. \n otherwise. Usage: if ( set % containsString ( str )) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self character(len=*) :: str Return Value logical procedure, public :: strings public  function strings (self) result(s) strings returns a pointer to an array of strings that are in the set.\n Deallocate this array when done with it. Usage: CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) , DIMENSION ( : ) , POINTER :: s s => set % strings ... do something ... DEALLOCATE ( s ) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value character(len=FTDICT_KWD_STRING_LENGTH), DIMENSION(:), POINTER procedure, public :: unionWithSet public  function unionWithSet (self, set) result(newSet) unionWithSet returns a pointer to a new set that is the union of two sets.\n the new set has reference count of 1. Release when done. Usage: newSet => set1 % unionWithSet ( set2 ) ... do something ... call releaseFTStringSet ( newSet ) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self class( FTStringSet ) :: set Return Value type( FTStringSet ), POINTER procedure, public :: intersectionWithSet public  function intersectionWithSet (self, set) result(newSet) intersectionWithSet returns a pointer to a new set that is the intersection of two sets.\n the new set has reference count of 1. Release when done. Usage: newSet => set1 % intersectionWithSet ( set2 ) ... do something ... call releaseFTStringSet ( newSet ) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self class( FTStringSet ) :: set Return Value type( FTStringSet ), POINTER procedure, public :: setFromDifference public  function setFromDifference (self, set) result(newSet) setFromDifference returns a pointer to a new set that is the difference of two sets. the new set has reference count of 1. Release when done. Usage: newSet => set1 % setFromDifference ( set2 ) ... do something ... call releaseFTStringSet ( newSet ) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self class( FTStringSet ) :: set Return Value type( FTStringSet ), POINTER procedure, public :: isEmpty public  function isEmpty (self) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value logical procedure, public :: count => stringCount public  function stringCount (self) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value integer procedure, public :: printDescription => printFTStringSet public  subroutine printFTStringSet (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self integer :: iUnit procedure, public :: className => FTStringSetClassName public  function FTStringSetClassName (self) result(s) Class name returns a string with the name of the type of the object Usage: PRINT * , obj % className () if ( obj % className = \" FTStringSet \" ) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH)","tags":"","loc":"type/ftstringset.html"},{"title":"FTMutableObjectArray – FTObjectLibrary ","text":"type, public, extends( FTObject ) :: FTMutableObjectArray Inherits type~~ftmutableobjectarray~~InheritsGraph type~ftmutableobjectarray FTMutableObjectArray type~ftobject FTObject type~ftmutableobjectarray->type~ftobject type~ftobjectpointerwrapper FTObjectPointerWrapper type~ftmutableobjectarray->type~ftobjectpointerwrapper array type~ftobjectpointerwrapper->type~ftobject object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Finalization Procedures destructObjectArray Type-Bound Procedures init description copy retain isUnreferenced refCount initWithSize addObject replaceObjectAtIndexWithObject removeObjectAtIndex objectAtIndex printDescription className setChunkSize chunkSize COUNT allocatedSize Finalization Procedures final :: destructObjectArray public recursive subroutine destructObjectArray (self) Destructor for the class. This is called automatically when the\nreference count reaches zero. Do not call this yourself. Arguments Type Intent Optional Attributes Name type( FTMutableObjectArray ) :: self Type-Bound Procedures procedure, public,  :: init => initFTObject public  subroutine initFTObject (self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public,  :: description => FTObjectDescription public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) procedure, public, NON_OVERRIDABLE :: copy => copyFTObject private  function copyFTObject(self) result(copy) Base class implemetation of the assignment function. Call this from\n within any subclasses copy assignment function. All FTObject's \n implementation does is set\n the reference count to one, implying no additional ownwership to the \n caller that is creating the copy. Arguments Type Intent Optional Attributes Name class( FTObject ), intent(in) :: self Return Value class( FTObject ), POINTER procedure, public, NON_OVERRIDABLE :: retain => retainFTObject public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self procedure, public, NON_OVERRIDABLE :: isUnreferenced public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical procedure, public, NON_OVERRIDABLE :: refCount public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer procedure, public :: initWithSize => initObjectArrayWithSize public  subroutine initObjectArrayWithSize (self, arraySize) Designated initializer. Initializes the amount of storage, but\nthe array remains empty. *Usage CLASS(FTMutableObjectArray)  :: array\n  integer                      :: N = 11\n  CALL array % initWithSize(N) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: arraySize procedure, public :: addObject => addObjectToArray public  subroutine addObjectToArray (self, obj) Add an object to the end of the array *Usage CLASS(FTMutableObjectArray)      :: array\n  CLASS(FTObject)        , POINTER :: obj\n  CLASS(FTObjectSubclass), POINTER :: p\n  obj => p\n  CALL array % addObject(obj) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self class( FTObject ), POINTER :: obj procedure, public :: replaceObjectAtIndexWithObject public  subroutine replaceObjectAtIndexWithObject (self, indx, replacement) Replace an object at the index indx Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: indx\n  CALL array % replaceObjectAtIndexWithObject(indx) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: indx class( FTObject ), POINTER :: replacement procedure, public :: removeObjectAtIndex public  subroutine removeObjectAtIndex (self, indx) Remove an object at the index indx *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: indx\n  CALL array % removeObjectAtIndex(indx) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: indx procedure, public :: objectAtIndex public  function objectAtIndex (self, indx) result(obj) Access the object at the index indx *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: indx\n  CLASS(FTObject), POINTER    :: obj\n  obj => array % objectAtIndex(indx) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: indx Return Value class( FTObject ), POINTER procedure, public :: printDescription => printArray public  subroutine printArray (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: iUnit procedure, public :: className => arrayClassName public  function arrayClassName (self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTMutableObjectArray \" ) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) procedure, public :: setChunkSize public  subroutine setChunkSize (self, chunkSize) Set the number of items to be added when the array needs to be re-sized *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: sze = 42\n  CALL array % setChunkSize(sze) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: chunkSize procedure, public :: chunkSize public  function chunkSize (self) Returns the number of items to be added when the array needs to be re-sized *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: sze\n  sze =  array % chunkSize Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value integer procedure, public :: COUNT => numberOfItems public  function numberOfItems (self) Generic name: count Returns the acutal number of items in the array. *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: sze\n  sze =  array % count() Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value integer procedure, public :: allocatedSize public  function allocatedSize (self) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value integer","tags":"","loc":"type/ftmutableobjectarray.html"},{"title":"TestSuiteManager – FTObjectLibrary ","text":"type, public :: TestSuiteManager Inherits type~~testsuitemanager~~InheritsGraph type~testsuitemanager TestSuiteManager type~testcaserecord TestCaseRecord type~testsuitemanager->type~testcaserecord testCasesHead, testCasesTail type~testcaserecord->type~testcaserecord next type~ftassertionsmanager FTAssertionsManager type~testcaserecord->type~ftassertionsmanager assertionsManager type~ftassertionfailurerecord FTAssertionFailureRecord type~ftassertionsmanager->type~ftassertionfailurerecord failureListHead, failureListTail type~ftassertionfailurerecord->type~ftassertionfailurerecord next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables numberOfTests stdOut testCasesHead testCasesTail Finalization Procedures finalizeTestSuiteManager Type-Bound Procedures init addTestSubroutineWithName performTests setOutputUnit Components Type Visibility Attributes Name Initial integer, public :: numberOfTests integer, public :: stdOut = 6 type(TestCaseRecord), public, POINTER :: testCasesHead => NULL() type(TestCaseRecord), public, POINTER :: testCasesTail => NULL() Finalization Procedures final :: finalizeTestSuiteManager private  subroutine finalizeTestSuiteManager(self) Arguments Type Intent Optional Attributes Name type( TestSuiteManager ) :: self Type-Bound Procedures procedure, public,  :: init => initializeTestSuiteManager private  subroutine initializeTestSuiteManager(self) Arguments Type Intent Optional Attributes Name class( TestSuiteManager ) :: self procedure, public,  :: addTestSubroutineWithName private  subroutine addTestSubroutineWithName(self, testSubroutine, testName, optData) Arguments Type Intent Optional Attributes Name class( TestSuiteManager ) :: self private  subroutine testSubroutine(optData) Arguments Type Intent Optional Attributes Name character(len=1), optional, POINTER :: optData (:) character(len=*) :: testName character(len=1), optional, POINTER :: optData (:) procedure, public,  :: performTests private  subroutine performTests(self, numberOfFailedTestsRet) Arguments Type Intent Optional Attributes Name class( TestSuiteManager ) :: self integer, optional :: numberOfFailedTestsRet procedure, public,  :: setOutputUnit private  subroutine setOutputUnit(self, iUnit) Arguments Type Intent Optional Attributes Name class( TestSuiteManager ) :: self integer :: iUnit","tags":"","loc":"type/testsuitemanager.html"},{"title":"FTAssertionsManager – FTObjectLibrary ","text":"type, public :: FTAssertionsManager Inherits type~~ftassertionsmanager~~InheritsGraph type~ftassertionsmanager FTAssertionsManager type~ftassertionfailurerecord FTAssertionFailureRecord type~ftassertionsmanager->type~ftassertionfailurerecord failureListHead, failureListTail type~ftassertionfailurerecord->type~ftassertionfailurerecord next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ftassertionsmanager~~InheritedByGraph type~ftassertionsmanager FTAssertionsManager type~testcaserecord TestCaseRecord type~testcaserecord->type~ftassertionsmanager assertionsManager type~testcaserecord->type~testcaserecord next type~testsuitemanager TestSuiteManager type~testsuitemanager->type~testcaserecord testCasesHead, testCasesTail Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Type-Bound Procedures init finalize numberOfAssertionFailures numberOfAssertions summarizeAssertions Type-Bound Procedures procedure, public :: init private  subroutine init(self) Arguments Type Intent Optional Attributes Name class( FTAssertionsManager ) :: self procedure, public :: finalize private  subroutine finalize(self) Arguments Type Intent Optional Attributes Name class( FTAssertionsManager ) :: self procedure, public :: numberOfAssertionFailures public  function numberOfAssertionFailures (self) Arguments Type Intent Optional Attributes Name class( FTAssertionsManager ) :: self Return Value integer procedure, public :: numberOfAssertions public  function numberOfAssertions (self) Arguments Type Intent Optional Attributes Name class( FTAssertionsManager ) :: self Return Value integer procedure, public :: summarizeAssertions private  subroutine summarizeAssertions(self, title, iUnit) Arguments Type Intent Optional Attributes Name class( FTAssertionsManager ) :: self character(len=*) :: title integer :: iUnit","tags":"","loc":"type/ftassertionsmanager.html"},{"title":"assertInfoArray1D – FTObjectLibrary ","text":"type, public :: assertInfoArray1D Contents Variables failureName failureType locations Components Type Visibility Attributes Name Initial character(len=128), public :: failureName integer, public :: failureType logical, public, DIMENSION(:), ALLOCATABLE :: locations","tags":"","loc":"type/assertinfoarray1d.html"},{"title":"assertInfoArray2D – FTObjectLibrary ","text":"type, public :: assertInfoArray2D Contents Variables failureName failureType locations Components Type Visibility Attributes Name Initial character(len=128), public :: failureName integer, public :: failureType logical, public, DIMENSION(:,:), ALLOCATABLE :: locations","tags":"","loc":"type/assertinfoarray2d.html"},{"title":"b3hs_hash_key_jenkins – FTObjectLibrary","text":"public  function b3hs_hash_key_jenkins(key, range) result(code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key integer, intent(in) :: range Return Value integer Called by proc~~b3hs_hash_key_jenkins~~CalledByGraph proc~b3hs_hash_key_jenkins HashModule::b3hs_hash_key_jenkins proc~addobjectforkey FTDictionaryClass::FTDictionary%addObjectForKey proc~addobjectforkey->proc~b3hs_hash_key_jenkins proc~objectforkey FTDictionaryClass::FTDictionary%objectForKey proc~objectforkey->proc~b3hs_hash_key_jenkins Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/b3hs_hash_key_jenkins.html"},{"title":"matrixDataCast – FTObjectLibrary","text":"public  function matrixDataCast(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( MatrixData ), POINTER Contents","tags":"","loc":"proc/matrixdatacast.html"},{"title":"initWithObjectAndKey – FTObjectLibrary","text":"public  subroutine initWithObjectAndKey(self, object, key) Type Bound MatrixData Arguments Type Intent Optional Attributes Name class( MatrixData ) :: self class( FTObject ), POINTER :: object integer :: key Contents","tags":"","loc":"proc/initwithobjectandkey.html"},{"title":"releaseFTMatrixData – FTObjectLibrary","text":"public  subroutine releaseFTMatrixData(self) Arguments Type Intent Optional Attributes Name type( MatrixData ), POINTER :: self Calls proc~~releaseftmatrixdata~~CallsGraph proc~releaseftmatrixdata FTSparseMatrixData::releaseFTMatrixData interface~release FTObjectClass::release proc~releaseftmatrixdata->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftmatrixdata.html"},{"title":"destructMatrixData – FTObjectLibrary","text":"public  subroutine destructMatrixData(self) Arguments Type Intent Optional Attributes Name type( MatrixData ) :: self Calls proc~~destructmatrixdata~~CallsGraph proc~destructmatrixdata FTSparseMatrixData::destructMatrixData proc~releaseftobject FTObjectClass::releaseFTObject proc~destructmatrixdata->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/destructmatrixdata.html"},{"title":"castObjectToMatrixData – FTObjectLibrary","text":"public  subroutine castObjectToMatrixData(obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( MatrixData ), POINTER :: cast Called by proc~~castobjecttomatrixdata~~CalledByGraph proc~castobjecttomatrixdata FTSparseMatrixData::castObjectToMatrixData interface~cast FTSparseMatrixData::cast interface~cast->proc~castobjecttomatrixdata proc~objectinsparsematrixforkeys FTSparseMatrixClass::FTSparseMatrix%objectInSparseMatrixForKeys proc~objectinsparsematrixforkeys->interface~cast proc~sparsematrixcontainskeys FTSparseMatrixClass::FTSparseMatrix%SparseMatrixContainsKeys proc~sparsematrixcontainskeys->interface~cast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/castobjecttomatrixdata.html"},{"title":"cast – FTObjectLibrary","text":"public interface cast Calls interface~~cast~~CallsGraph interface~cast FTSparseMatrixData::cast proc~castobjecttomatrixdata FTSparseMatrixData::castObjectToMatrixData interface~cast->proc~castobjecttomatrixdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~cast~~CalledByGraph interface~cast FTSparseMatrixData::cast proc~objectinsparsematrixforkeys FTSparseMatrixClass::FTSparseMatrix%objectInSparseMatrixForKeys proc~objectinsparsematrixforkeys->interface~cast proc~sparsematrixcontainskeys FTSparseMatrixClass::FTSparseMatrix%SparseMatrixContainsKeys proc~sparsematrixcontainskeys->interface~cast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures castObjectToMatrixData Module Procedures public  subroutine castObjectToMatrixData (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( MatrixData ), POINTER :: cast","tags":"","loc":"interface/cast.html"},{"title":"objectInSparseMatrixForKeys – FTObjectLibrary","text":"public  function objectInSparseMatrixForKeys(self, i, j) result(r) Type Bound FTSparseMatrix Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self integer :: i integer :: j Return Value class( FTObject ), POINTER Calls proc~~objectinsparsematrixforkeys~~CallsGraph proc~objectinsparsematrixforkeys FTSparseMatrixClass::FTSparseMatrix%objectInSparseMatrixForKeys interface~cast FTSparseMatrixData::cast proc~objectinsparsematrixforkeys->interface~cast proc~castobjecttomatrixdata FTSparseMatrixData::castObjectToMatrixData interface~cast->proc~castobjecttomatrixdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/objectinsparsematrixforkeys.html"},{"title":"SparseMatrixContainsKeys – FTObjectLibrary","text":"public  function SparseMatrixContainsKeys(self, i, j) result(r) Type Bound FTSparseMatrix Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self integer :: i integer :: j Return Value logical Calls proc~~sparsematrixcontainskeys~~CallsGraph proc~sparsematrixcontainskeys FTSparseMatrixClass::FTSparseMatrix%SparseMatrixContainsKeys interface~cast FTSparseMatrixData::cast proc~sparsematrixcontainskeys->interface~cast proc~castobjecttomatrixdata FTSparseMatrixData::castObjectToMatrixData interface~cast->proc~castobjecttomatrixdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/sparsematrixcontainskeys.html"},{"title":"SparseMatrixSize – FTObjectLibrary","text":"public  function SparseMatrixSize(self) Type Bound FTSparseMatrix Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self Return Value integer Contents","tags":"","loc":"proc/sparsematrixsize.html"},{"title":"SparseMatrixFromObject – FTObjectLibrary","text":"public  function SparseMatrixFromObject(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTSparseMatrix ), POINTER Contents","tags":"","loc":"proc/sparsematrixfromobject.html"},{"title":"Hash1 – FTObjectLibrary","text":"public  function Hash1(idPair) Arguments Type Intent Optional Attributes Name integer, DIMENSION(2) :: idPair Return Value integer Contents","tags":"","loc":"proc/hash1.html"},{"title":"Hash2 – FTObjectLibrary","text":"public  function Hash2(idPair) Arguments Type Intent Optional Attributes Name integer, DIMENSION(2) :: idPair Return Value integer Contents","tags":"","loc":"proc/hash2.html"},{"title":"initSparseMatrixWithSize – FTObjectLibrary","text":"public  subroutine initSparseMatrixWithSize(self, N) Type Bound FTSparseMatrix Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self integer :: N Contents","tags":"","loc":"proc/initsparsematrixwithsize.html"},{"title":"addObjectToSparseMatrixForKeys – FTObjectLibrary","text":"public  subroutine addObjectToSparseMatrixForKeys(self, obj, i, j) Type Bound FTSparseMatrix Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self class( FTObject ), POINTER :: obj integer :: i integer :: j Calls proc~~addobjecttosparsematrixforkeys~~CallsGraph proc~addobjecttosparsematrixforkeys FTSparseMatrixClass::FTSparseMatrix%addObjectToSparseMatrixForKeys proc~releaseftobject FTObjectClass::releaseFTObject proc~addobjecttosparsematrixforkeys->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/addobjecttosparsematrixforkeys.html"},{"title":"releaseFTSparseMatrix – FTObjectLibrary","text":"public  subroutine releaseFTSparseMatrix(self) Arguments Type Intent Optional Attributes Name type( FTSparseMatrix ), POINTER :: self Calls proc~~releaseftsparsematrix~~CallsGraph proc~releaseftsparsematrix FTSparseMatrixClass::releaseFTSparseMatrix interface~release FTObjectClass::release proc~releaseftsparsematrix->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftsparsematrix.html"},{"title":"destructSparseMatrix – FTObjectLibrary","text":"public  subroutine destructSparseMatrix(self) Arguments Type Intent Optional Attributes Name type( FTSparseMatrix ) :: self Calls proc~~destructsparsematrix~~CallsGraph proc~destructsparsematrix FTSparseMatrixClass::destructSparseMatrix proc~releasesmmemberlist FTSparseMatrixClass::releaseSMMemberList proc~destructsparsematrix->proc~releasesmmemberlist proc~releaseftobject FTObjectClass::releaseFTObject proc~releasesmmemberlist->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/destructsparsematrix.html"},{"title":"releaseSMMemberList – FTObjectLibrary","text":"public  subroutine releaseSMMemberList(list) Arguments Type Intent Optional Attributes Name class( FTLinkedList ), POINTER :: list Calls proc~~releasesmmemberlist~~CallsGraph proc~releasesmmemberlist FTSparseMatrixClass::releaseSMMemberList proc~releaseftobject FTObjectClass::releaseFTObject proc~releasesmmemberlist->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~releasesmmemberlist~~CalledByGraph proc~releasesmmemberlist FTSparseMatrixClass::releaseSMMemberList proc~destructsparsematrix FTSparseMatrixClass::destructSparseMatrix proc~destructsparsematrix->proc~releasesmmemberlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releasesmmemberlist.html"},{"title":"peek – FTObjectLibrary","text":"public  function peek(self) Type Bound FTStack Arguments Type Intent Optional Attributes Name class( FTStack ) :: self Return Value class( FTObject ), POINTER Contents","tags":"","loc":"proc/peek.html"},{"title":"stackFromObject – FTObjectLibrary","text":"public  function stackFromObject(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTStack ), POINTER Contents","tags":"","loc":"proc/stackfromobject.html"},{"title":"stackClassName – FTObjectLibrary","text":"public  function stackClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTStack \" ) Type Bound FTStack Arguments Type Intent Optional Attributes Name class( FTStack ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/stackclassname.html"},{"title":"initFTStack – FTObjectLibrary","text":"public  subroutine initFTStack(self) Public, generic name: init() Initialize the stack. Type Bound FTStack Arguments Type Intent Optional Attributes Name class( FTStack ) :: self Contents","tags":"","loc":"proc/initftstack.html"},{"title":"releaseFTStack – FTObjectLibrary","text":"public  subroutine releaseFTStack(self) Arguments Type Intent Optional Attributes Name type( FTStack ), POINTER :: self Calls proc~~releaseftstack~~CallsGraph proc~releaseftstack FTStackClass::releaseFTStack interface~release FTObjectClass::release proc~releaseftstack->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftstack.html"},{"title":"push – FTObjectLibrary","text":"public  subroutine push(self, obj) Type Bound FTStack Arguments Type Intent Optional Attributes Name class( FTStack ) :: self class( FTObject ), POINTER :: obj Contents","tags":"","loc":"proc/push.html"},{"title":"pop – FTObjectLibrary","text":"public  subroutine pop(self, p) Type Bound FTStack Arguments Type Intent Optional Attributes Name class( FTStack ) :: self class( FTObject ), POINTER :: p Calls proc~~pop~~CallsGraph proc~pop FTStackClass::FTStack%pop interface~release FTObjectClass::release proc~pop->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/pop.html"},{"title":"printStackDescription – FTObjectLibrary","text":"public  subroutine printStackDescription(self, iUnit) Type Bound FTStack Arguments Type Intent Optional Attributes Name class( FTStack ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printstackdescription.html"},{"title":"MultiIndexMatrixDataCast – FTObjectLibrary","text":"public  function MultiIndexMatrixDataCast(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( MultiIndexMatrixData ), POINTER Contents","tags":"","loc":"proc/multiindexmatrixdatacast.html"},{"title":"initWithObjectAndKeys – FTObjectLibrary","text":"public  subroutine initWithObjectAndKeys(self, object, key) Type Bound MultiIndexMatrixData Arguments Type Intent Optional Attributes Name class( MultiIndexMatrixData ) :: self class( FTObject ), POINTER :: object integer :: key (:) Contents","tags":"","loc":"proc/initwithobjectandkeys.html"},{"title":"releaseFTMultiIndexMatrixData – FTObjectLibrary","text":"public  subroutine releaseFTMultiIndexMatrixData(self) Arguments Type Intent Optional Attributes Name type( MultiIndexMatrixData ), POINTER :: self Calls proc~~releaseftmultiindexmatrixdata~~CallsGraph proc~releaseftmultiindexmatrixdata FTMultiIndexTableData::releaseFTMultiIndexMatrixData interface~release FTObjectClass::release proc~releaseftmultiindexmatrixdata->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftmultiindexmatrixdata.html"},{"title":"destructMultiIndexMatrixData – FTObjectLibrary","text":"public  subroutine destructMultiIndexMatrixData(self) Arguments Type Intent Optional Attributes Name type( MultiIndexMatrixData ) :: self Calls proc~~destructmultiindexmatrixdata~~CallsGraph proc~destructmultiindexmatrixdata FTMultiIndexTableData::destructMultiIndexMatrixData proc~releaseftobject FTObjectClass::releaseFTObject proc~destructmultiindexmatrixdata->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/destructmultiindexmatrixdata.html"},{"title":"castObjectToMultiIndexMatrixData – FTObjectLibrary","text":"public  subroutine castObjectToMultiIndexMatrixData(obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( MultiIndexMatrixData ), POINTER :: cast Called by proc~~castobjecttomultiindexmatrixdata~~CalledByGraph proc~castobjecttomultiindexmatrixdata FTMultiIndexTableData::castObjectToMultiIndexMatrixData interface~cast~2 FTMultiIndexTableData::cast interface~cast~2->proc~castobjecttomultiindexmatrixdata proc~multiindextablecontainskeys FTMultiIndexTableClass::FTMultiIndexTable%MultiIndexTableContainsKeys proc~multiindextablecontainskeys->interface~cast~2 proc~objectinmultiindextableforkeys FTMultiIndexTableClass::FTMultiIndexTable%objectInMultiIndexTableForKeys proc~objectinmultiindextableforkeys->interface~cast~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/castobjecttomultiindexmatrixdata.html"},{"title":"cast – FTObjectLibrary","text":"public interface cast Calls interface~~cast~2~~CallsGraph interface~cast~2 FTMultiIndexTableData::cast proc~castobjecttomultiindexmatrixdata FTMultiIndexTableData::castObjectToMultiIndexMatrixData interface~cast~2->proc~castobjecttomultiindexmatrixdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~cast~2~~CalledByGraph interface~cast~2 FTMultiIndexTableData::cast proc~multiindextablecontainskeys FTMultiIndexTableClass::FTMultiIndexTable%MultiIndexTableContainsKeys proc~multiindextablecontainskeys->interface~cast~2 proc~objectinmultiindextableforkeys FTMultiIndexTableClass::FTMultiIndexTable%objectInMultiIndexTableForKeys proc~objectinmultiindextableforkeys->interface~cast~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures castObjectToMultiIndexMatrixData Module Procedures public  subroutine castObjectToMultiIndexMatrixData (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( MultiIndexMatrixData ), POINTER :: cast","tags":"","loc":"interface/cast~2.html"},{"title":"objectInMultiIndexTableForKeys – FTObjectLibrary","text":"public  function objectInMultiIndexTableForKeys(self, keys) result(r) Type Bound FTMultiIndexTable Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: keys (:) Return Value class( FTObject ), POINTER Calls proc~~objectinmultiindextableforkeys~~CallsGraph proc~objectinmultiindextableforkeys FTMultiIndexTableClass::FTMultiIndexTable%objectInMultiIndexTableForKeys interface~cast~2 FTMultiIndexTableData::cast proc~objectinmultiindextableforkeys->interface~cast~2 proc~keysmatch FTMultiIndexTableClass::keysMatch proc~objectinmultiindextableforkeys->proc~keysmatch proc~sortkeysascending FTMultiIndexTableClass::sortKeysAscending proc~objectinmultiindextableforkeys->proc~sortkeysascending proc~castobjecttomultiindexmatrixdata FTMultiIndexTableData::castObjectToMultiIndexMatrixData interface~cast~2->proc~castobjecttomultiindexmatrixdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/objectinmultiindextableforkeys.html"},{"title":"MultiIndexTableContainsKeys – FTObjectLibrary","text":"public  function MultiIndexTableContainsKeys(self, keys) result(r) Type Bound FTMultiIndexTable Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: keys (:) Return Value logical Calls proc~~multiindextablecontainskeys~~CallsGraph proc~multiindextablecontainskeys FTMultiIndexTableClass::FTMultiIndexTable%MultiIndexTableContainsKeys interface~cast~2 FTMultiIndexTableData::cast proc~multiindextablecontainskeys->interface~cast~2 proc~keysmatch FTMultiIndexTableClass::keysMatch proc~multiindextablecontainskeys->proc~keysmatch proc~sortkeysascending FTMultiIndexTableClass::sortKeysAscending proc~multiindextablecontainskeys->proc~sortkeysascending proc~castobjecttomultiindexmatrixdata FTMultiIndexTableData::castObjectToMultiIndexMatrixData interface~cast~2->proc~castobjecttomultiindexmatrixdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/multiindextablecontainskeys.html"},{"title":"MultiIndexTableSize – FTObjectLibrary","text":"public  function MultiIndexTableSize(self) Type Bound FTMultiIndexTable Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self Return Value integer Contents","tags":"","loc":"proc/multiindextablesize.html"},{"title":"MultiIndexTableFromObject – FTObjectLibrary","text":"public  function MultiIndexTableFromObject(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTMultiIndexTable ), POINTER Contents","tags":"","loc":"proc/multiindextablefromobject.html"},{"title":"keysMatch – FTObjectLibrary","text":"public  function keysMatch(key1, key2) Arguments Type Intent Optional Attributes Name integer, DIMENSION(:) :: key1 integer, DIMENSION(:) :: key2 Return Value logical Called by proc~~keysmatch~~CalledByGraph proc~keysmatch FTMultiIndexTableClass::keysMatch proc~multiindextablecontainskeys FTMultiIndexTableClass::FTMultiIndexTable%MultiIndexTableContainsKeys proc~multiindextablecontainskeys->proc~keysmatch proc~objectinmultiindextableforkeys FTMultiIndexTableClass::FTMultiIndexTable%objectInMultiIndexTableForKeys proc~objectinmultiindextableforkeys->proc~keysmatch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/keysmatch.html"},{"title":"initMultiIndexTableWithSize – FTObjectLibrary","text":"public  subroutine initMultiIndexTableWithSize(self, N) Type Bound FTMultiIndexTable Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: N Contents","tags":"","loc":"proc/initmultiindextablewithsize.html"},{"title":"releaseFTMultiIndexTable – FTObjectLibrary","text":"public  subroutine releaseFTMultiIndexTable(self) Arguments Type Intent Optional Attributes Name type( FTMultiIndexTable ), POINTER :: self Calls proc~~releaseftmultiindextable~~CallsGraph proc~releaseftmultiindextable FTMultiIndexTableClass::releaseFTMultiIndexTable interface~release FTObjectClass::release proc~releaseftmultiindextable->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftmultiindextable.html"},{"title":"destructMultiIndexTable – FTObjectLibrary","text":"public  subroutine destructMultiIndexTable(self) Arguments Type Intent Optional Attributes Name type( FTMultiIndexTable ) :: self Contents","tags":"","loc":"proc/destructmultiindextable.html"},{"title":"addObjectToMultiIndexTableForKeys – FTObjectLibrary","text":"public  subroutine addObjectToMultiIndexTableForKeys(self, obj, keys) Type Bound FTMultiIndexTable Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self class( FTObject ), POINTER :: obj integer :: keys (:) Calls proc~~addobjecttomultiindextableforkeys~~CallsGraph proc~addobjecttomultiindextableforkeys FTMultiIndexTableClass::FTMultiIndexTable%addObjectToMultiIndexTableForKeys proc~releaseftobject FTObjectClass::releaseFTObject proc~addobjecttomultiindextableforkeys->proc~releaseftobject proc~sortkeysascending FTMultiIndexTableClass::sortKeysAscending proc~addobjecttomultiindextableforkeys->proc~sortkeysascending Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/addobjecttomultiindextableforkeys.html"},{"title":"sortKeysAscending – FTObjectLibrary","text":"public  subroutine sortKeysAscending(keys) Arguments Type Intent Optional Attributes Name integer, DIMENSION(:) :: keys Called by proc~~sortkeysascending~~CalledByGraph proc~sortkeysascending FTMultiIndexTableClass::sortKeysAscending proc~addobjecttomultiindextableforkeys FTMultiIndexTableClass::FTMultiIndexTable%addObjectToMultiIndexTableForKeys proc~addobjecttomultiindextableforkeys->proc~sortkeysascending proc~multiindextablecontainskeys FTMultiIndexTableClass::FTMultiIndexTable%MultiIndexTableContainsKeys proc~multiindextablecontainskeys->proc~sortkeysascending proc~objectinmultiindextableforkeys FTMultiIndexTableClass::FTMultiIndexTable%objectInMultiIndexTableForKeys proc~objectinmultiindextableforkeys->proc~sortkeysascending Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/sortkeysascending.html"},{"title":"printMultiIndexTableDescription – FTObjectLibrary","text":"public  subroutine printMultiIndexTableDescription(self, iUnit) Type Bound FTMultiIndexTable Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printmultiindextabledescription.html"},{"title":"storedData – FTObjectLibrary","text":"public  function storedData(self) result(d) Type Bound FTData Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value character(len=1), POINTER, (:) Contents","tags":"","loc":"proc/storeddata.html"},{"title":"storedDataSize – FTObjectLibrary","text":"public  function storedDataSize(self) Type Bound FTData Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value integer Contents","tags":"","loc":"proc/storeddatasize.html"},{"title":"dataType – FTObjectLibrary","text":"public  function dataType(self) result(t) Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value character(len=DATA_CLASS_TYPE_LENGTH) Contents","tags":"","loc":"proc/datatype.html"},{"title":"dataFromObject – FTObjectLibrary","text":"public  function dataFromObject(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTData ), POINTER Contents","tags":"","loc":"proc/datafromobject.html"},{"title":"dataClassName – FTObjectLibrary","text":"public  function dataClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTData \" ) Type Bound FTData Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/dataclassname.html"},{"title":"dataIsOfType – FTObjectLibrary","text":"public  function dataIsOfType(self, dataType) result(t) Arguments Type Intent Optional Attributes Name class( FTData ) :: self character(len=DATA_CLASS_TYPE_LENGTH) :: dataType Return Value logical Contents","tags":"","loc":"proc/dataisoftype.html"},{"title":"initWithDataOfType – FTObjectLibrary","text":"public  subroutine initWithDataOfType(self, genericData, dataType) Type Bound FTData Arguments Type Intent Optional Attributes Name class( FTData ) :: self character(len=1) :: genericData (:) character(len=*) :: dataType Contents","tags":"","loc":"proc/initwithdataoftype.html"},{"title":"destructData – FTObjectLibrary","text":"public  subroutine destructData(self) Arguments Type Intent Optional Attributes Name type( FTData ) :: self Contents","tags":"","loc":"proc/destructdata.html"},{"title":"releaseFTData – FTObjectLibrary","text":"public  subroutine releaseFTData(self) Arguments Type Intent Optional Attributes Name type( FTData ), POINTER :: self Calls proc~~releaseftdata~~CallsGraph proc~releaseftdata FTDataClass::releaseFTData interface~release FTObjectClass::release proc~releaseftdata->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftdata.html"},{"title":"llRecordClassName – FTObjectLibrary","text":"public  function llRecordClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTLinkedListRecord \" ) Type Bound FTLinkedListRecord Arguments Type Intent Optional Attributes Name class( FTLinkedListRecord ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/llrecordclassname.html"},{"title":"initWithObject – FTObjectLibrary","text":"public  subroutine initWithObject(self, obj) Type Bound FTLinkedListRecord Arguments Type Intent Optional Attributes Name class( FTLinkedListRecord ) :: self class( FTObject ), POINTER :: obj Contents","tags":"","loc":"proc/initwithobject.html"},{"title":"destructFTLinkedListRecord – FTObjectLibrary","text":"public  subroutine destructFTLinkedListRecord(self) Arguments Type Intent Optional Attributes Name type( FTLinkedListRecord ) :: self Calls proc~~destructftlinkedlistrecord~~CallsGraph proc~destructftlinkedlistrecord FTLinkedListRecordClass::destructFTLinkedListRecord proc~releaseftobject FTObjectClass::releaseFTObject proc~destructftlinkedlistrecord->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/destructftlinkedlistrecord.html"},{"title":"releaseFTLinkedListRecord – FTObjectLibrary","text":"public  subroutine releaseFTLinkedListRecord(self) Arguments Type Intent Optional Attributes Name type( FTLinkedListRecord ), POINTER :: self Calls proc~~releaseftlinkedlistrecord~~CallsGraph proc~releaseftlinkedlistrecord FTLinkedListRecordClass::releaseFTLinkedListRecord interface~release FTObjectClass::release proc~releaseftlinkedlistrecord->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftlinkedlistrecord.html"},{"title":"printFTLinkedRecordDescription – FTObjectLibrary","text":"public recursive subroutine printFTLinkedRecordDescription(self, iUnit) Type Bound FTLinkedListRecord Arguments Type Intent Optional Attributes Name class( FTLinkedListRecord ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printftlinkedrecorddescription.html"},{"title":"isCircular – FTObjectLibrary","text":"public  function isCircular(self) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value logical Contents","tags":"","loc":"proc/iscircular.html"},{"title":"numberOfRecords – FTObjectLibrary","text":"public  function numberOfRecords(self) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value integer Contents","tags":"","loc":"proc/numberofrecords.html"},{"title":"FTLinkedListDescription – FTObjectLibrary","text":"public  function FTLinkedListDescription(self) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/ftlinkedlistdescription.html"},{"title":"allLinkedListObjects – FTObjectLibrary","text":"public  function allLinkedListObjects(self) result(array) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value class( FTMutableObjectArray ), POINTER Contents","tags":"","loc":"proc/alllinkedlistobjects.html"},{"title":"linkedListClassName – FTObjectLibrary","text":"public  function linkedListClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTLinkedList \" ) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/linkedlistclassname.html"},{"title":"linkedListFromObject – FTObjectLibrary","text":"public  function linkedListFromObject(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTLinkedList ), POINTER Contents","tags":"","loc":"proc/linkedlistfromobject.html"},{"title":"initFTLinkedList – FTObjectLibrary","text":"public  subroutine initFTLinkedList(self) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Contents","tags":"","loc":"proc/initftlinkedlist.html"},{"title":"add – FTObjectLibrary","text":"public  subroutine add(self, obj) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj Contents","tags":"","loc":"proc/add.html"},{"title":"addObjectsFromList – FTObjectLibrary","text":"public  subroutine addObjectsFromList(self, list) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTLinkedList ), POINTER :: list Contents","tags":"","loc":"proc/addobjectsfromlist.html"},{"title":"insertObjectAfterRecord – FTObjectLibrary","text":"public  subroutine insertObjectAfterRecord(self, obj, after) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj class( FTLinkedListRecord ), POINTER :: after Contents","tags":"","loc":"proc/insertobjectafterrecord.html"},{"title":"insertObjectAfterObject – FTObjectLibrary","text":"public  subroutine insertObjectAfterObject(self, obj, after) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj class( FTObject ), POINTER :: after Contents","tags":"","loc":"proc/insertobjectafterobject.html"},{"title":"makeCircular – FTObjectLibrary","text":"public  subroutine makeCircular(self, circular) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self logical :: circular Contents","tags":"","loc":"proc/makecircular.html"},{"title":"removeObject1 – FTObjectLibrary","text":"public  subroutine removeObject1(self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj Calls proc~~removeobject1~~CallsGraph proc~removeobject1 FTLinkedListClass::removeObject1 interface~release FTObjectClass::release proc~removeobject1->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/removeobject1.html"},{"title":"removeObject – FTObjectLibrary","text":"public  subroutine removeObject(self, obj) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj Contents","tags":"","loc":"proc/removeobject.html"},{"title":"removeLinkedListRecord – FTObjectLibrary","text":"public  subroutine removeLinkedListRecord(self, listRecord) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTLinkedListRecord ), POINTER :: listRecord Calls proc~~removelinkedlistrecord~~CallsGraph proc~removelinkedlistrecord FTLinkedListClass::FTLinkedList%removeLinkedListRecord interface~release FTObjectClass::release proc~removelinkedlistrecord->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/removelinkedlistrecord.html"},{"title":"removeAllLinkedListObjects – FTObjectLibrary","text":"public  subroutine removeAllLinkedListObjects(self) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Calls proc~~removealllinkedlistobjects~~CallsGraph proc~removealllinkedlistobjects FTLinkedListClass::FTLinkedList%removeAllLinkedListObjects interface~release FTObjectClass::release proc~removealllinkedlistobjects->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/removealllinkedlistobjects.html"},{"title":"releaseFTLinkedList – FTObjectLibrary","text":"public  subroutine releaseFTLinkedList(self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ), POINTER :: self Calls proc~~releaseftlinkedlist~~CallsGraph proc~releaseftlinkedlist FTLinkedListClass::releaseFTLinkedList interface~release FTObjectClass::release proc~releaseftlinkedlist->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftlinkedlist.html"},{"title":"destructFTLinkedList – FTObjectLibrary","text":"public  subroutine destructFTLinkedList(self) It is automatically called by release(). Arguments Type Intent Optional Attributes Name type( FTLinkedList ) :: self Contents","tags":"","loc":"proc/destructftlinkedlist.html"},{"title":"printFTLinkedListDescription – FTObjectLibrary","text":"public recursive subroutine printFTLinkedListDescription(self, iUnit) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printftlinkedlistdescription.html"},{"title":"reverseLinkedList – FTObjectLibrary","text":"public  subroutine reverseLinkedList(self) Type Bound FTLinkedList Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Contents","tags":"","loc":"proc/reverselinkedlist.html"},{"title":"castObjectToLinkedList – FTObjectLibrary","text":"public  subroutine castObjectToLinkedList(obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTLinkedList ), POINTER :: cast Called by proc~~castobjecttolinkedlist~~CalledByGraph proc~castobjecttolinkedlist FTLinkedListClass::castObjectToLinkedList interface~cast~3 FTLinkedListClass::cast interface~cast~3->proc~castobjecttolinkedlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/castobjecttolinkedlist.html"},{"title":"cast – FTObjectLibrary","text":"public interface cast Calls interface~~cast~3~~CallsGraph interface~cast~3 FTLinkedListClass::cast proc~castobjecttolinkedlist FTLinkedListClass::castObjectToLinkedList interface~cast~3->proc~castobjecttolinkedlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures castObjectToLinkedList Module Procedures public  subroutine castObjectToLinkedList (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTLinkedList ), POINTER :: cast","tags":"","loc":"interface/cast~3.html"},{"title":"FTLinkedListIsAtEnd – FTObjectLibrary","text":"public  function FTLinkedListIsAtEnd(self) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value logical Contents","tags":"","loc":"proc/ftlinkedlistisatend.html"},{"title":"returnLinkedList – FTObjectLibrary","text":"public  function returnLinkedList(self) result(o) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value class( FTLinkedList ), POINTER Contents","tags":"","loc":"proc/returnlinkedlist.html"},{"title":"FTLinkedListObject – FTObjectLibrary","text":"public  function FTLinkedListObject(self) result(o) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value class( FTObject ), POINTER Contents","tags":"","loc":"proc/ftlinkedlistobject.html"},{"title":"FTLinkedListCurrentRecord – FTObjectLibrary","text":"public  function FTLinkedListCurrentRecord(self) result(o) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value class( FTLinkedListRecord ), POINTER Contents","tags":"","loc":"proc/ftlinkedlistcurrentrecord.html"},{"title":"linkedListIteratorClassName – FTObjectLibrary","text":"public  function linkedListIteratorClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTLinkedListIterator \" ) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/linkedlistiteratorclassname.html"},{"title":"initEmpty – FTObjectLibrary","text":"public  subroutine initEmpty(self) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Contents","tags":"","loc":"proc/initempty.html"},{"title":"initWithFTLinkedList – FTObjectLibrary","text":"public  subroutine initWithFTLinkedList(self, list) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self class( FTLinkedList ), POINTER :: list Contents","tags":"","loc":"proc/initwithftlinkedlist.html"},{"title":"releaseFTLinkedListIterator – FTObjectLibrary","text":"public  subroutine releaseFTLinkedListIterator(self) Arguments Type Intent Optional Attributes Name type( FTLinkedListIterator ), POINTER :: self Calls proc~~releaseftlinkedlistiterator~~CallsGraph proc~releaseftlinkedlistiterator FTLinkedListIteratorClass::releaseFTLinkedListIterator interface~release FTObjectClass::release proc~releaseftlinkedlistiterator->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftlinkedlistiterator.html"},{"title":"destructIterator – FTObjectLibrary","text":"public  subroutine destructIterator(self) Arguments Type Intent Optional Attributes Name type( FTLinkedListIterator ) :: self Calls proc~~destructiterator~~CallsGraph proc~destructiterator FTLinkedListIteratorClass::destructIterator proc~releasememberlist FTLinkedListIteratorClass::releaseMemberList proc~destructiterator->proc~releasememberlist proc~releaseftobject FTObjectClass::releaseFTObject proc~releasememberlist->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/destructiterator.html"},{"title":"releaseMemberList – FTObjectLibrary","text":"public  subroutine releaseMemberList(self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Calls proc~~releasememberlist~~CallsGraph proc~releasememberlist FTLinkedListIteratorClass::releaseMemberList proc~releaseftobject FTObjectClass::releaseFTObject proc~releasememberlist->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~releasememberlist~~CalledByGraph proc~releasememberlist FTLinkedListIteratorClass::releaseMemberList proc~destructiterator FTLinkedListIteratorClass::destructIterator proc~destructiterator->proc~releasememberlist proc~setlinkedlist FTLinkedListIteratorClass::FTLinkedListIterator%setLinkedList proc~setlinkedlist->proc~releasememberlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releasememberlist.html"},{"title":"setToStart – FTObjectLibrary","text":"public  subroutine setToStart(self) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Contents","tags":"","loc":"proc/settostart.html"},{"title":"moveToNext – FTObjectLibrary","text":"public  subroutine moveToNext(self) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Contents","tags":"","loc":"proc/movetonext.html"},{"title":"setLinkedList – FTObjectLibrary","text":"public  subroutine setLinkedList(self, list) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self class( FTLinkedList ), POINTER :: list Calls proc~~setlinkedlist~~CallsGraph proc~setlinkedlist FTLinkedListIteratorClass::FTLinkedListIterator%setLinkedList proc~releasememberlist FTLinkedListIteratorClass::releaseMemberList proc~setlinkedlist->proc~releasememberlist proc~releaseftobject FTObjectClass::releaseFTObject proc~releasememberlist->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/setlinkedlist.html"},{"title":"removeCurrentRecord – FTObjectLibrary","text":"public  subroutine removeCurrentRecord(self) Type Bound FTLinkedListIterator Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Contents","tags":"","loc":"proc/removecurrentrecord.html"},{"title":"infoDictionary – FTObjectLibrary","text":"public  function infoDictionary(self) Returns the exception's infoDictionary. Does\nnot transfer ownership/reference count is \nunchanged. Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value class( FTDictionary ), POINTER Contents","tags":"","loc":"proc/infodictionary.html"},{"title":"exceptionName – FTObjectLibrary","text":"public  function exceptionName(self) Returns the string representing the name set\nfor the exception. Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value character(len=ERROR_MSG_STRING_LENGTH) Contents","tags":"","loc":"proc/exceptionname.html"},{"title":"severity – FTObjectLibrary","text":"public  function severity(self) Returns the severity level of the exception. Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value integer Contents","tags":"","loc":"proc/severity.html"},{"title":"exceptionFromObject – FTObjectLibrary","text":"public  function exceptionFromObject(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTException ), POINTER Contents","tags":"","loc":"proc/exceptionfromobject.html"},{"title":"exceptionClassName – FTObjectLibrary","text":"public  function exceptionClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTException \" ) Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/exceptionclassname.html"},{"title":"initWarningException – FTObjectLibrary","text":"public  subroutine initWarningException(self, msg) A convenience initializer for a warning error \nthat includes the key \"message\" in the\ninfoDictionary. Use this initializer as an \nexample of how to write one's own exception. Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self character(len=*) :: msg Calls proc~~initwarningexception~~CallsGraph proc~initwarningexception FTExceptionClass::FTException%initWarningException proc~releasememberdictionary FTExceptionClass::releaseMemberDictionary proc~initwarningexception->proc~releasememberdictionary proc~releaseftobject FTObjectClass::releaseFTObject proc~releasememberdictionary->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/initwarningexception.html"},{"title":"initFatalException – FTObjectLibrary","text":"public  subroutine initFatalException(self, msg) A convenience initializer for a fatal error \nthat includes the key \"message\" in the\ninfoDictionary.Use this initializer as an \nexample of how to write one's own exception. Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self character(len=*) :: msg Calls proc~~initfatalexception~~CallsGraph proc~initfatalexception FTExceptionClass::FTException%initFatalException proc~releasememberdictionary FTExceptionClass::releaseMemberDictionary proc~initfatalexception->proc~releasememberdictionary proc~releaseftobject FTObjectClass::releaseFTObject proc~releasememberdictionary->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/initfatalexception.html"},{"title":"initFTException – FTObjectLibrary","text":"public  subroutine initFTException(self, severity, exceptionName, infoDictionary) The main initializer for the class Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self integer :: severity character(len=*) :: exceptionName class( FTDictionary ), optional, POINTER :: infoDictionary Contents","tags":"","loc":"proc/initftexception.html"},{"title":"initAssertionFailureException – FTObjectLibrary","text":"public  subroutine initAssertionFailureException(self, msg, expectedValueObject, ObservedValueObject, level) A convenience initializer for an assertion error \nthat includes the keys: -\"message\"\n-\"expectedValue\"\n-\"observedValue\" in the infoDictionary Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self character(len=*) :: msg class( FTValue ), POINTER :: expectedValueObject class( FTValue ), POINTER :: ObservedValueObject integer :: level Calls proc~~initassertionfailureexception~~CallsGraph proc~initassertionfailureexception FTExceptionClass::FTException%initAssertionFailureException proc~releasememberdictionary FTExceptionClass::releaseMemberDictionary proc~initassertionfailureexception->proc~releasememberdictionary proc~releaseftobject FTObjectClass::releaseFTObject proc~releasememberdictionary->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/initassertionfailureexception.html"},{"title":"releaseFTException – FTObjectLibrary","text":"public  subroutine releaseFTException(self) Arguments Type Intent Optional Attributes Name type( FTException ), POINTER :: self Calls proc~~releaseftexception~~CallsGraph proc~releaseftexception FTExceptionClass::releaseFTException interface~release FTObjectClass::release proc~releaseftexception->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftexception.html"},{"title":"destructException – FTObjectLibrary","text":"public  subroutine destructException(self) The destructor for the class. Do not call this direectly. Call\nthe release() procedure instead Arguments Type Intent Optional Attributes Name type( FTException ) :: self Calls proc~~destructexception~~CallsGraph proc~destructexception FTExceptionClass::destructException proc~releasememberdictionary FTExceptionClass::releaseMemberDictionary proc~destructexception->proc~releasememberdictionary proc~releaseftobject FTObjectClass::releaseFTObject proc~releasememberdictionary->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/destructexception.html"},{"title":"setInfoDictionary – FTObjectLibrary","text":"public  subroutine setInfoDictionary(self, dict) Sets and retains the exception infoDictionary Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self class( FTDictionary ), POINTER :: dict Calls proc~~setinfodictionary~~CallsGraph proc~setinfodictionary FTExceptionClass::FTException%setInfoDictionary proc~releasememberdictionary FTExceptionClass::releaseMemberDictionary proc~setinfodictionary->proc~releasememberdictionary proc~releaseftobject FTObjectClass::releaseFTObject proc~releasememberdictionary->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/setinfodictionary.html"},{"title":"releaseMemberDictionary – FTObjectLibrary","text":"public  subroutine releaseMemberDictionary(self) Arguments Type Intent Optional Attributes Name class( FTException ) :: self Calls proc~~releasememberdictionary~~CallsGraph proc~releasememberdictionary FTExceptionClass::releaseMemberDictionary proc~releaseftobject FTObjectClass::releaseFTObject proc~releasememberdictionary->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~releasememberdictionary~~CalledByGraph proc~releasememberdictionary FTExceptionClass::releaseMemberDictionary proc~destructexception FTExceptionClass::destructException proc~destructexception->proc~releasememberdictionary proc~initassertionfailureexception FTExceptionClass::FTException%initAssertionFailureException proc~initassertionfailureexception->proc~releasememberdictionary proc~initfatalexception FTExceptionClass::FTException%initFatalException proc~initfatalexception->proc~releasememberdictionary proc~initwarningexception FTExceptionClass::FTException%initWarningException proc~initwarningexception->proc~releasememberdictionary proc~setinfodictionary FTExceptionClass::FTException%setInfoDictionary proc~setinfodictionary->proc~releasememberdictionary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releasememberdictionary.html"},{"title":"printFTExceptionDescription – FTObjectLibrary","text":"public  subroutine printFTExceptionDescription(self, iUnit) A basic printing of the exception and the info\nheld in the infoDicitonary. Type Bound FTException Arguments Type Intent Optional Attributes Name class( FTException ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printftexceptiondescription.html"},{"title":"castToException – FTObjectLibrary","text":"public  subroutine castToException(obj, cast) Cast the base class FTObject to the FTException class Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTException ), POINTER :: cast Called by proc~~casttoexception~~CalledByGraph proc~casttoexception FTExceptionClass::castToException interface~cast~4 FTExceptionClass::cast interface~cast~4->proc~casttoexception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/casttoexception.html"},{"title":"cast – FTObjectLibrary","text":"public interface cast Calls interface~~cast~4~~CallsGraph interface~cast~4 FTExceptionClass::cast proc~casttoexception FTExceptionClass::castToException interface~cast~4->proc~casttoexception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures castToException Module Procedures public  subroutine castToException (obj, cast) Cast the base class FTObject to the FTException class Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTException ), POINTER :: cast","tags":"","loc":"interface/cast~4.html"},{"title":"errorCount – FTObjectLibrary","text":"public  function errorCount() Returns the number of exceptions that have \nbeen thrown. Arguments None Return Value integer Calls proc~~errorcount~~CallsGraph proc~errorcount SharedExceptionManagerModule::errorCount proc~initializeftexceptions SharedExceptionManagerModule::initializeFTExceptions proc~errorcount->proc~initializeftexceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/errorcount.html"},{"title":"maximumErrorSeverity – FTObjectLibrary","text":"public  function maximumErrorSeverity() Returns the maxSeverity of exceptions that have \nbeen thrown. Arguments None Return Value integer Calls proc~~maximumerrorseverity~~CallsGraph proc~maximumerrorseverity SharedExceptionManagerModule::maximumErrorSeverity proc~initializeftexceptions SharedExceptionManagerModule::initializeFTExceptions proc~maximumerrorseverity->proc~initializeftexceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/maximumerrorseverity.html"},{"title":"errorObject – FTObjectLibrary","text":"public  function errorObject() Returns a pointer to the current exception. Arguments None Return Value class( FTException ), POINTER Calls proc~~errorobject~~CallsGraph proc~errorobject SharedExceptionManagerModule::errorObject proc~initializeftexceptions SharedExceptionManagerModule::initializeFTExceptions proc~errorobject->proc~initializeftexceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/errorobject.html"},{"title":"popLastException – FTObjectLibrary","text":"public  function popLastException() Get the last exception posted. This is popped from the stack.\nThe caller is responsible for releasing the object after popping Arguments None Return Value class( FTException ), POINTER Calls proc~~poplastexception~~CallsGraph proc~poplastexception SharedExceptionManagerModule::popLastException interface~cast~5 FTMutableObjectArrayClass::cast proc~poplastexception->interface~cast~5 proc~initializeftexceptions SharedExceptionManagerModule::initializeFTExceptions proc~poplastexception->proc~initializeftexceptions proc~casttomutableobjectarray FTMutableObjectArrayClass::castToMutableObjectArray interface~cast~5->proc~casttomutableobjectarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/poplastexception.html"},{"title":"peekLastException – FTObjectLibrary","text":"public  function peekLastException() Get the last exception posted. This is NOT popped from the stack.\nThe caller does not own the object. Arguments None Return Value class( FTException ), POINTER Calls proc~~peeklastexception~~CallsGraph proc~peeklastexception SharedExceptionManagerModule::peekLastException interface~cast~5 FTMutableObjectArrayClass::cast proc~peeklastexception->interface~cast~5 proc~initializeftexceptions SharedExceptionManagerModule::initializeFTExceptions proc~peeklastexception->proc~initializeftexceptions proc~casttomutableobjectarray FTMutableObjectArrayClass::castToMutableObjectArray interface~cast~5->proc~casttomutableobjectarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/peeklastexception.html"},{"title":"initializeFTExceptions – FTObjectLibrary","text":"public  subroutine initializeFTExceptions() Called at start of execution. Will be called automatically if an \nexception is thrown. Arguments None Called by proc~~initializeftexceptions~~CalledByGraph proc~initializeftexceptions SharedExceptionManagerModule::initializeFTExceptions proc~errorcount SharedExceptionManagerModule::errorCount proc~errorcount->proc~initializeftexceptions proc~errorobject SharedExceptionManagerModule::errorObject proc~errorobject->proc~initializeftexceptions proc~maximumerrorseverity SharedExceptionManagerModule::maximumErrorSeverity proc~maximumerrorseverity->proc~initializeftexceptions proc~peeklastexception SharedExceptionManagerModule::peekLastException proc~peeklastexception->proc~initializeftexceptions proc~poplastexception SharedExceptionManagerModule::popLastException proc~poplastexception->proc~initializeftexceptions proc~throw SharedExceptionManagerModule::throw proc~throw->proc~initializeftexceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initializeftexceptions.html"},{"title":"destructFTExceptions – FTObjectLibrary","text":"public  subroutine destructFTExceptions() Called at the end of execution. This procedure will announce if there\nare uncaught exceptions raised and print them. Arguments None Calls proc~~destructftexceptions~~CallsGraph proc~destructftexceptions SharedExceptionManagerModule::destructFTExceptions interface~catch SharedExceptionManagerModule::catch proc~destructftexceptions->interface~catch proc~releasecurrenterror SharedExceptionManagerModule::releaseCurrentError proc~destructftexceptions->proc~releasecurrenterror proc~releaseftobject FTObjectClass::releaseFTObject proc~destructftexceptions->proc~releaseftobject proc~releasecurrenterror->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/destructftexceptions.html"},{"title":"throw – FTObjectLibrary","text":"public  subroutine throw(exceptionToThrow) Throws the exception: exceptionToThrow Arguments Type Intent Optional Attributes Name type( FTException ), POINTER :: exceptionToThrow Calls proc~~throw~~CallsGraph proc~throw SharedExceptionManagerModule::throw proc~initializeftexceptions SharedExceptionManagerModule::initializeFTExceptions proc~throw->proc~initializeftexceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/throw.html"},{"title":"setCurrentError – FTObjectLibrary","text":"public  subroutine setCurrentError(e) Arguments Type Intent Optional Attributes Name class( FTException ), POINTER :: e Calls proc~~setcurrenterror~~CallsGraph proc~setcurrenterror SharedExceptionManagerModule::setCurrentError proc~releasecurrenterror SharedExceptionManagerModule::releaseCurrentError proc~setcurrenterror->proc~releasecurrenterror proc~releaseftobject FTObjectClass::releaseFTObject proc~releasecurrenterror->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/setcurrenterror.html"},{"title":"printAllExceptions – FTObjectLibrary","text":"public  subroutine printAllExceptions() Arguments None Calls proc~~printallexceptions~~CallsGraph proc~printallexceptions SharedExceptionManagerModule::printAllExceptions interface~cast~5 FTMutableObjectArrayClass::cast proc~printallexceptions->interface~cast~5 proc~casttomutableobjectarray FTMutableObjectArrayClass::castToMutableObjectArray interface~cast~5->proc~casttomutableobjectarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/printallexceptions.html"},{"title":"releaseCurrentError – FTObjectLibrary","text":"public  subroutine releaseCurrentError() Arguments None Calls proc~~releasecurrenterror~~CallsGraph proc~releasecurrenterror SharedExceptionManagerModule::releaseCurrentError proc~releaseftobject FTObjectClass::releaseFTObject proc~releasecurrenterror->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~releasecurrenterror~~CalledByGraph proc~releasecurrenterror SharedExceptionManagerModule::releaseCurrentError proc~destructftexceptions SharedExceptionManagerModule::destructFTExceptions proc~destructftexceptions->proc~releasecurrenterror proc~setcurrenterror SharedExceptionManagerModule::setCurrentError proc~setcurrenterror->proc~releasecurrenterror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/releasecurrenterror.html"},{"title":"catch – FTObjectLibrary","text":"public interface catch Called by interface~~catch~~CalledByGraph interface~catch SharedExceptionManagerModule::catch proc~destructftexceptions SharedExceptionManagerModule::destructFTExceptions proc~destructftexceptions->interface~catch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures catchAll catchErrorWithName Module Procedures private  function catchAll() Returns .TRUE. if there are any exceptions. Arguments None Return Value logical private  function catchErrorWithName(exceptionName) Returns .TRUE. if there is an exception with\nthe requested name. If so, it pops the \nexception and saves the pointer to it so that\nit can be accessed with the currentError()\nfunction. Arguments Type Intent Optional Attributes Name character(len=*) :: exceptionName Return Value logical","tags":"","loc":"interface/catch.html"},{"title":"className – FTObjectLibrary","text":"public  function className(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTObject \" ) Type Bound FTObject Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/classname.html"},{"title":"isUnreferenced – FTObjectLibrary","text":"public  function isUnreferenced(self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() ### Usage: ### IF ( v % isUnreferenced () ) THEN DEALLOCATE ( v ) v => NULL () END IF Type Bound FTObject Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical Contents","tags":"","loc":"proc/isunreferenced.html"},{"title":"refCount – FTObjectLibrary","text":"public  function refCount(self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Type Bound FTObject Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer Contents","tags":"","loc":"proc/refcount.html"},{"title":"FTObjectDescription – FTObjectLibrary","text":"public  function FTObjectDescription(self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Type Bound FTObject Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/ftobjectdescription.html"},{"title":"initFTObject – FTObjectLibrary","text":"public  subroutine initFTObject(self) Generic Name: init() Initializes the object. The base class initialization does \nnothing but set the reference count to one. Type Bound FTObject Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Contents","tags":"","loc":"proc/initftobject.html"},{"title":"destructFTObject – FTObjectLibrary","text":"public  subroutine destructFTObject(self) Generic Name: destruct() The destructor for the class. The base class destructor does nothing. Arguments Type Intent Optional Attributes Name type( FTObject ) :: self Contents","tags":"","loc":"proc/destructftobject.html"},{"title":"retainFTObject – FTObjectLibrary","text":"public  subroutine retainFTObject(self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Type Bound FTObject Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Contents","tags":"","loc":"proc/retainftobject.html"},{"title":"releaseFTObject – FTObjectLibrary","text":"public recursive subroutine releaseFTObject(self) releaseFTObject decreases the reference count by one and implies \nrelinquishing ownership by the caller. Call this if control\nover the existence of an object pointer is no longer desired by the caller.\nWhen the reference count goes to zero, the destructor of the object\nis called automatically and the object is deallocated. Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: self Called by proc~~releaseftobject~~CalledByGraph proc~releaseftobject FTObjectClass::releaseFTObject interface~release FTObjectClass::release interface~release->proc~releaseftobject proc~addobjecttomultiindextableforkeys FTMultiIndexTableClass::FTMultiIndexTable%addObjectToMultiIndexTableForKeys proc~addobjecttomultiindextableforkeys->proc~releaseftobject proc~addobjecttosparsematrixforkeys FTSparseMatrixClass::FTSparseMatrix%addObjectToSparseMatrixForKeys proc~addobjecttosparsematrixforkeys->proc~releaseftobject proc~destructftexceptions SharedExceptionManagerModule::destructFTExceptions proc~destructftexceptions->proc~releaseftobject proc~releasecurrenterror SharedExceptionManagerModule::releaseCurrentError proc~destructftexceptions->proc~releasecurrenterror proc~destructftkeyobjectpair FTKeyObjectPairClass::destructFTKeyObjectPair proc~destructftkeyobjectpair->proc~releaseftobject proc~destructftlinkedlistrecord FTLinkedListRecordClass::destructFTLinkedListRecord proc~destructftlinkedlistrecord->proc~releaseftobject proc~destructmatrixdata FTSparseMatrixData::destructMatrixData proc~destructmatrixdata->proc~releaseftobject proc~destructmultiindexmatrixdata FTMultiIndexTableData::destructMultiIndexMatrixData proc~destructmultiindexmatrixdata->proc~releaseftobject proc~destructobjectarray FTMutableObjectArrayClass::destructObjectArray proc~destructobjectarray->proc~releaseftobject proc~releasecurrenterror->proc~releaseftobject proc~releaseftvaluedictionary FTValueDictionaryClass::releaseFTValueDictionary proc~releaseftvaluedictionary->proc~releaseftobject proc~releasememberdictionary FTExceptionClass::releaseMemberDictionary proc~releasememberdictionary->proc~releaseftobject proc~releasememberlist FTLinkedListIteratorClass::releaseMemberList proc~releasememberlist->proc~releaseftobject proc~releasesmmemberlist FTSparseMatrixClass::releaseSMMemberList proc~releasesmmemberlist->proc~releaseftobject proc~removeobjectatindex FTMutableObjectArrayClass::FTMutableObjectArray%removeObjectAtIndex proc~removeobjectatindex->proc~releaseftobject proc~replaceobjectatindexwithobject FTMutableObjectArrayClass::FTMutableObjectArray%replaceObjectAtIndexWithObject proc~replaceobjectatindexwithobject->proc~releaseftobject proc~adddoubleprecisionvalueforkey FTValueDictionaryClass::FTValueDictionary%addDoublePrecisionValueForKey proc~adddoubleprecisionvalueforkey->interface~release proc~addintegervalueforkey FTValueDictionaryClass::FTValueDictionary%addIntegerValueForKey proc~addintegervalueforkey->interface~release proc~addlogicalvalueforkey FTValueDictionaryClass::FTValueDictionary%addLogicalValueForKey proc~addlogicalvalueforkey->interface~release proc~addobjectforkey FTDictionaryClass::FTDictionary%addObjectForKey proc~addobjectforkey->interface~release proc~addquadvalueforkey FTValueDictionaryClass::FTValueDictionary%addQuadValueForKey proc~addquadvalueforkey->interface~release proc~addrealvalueforkey FTValueDictionaryClass::FTValueDictionary%addRealValueForKey proc~addrealvalueforkey->interface~release proc~addstring FTStringSetClass::FTStringSet%AddString proc~addstring->interface~release proc~addstringvalueforkey FTValueDictionaryClass::FTValueDictionary%addStringValueForKey proc~addstringvalueforkey->interface~release proc~destructexception FTExceptionClass::destructException proc~destructexception->proc~releasememberdictionary proc~destructiterator FTLinkedListIteratorClass::destructIterator proc~destructiterator->proc~releasememberlist proc~destructsparsematrix FTSparseMatrixClass::destructSparseMatrix proc~destructsparsematrix->proc~releasesmmemberlist proc~initassertionfailureexception FTExceptionClass::FTException%initAssertionFailureException proc~initassertionfailureexception->proc~releasememberdictionary proc~initfatalexception FTExceptionClass::FTException%initFatalException proc~initfatalexception->proc~releasememberdictionary proc~initwarningexception FTExceptionClass::FTException%initWarningException proc~initwarningexception->proc~releasememberdictionary proc~pop FTStackClass::FTStack%pop proc~pop->interface~release proc~releaseftdata FTDataClass::releaseFTData proc~releaseftdata->interface~release proc~releaseftdictionary FTDictionaryClass::releaseFTDictionary proc~releaseftdictionary->interface~release proc~releaseftexception FTExceptionClass::releaseFTException proc~releaseftexception->interface~release proc~releaseftkeyobjectpair FTKeyObjectPairClass::releaseFTKeyObjectPair proc~releaseftkeyobjectpair->interface~release proc~releaseftlinkedlist FTLinkedListClass::releaseFTLinkedList proc~releaseftlinkedlist->interface~release proc~releaseftlinkedlistiterator FTLinkedListIteratorClass::releaseFTLinkedListIterator proc~releaseftlinkedlistiterator->interface~release proc~releaseftlinkedlistrecord FTLinkedListRecordClass::releaseFTLinkedListRecord proc~releaseftlinkedlistrecord->interface~release proc~releaseftmatrixdata FTSparseMatrixData::releaseFTMatrixData proc~releaseftmatrixdata->interface~release proc~releaseftmultiindexmatrixdata FTMultiIndexTableData::releaseFTMultiIndexMatrixData proc~releaseftmultiindexmatrixdata->interface~release proc~releaseftmultiindextable FTMultiIndexTableClass::releaseFTMultiIndexTable proc~releaseftmultiindextable->interface~release proc~releaseftmutableobjectarray FTMutableObjectArrayClass::releaseFTMutableObjectArray proc~releaseftmutableobjectarray->interface~release proc~releaseftsparsematrix FTSparseMatrixClass::releaseFTSparseMatrix proc~releaseftsparsematrix->interface~release proc~releaseftstack FTStackClass::releaseFTStack proc~releaseftstack->interface~release proc~releaseftstringset FTStringSetClass::releaseFTStringSet proc~releaseftstringset->interface~release proc~releaseftvalue FTValueClass::releaseFTValue proc~releaseftvalue->interface~release proc~removealllinkedlistobjects FTLinkedListClass::FTLinkedList%removeAllLinkedListObjects proc~removealllinkedlistobjects->interface~release proc~removelinkedlistrecord FTLinkedListClass::FTLinkedList%removeLinkedListRecord proc~removelinkedlistrecord->interface~release proc~removeobject1 FTLinkedListClass::removeObject1 proc~removeobject1->interface~release proc~setcurrenterror SharedExceptionManagerModule::setCurrentError proc~setcurrenterror->proc~releasecurrenterror proc~setinfodictionary FTExceptionClass::FTException%setInfoDictionary proc~setinfodictionary->proc~releasememberdictionary proc~setlinkedlist FTLinkedListIteratorClass::FTLinkedListIterator%setLinkedList proc~setlinkedlist->proc~releasememberlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftobject.html"},{"title":"printFTObjectDescription – FTObjectLibrary","text":"public  subroutine printFTObjectDescription(self, iUnit) Generic Name: printDescription() Prints a string to unit iUnit that represents the contents of the object. FTObject's\n description simply prints its name. Override this in subclasses to print something\n useful. Type Bound FTObject Arguments Type Intent Optional Attributes Name class( FTObject ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printftobjectdescription.html"},{"title":"release – FTObjectLibrary","text":"public interface release Calls interface~~release~~CallsGraph interface~release FTObjectClass::release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~release~~CalledByGraph interface~release FTObjectClass::release proc~adddoubleprecisionvalueforkey FTValueDictionaryClass::FTValueDictionary%addDoublePrecisionValueForKey proc~adddoubleprecisionvalueforkey->interface~release proc~addintegervalueforkey FTValueDictionaryClass::FTValueDictionary%addIntegerValueForKey proc~addintegervalueforkey->interface~release proc~addlogicalvalueforkey FTValueDictionaryClass::FTValueDictionary%addLogicalValueForKey proc~addlogicalvalueforkey->interface~release proc~addobjectforkey FTDictionaryClass::FTDictionary%addObjectForKey proc~addobjectforkey->interface~release proc~addquadvalueforkey FTValueDictionaryClass::FTValueDictionary%addQuadValueForKey proc~addquadvalueforkey->interface~release proc~addrealvalueforkey FTValueDictionaryClass::FTValueDictionary%addRealValueForKey proc~addrealvalueforkey->interface~release proc~addstring FTStringSetClass::FTStringSet%AddString proc~addstring->interface~release proc~addstringvalueforkey FTValueDictionaryClass::FTValueDictionary%addStringValueForKey proc~addstringvalueforkey->interface~release proc~pop FTStackClass::FTStack%pop proc~pop->interface~release proc~releaseftdata FTDataClass::releaseFTData proc~releaseftdata->interface~release proc~releaseftdictionary FTDictionaryClass::releaseFTDictionary proc~releaseftdictionary->interface~release proc~releaseftexception FTExceptionClass::releaseFTException proc~releaseftexception->interface~release proc~releaseftkeyobjectpair FTKeyObjectPairClass::releaseFTKeyObjectPair proc~releaseftkeyobjectpair->interface~release proc~releaseftlinkedlist FTLinkedListClass::releaseFTLinkedList proc~releaseftlinkedlist->interface~release proc~releaseftlinkedlistiterator FTLinkedListIteratorClass::releaseFTLinkedListIterator proc~releaseftlinkedlistiterator->interface~release proc~releaseftlinkedlistrecord FTLinkedListRecordClass::releaseFTLinkedListRecord proc~releaseftlinkedlistrecord->interface~release proc~releaseftmatrixdata FTSparseMatrixData::releaseFTMatrixData proc~releaseftmatrixdata->interface~release proc~releaseftmultiindexmatrixdata FTMultiIndexTableData::releaseFTMultiIndexMatrixData proc~releaseftmultiindexmatrixdata->interface~release proc~releaseftmultiindextable FTMultiIndexTableClass::releaseFTMultiIndexTable proc~releaseftmultiindextable->interface~release proc~releaseftmutableobjectarray FTMutableObjectArrayClass::releaseFTMutableObjectArray proc~releaseftmutableobjectarray->interface~release proc~releaseftsparsematrix FTSparseMatrixClass::releaseFTSparseMatrix proc~releaseftsparsematrix->interface~release proc~releaseftstack FTStackClass::releaseFTStack proc~releaseftstack->interface~release proc~releaseftstringset FTStringSetClass::releaseFTStringSet proc~releaseftstringset->interface~release proc~releaseftvalue FTValueClass::releaseFTValue proc~releaseftvalue->interface~release proc~removealllinkedlistobjects FTLinkedListClass::FTLinkedList%removeAllLinkedListObjects proc~removealllinkedlistobjects->interface~release proc~removelinkedlistrecord FTLinkedListClass::FTLinkedList%removeLinkedListRecord proc~removelinkedlistrecord->interface~release proc~removeobject1 FTLinkedListClass::removeObject1 proc~removeobject1->interface~release Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures releaseFTObject Module Procedures public recursive subroutine releaseFTObject (self) releaseFTObject decreases the reference count by one and implies \nrelinquishing ownership by the caller. Call this if control\nover the existence of an object pointer is no longer desired by the caller.\nWhen the reference count goes to zero, the destructor of the object\nis called automatically and the object is deallocated. Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: self","tags":"","loc":"interface/release.html"},{"title":"realValueForKey – FTObjectLibrary","text":"public  function realValueForKey(self, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value real Calls proc~~realvalueforkey~~CallsGraph proc~realvalueforkey FTValueDictionaryClass::FTValueDictionary%realValueForKey proc~valuefromobject FTValueClass::valueFromObject proc~realvalueforkey->proc~valuefromobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/realvalueforkey.html"},{"title":"integerValueForKey – FTObjectLibrary","text":"public  function integerValueForKey(self, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value integer Calls proc~~integervalueforkey~~CallsGraph proc~integervalueforkey FTValueDictionaryClass::FTValueDictionary%integerValueForKey proc~valuefromobject FTValueClass::valueFromObject proc~integervalueforkey->proc~valuefromobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/integervalueforkey.html"},{"title":"doublePrecisionValueForKey – FTObjectLibrary","text":"public  function doublePrecisionValueForKey(self, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value doubleprecision Calls proc~~doubleprecisionvalueforkey~~CallsGraph proc~doubleprecisionvalueforkey FTValueDictionaryClass::FTValueDictionary%doublePrecisionValueForKey proc~valuefromobject FTValueClass::valueFromObject proc~doubleprecisionvalueforkey->proc~valuefromobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/doubleprecisionvalueforkey.html"},{"title":"quadValueForKey – FTObjectLibrary","text":"public  function quadValueForKey(self, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value real(kind=selected_real_kind(quad_digits)) Calls proc~~quadvalueforkey~~CallsGraph proc~quadvalueforkey FTValueDictionaryClass::FTValueDictionary%quadValueForKey proc~valuefromobject FTValueClass::valueFromObject proc~quadvalueforkey->proc~valuefromobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/quadvalueforkey.html"},{"title":"logicalValueForKey – FTObjectLibrary","text":"public  function logicalValueForKey(self, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value logical Calls proc~~logicalvalueforkey~~CallsGraph proc~logicalvalueforkey FTValueDictionaryClass::FTValueDictionary%logicalValueForKey proc~valuefromobject FTValueClass::valueFromObject proc~logicalvalueforkey->proc~valuefromobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/logicalvalueforkey.html"},{"title":"stringValueForKey – FTObjectLibrary","text":"public  function stringValueForKey(self, key, requestedLength) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key integer :: requestedLength Return Value character(len=requestedLength) Calls proc~~stringvalueforkey~~CallsGraph proc~stringvalueforkey FTValueDictionaryClass::FTValueDictionary%stringValueForKey proc~valuefromobject FTValueClass::valueFromObject proc~stringvalueforkey->proc~valuefromobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/stringvalueforkey.html"},{"title":"valueDictionaryFromDictionary – FTObjectLibrary","text":"public  function valueDictionaryFromDictionary(dict) result(valueDict) Arguments Type Intent Optional Attributes Name class( FTDictionary ), POINTER :: dict Return Value class( FTValueDictionary ), POINTER Contents","tags":"","loc":"proc/valuedictionaryfromdictionary.html"},{"title":"valueDictionaryFromObject – FTObjectLibrary","text":"public  function valueDictionaryFromObject(obj) result(valueDict) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTValueDictionary ), POINTER Contents","tags":"","loc":"proc/valuedictionaryfromobject.html"},{"title":"valueDictionaryClassName – FTObjectLibrary","text":"public  function valueDictionaryClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTValueDictionary \" ) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/valuedictionaryclassname.html"},{"title":"releaseFTValueDictionary – FTObjectLibrary","text":"public  subroutine releaseFTValueDictionary(self) Public, generic name: release(self) Call release(self) on an object to release control\nof an object. If its reference count is zero, then \nit is deallocated. Arguments Type Intent Optional Attributes Name type( FTValueDictionary ), POINTER :: self Calls proc~~releaseftvaluedictionary~~CallsGraph proc~releaseftvaluedictionary FTValueDictionaryClass::releaseFTValueDictionary proc~releaseftobject FTObjectClass::releaseFTObject proc~releaseftvaluedictionary->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftvaluedictionary.html"},{"title":"addIntegerValueForKey – FTObjectLibrary","text":"public  subroutine addIntegerValueForKey(self, i, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self integer :: i character(len=*) :: key Calls proc~~addintegervalueforkey~~CallsGraph proc~addintegervalueforkey FTValueDictionaryClass::FTValueDictionary%addIntegerValueForKey interface~release FTObjectClass::release proc~addintegervalueforkey->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/addintegervalueforkey.html"},{"title":"addRealValueForKey – FTObjectLibrary","text":"public  subroutine addRealValueForKey(self, r, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self real :: r character(len=*) :: key Calls proc~~addrealvalueforkey~~CallsGraph proc~addrealvalueforkey FTValueDictionaryClass::FTValueDictionary%addRealValueForKey interface~release FTObjectClass::release proc~addrealvalueforkey->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/addrealvalueforkey.html"},{"title":"addDoublePrecisionValueForKey – FTObjectLibrary","text":"public  subroutine addDoublePrecisionValueForKey(self, r, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self double precision :: r character(len=*) :: key Calls proc~~adddoubleprecisionvalueforkey~~CallsGraph proc~adddoubleprecisionvalueforkey FTValueDictionaryClass::FTValueDictionary%addDoublePrecisionValueForKey interface~release FTObjectClass::release proc~adddoubleprecisionvalueforkey->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/adddoubleprecisionvalueforkey.html"},{"title":"addQuadValueForKey – FTObjectLibrary","text":"public  subroutine addQuadValueForKey(self, r, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)) :: r character(len=*) :: key Calls proc~~addquadvalueforkey~~CallsGraph proc~addquadvalueforkey FTValueDictionaryClass::FTValueDictionary%addQuadValueForKey interface~release FTObjectClass::release proc~addquadvalueforkey->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/addquadvalueforkey.html"},{"title":"addStringValueForKey – FTObjectLibrary","text":"public  subroutine addStringValueForKey(self, s, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: s character(len=*) :: key Calls proc~~addstringvalueforkey~~CallsGraph proc~addstringvalueforkey FTValueDictionaryClass::FTValueDictionary%addStringValueForKey interface~release FTObjectClass::release proc~addstringvalueforkey->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/addstringvalueforkey.html"},{"title":"addLogicalValueForKey – FTObjectLibrary","text":"public  subroutine addLogicalValueForKey(self, l, key) Type Bound FTValueDictionary Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self logical :: l character(len=*) :: key Calls proc~~addlogicalvalueforkey~~CallsGraph proc~addlogicalvalueforkey FTValueDictionaryClass::FTValueDictionary%addLogicalValueForKey interface~release FTObjectClass::release proc~addlogicalvalueforkey->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/addlogicalvalueforkey.html"},{"title":"castDictionaryToValueDictionary – FTObjectLibrary","text":"public  subroutine castDictionaryToValueDictionary(dict, valueDict) Arguments Type Intent Optional Attributes Name class( FTDictionary ), POINTER :: dict class( FTValueDictionary ), POINTER :: valueDict Contents","tags":"","loc":"proc/castdictionarytovaluedictionary.html"},{"title":"castObjectToValueDictionary – FTObjectLibrary","text":"public  subroutine castObjectToValueDictionary(obj, valueDict) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTValueDictionary ), POINTER :: valueDict Contents","tags":"","loc":"proc/castobjecttovaluedictionary.html"},{"title":"FTKeyObjectPairDescription – FTObjectLibrary","text":"public  function FTKeyObjectPairDescription(self) Type Bound FTKeyObjectPair Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self Return Value character(len=description_character_length) Contents","tags":"","loc":"proc/ftkeyobjectpairdescription.html"},{"title":"key – FTObjectLibrary","text":"public  function key(self) Type Bound FTKeyObjectPair Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self Return Value character(len=ftdict_kwd_string_length) Contents","tags":"","loc":"proc/key.html"},{"title":"object – FTObjectLibrary","text":"public  function object(self) Type Bound FTKeyObjectPair Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self Return Value class( FTObject ), POINTER Contents","tags":"","loc":"proc/object.html"},{"title":"initWithObjectAndKey – FTObjectLibrary","text":"public  subroutine initWithObjectAndKey(self, v, key) Type Bound FTKeyObjectPair Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self class( FTObject ), POINTER :: v character(len=*) :: key Contents","tags":"","loc":"proc/initwithobjectandkey~2.html"},{"title":"releaseFTKeyObjectPair – FTObjectLibrary","text":"public  subroutine releaseFTKeyObjectPair(self) Arguments Type Intent Optional Attributes Name type( FTKeyObjectPair ), POINTER :: self Calls proc~~releaseftkeyobjectpair~~CallsGraph proc~releaseftkeyobjectpair FTKeyObjectPairClass::releaseFTKeyObjectPair interface~release FTObjectClass::release proc~releaseftkeyobjectpair->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftkeyobjectpair.html"},{"title":"destructFTKeyObjectPair – FTObjectLibrary","text":"public  subroutine destructFTKeyObjectPair(self) Arguments Type Intent Optional Attributes Name type( FTKeyObjectPair ) :: self Calls proc~~destructftkeyobjectpair~~CallsGraph proc~destructftkeyobjectpair FTKeyObjectPairClass::destructFTKeyObjectPair proc~releaseftobject FTObjectClass::releaseFTObject proc~destructftkeyobjectpair->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/destructftkeyobjectpair.html"},{"title":"printFTKeyObjectPairDescription – FTObjectLibrary","text":"public recursive subroutine printFTKeyObjectPairDescription(self, iUnit) Type Bound FTKeyObjectPair Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printftkeyobjectpairdescription.html"},{"title":"COUNT – FTObjectLibrary","text":"public  function COUNT(self) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value integer Contents","tags":"","loc":"proc/count.html"},{"title":"objectForKey – FTObjectLibrary","text":"public  function objectForKey(self, key) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self character(len=*) :: key Return Value class( FTObject ), POINTER Calls proc~~objectforkey~~CallsGraph proc~objectforkey FTDictionaryClass::FTDictionary%objectForKey proc~b3hs_hash_key_jenkins HashModule::b3hs_hash_key_jenkins proc~objectforkey->proc~b3hs_hash_key_jenkins Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/objectforkey.html"},{"title":"containsKey – FTObjectLibrary","text":"public  function containsKey(self, key) result(r) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self character(len=*) :: key Return Value logical Contents","tags":"","loc":"proc/containskey.html"},{"title":"FTDictionaryDescription – FTObjectLibrary","text":"public  function FTDictionaryDescription(self) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=description_character_length) Contents","tags":"","loc":"proc/ftdictionarydescription.html"},{"title":"AllObjects – FTObjectLibrary","text":"public  function AllObjects(self) result(objectArray) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value class( FTMutableObjectArray ), POINTER Contents","tags":"","loc":"proc/allobjects.html"},{"title":"AllKeys – FTObjectLibrary","text":"public  function AllKeys(self) result(keys) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=FTDICT_KWD_STRING_LENGTH), POINTER, (:) Contents","tags":"","loc":"proc/allkeys.html"},{"title":"dictionaryFromObject – FTObjectLibrary","text":"public  function dictionaryFromObject(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTDictionary ), POINTER Contents","tags":"","loc":"proc/dictionaryfromobject.html"},{"title":"dictionaryClassName – FTObjectLibrary","text":"public  function dictionaryClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTDictionary \" ) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/dictionaryclassname.html"},{"title":"init – FTObjectLibrary","text":"public  subroutine init(self) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Calls proc~~init~~CallsGraph proc~init FTDictionaryClass::FTDictionary%init proc~initwithsize FTDictionaryClass::FTDictionary%initWithSize proc~init->proc~initwithsize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/init.html"},{"title":"initWithSize – FTObjectLibrary","text":"public  subroutine initWithSize(self, sze) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self integer, intent(in) :: sze Called by proc~~initwithsize~~CalledByGraph proc~initwithsize FTDictionaryClass::FTDictionary%initWithSize proc~init FTDictionaryClass::FTDictionary%init proc~init->proc~initwithsize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/initwithsize.html"},{"title":"releaseFTDictionary – FTObjectLibrary","text":"public  subroutine releaseFTDictionary(self) Arguments Type Intent Optional Attributes Name type( FTDictionary ), POINTER :: self Calls proc~~releaseftdictionary~~CallsGraph proc~releaseftdictionary FTDictionaryClass::releaseFTDictionary interface~release FTObjectClass::release proc~releaseftdictionary->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftdictionary.html"},{"title":"destructFTDictionary – FTObjectLibrary","text":"public  subroutine destructFTDictionary(self) Arguments Type Intent Optional Attributes Name type( FTDictionary ) :: self Contents","tags":"","loc":"proc/destructftdictionary.html"},{"title":"addObjectForKey – FTObjectLibrary","text":"public  subroutine addObjectForKey(self, object, key) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self class( FTObject ), POINTER :: object character(len=*) :: key Calls proc~~addobjectforkey~~CallsGraph proc~addobjectforkey FTDictionaryClass::FTDictionary%addObjectForKey interface~release FTObjectClass::release proc~addobjectforkey->interface~release proc~b3hs_hash_key_jenkins HashModule::b3hs_hash_key_jenkins proc~addobjectforkey->proc~b3hs_hash_key_jenkins proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/addobjectforkey.html"},{"title":"printFTDictionaryDescription – FTObjectLibrary","text":"public recursive subroutine printFTDictionaryDescription(self, iUnit) Type Bound FTDictionary Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printftdictionarydescription.html"},{"title":"castToDictionary – FTObjectLibrary","text":"public  subroutine castToDictionary(obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTDictionary ), POINTER :: cast Called by proc~~casttodictionary~~CalledByGraph proc~casttodictionary FTDictionaryClass::castToDictionary interface~cast~6 FTDictionaryClass::cast interface~cast~6->proc~casttodictionary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/casttodictionary.html"},{"title":"cast – FTObjectLibrary","text":"public interface cast Calls interface~~cast~6~~CallsGraph interface~cast~6 FTDictionaryClass::cast proc~casttodictionary FTDictionaryClass::castToDictionary interface~cast~6->proc~casttodictionary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures castToDictionary Module Procedures public  subroutine castToDictionary (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTDictionary ), POINTER :: cast","tags":"","loc":"interface/cast~6.html"},{"title":"realValue – FTObjectLibrary","text":"public  function realValue(self) Get the real value stored in the object, or convert the value\nin the object to a real if it is of a different type. Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value real Contents","tags":"","loc":"proc/realvalue.html"},{"title":"doublePrecisionValue – FTObjectLibrary","text":"public  function doublePrecisionValue(self) Get the double precision value stored in the object, or convert the value\nin the object to a double precision if it is of a different type. Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value doubleprecision Contents","tags":"","loc":"proc/doubleprecisionvalue.html"},{"title":"quadValue – FTObjectLibrary","text":"public  function quadValue(self) Get the double precision value stored in the object, or convert the value\nin the object to a double precision if it is of a different type. Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value doubleprecision Contents","tags":"","loc":"proc/quadvalue.html"},{"title":"integerValue – FTObjectLibrary","text":"public  function integerValue(self) Get the integer value stored in the object, or convert the value\nin the object to an integer if it is of a different type. Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value integer Contents","tags":"","loc":"proc/integervalue.html"},{"title":"logicalValue – FTObjectLibrary","text":"public  function logicalValue(self) Get the logical value stored in the object, or convert the value\nin the object to a logical if it is of a different type. Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value logical Contents","tags":"","loc":"proc/logicalvalue.html"},{"title":"stringValue – FTObjectLibrary","text":"public  function stringValue(self, requestedLength) result(s) Get the string value of length requestedLength stored in the object, or \nconvert the value\nin the object to a string of that length if it is of a different type. Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self integer :: requestedLength Return Value character(len=requestedLength) Contents","tags":"","loc":"proc/stringvalue.html"},{"title":"FTValueDescription – FTObjectLibrary","text":"public  function FTValueDescription(self) Returns the description of the value. In this case, it returns the \nstringValue() of the object. Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/ftvaluedescription.html"},{"title":"valueFromObject – FTObjectLibrary","text":"public  function valueFromObject(obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTValue ), POINTER Called by proc~~valuefromobject~~CalledByGraph proc~valuefromobject FTValueClass::valueFromObject proc~doubleprecisionvalueforkey FTValueDictionaryClass::FTValueDictionary%doublePrecisionValueForKey proc~doubleprecisionvalueforkey->proc~valuefromobject proc~integervalueforkey FTValueDictionaryClass::FTValueDictionary%integerValueForKey proc~integervalueforkey->proc~valuefromobject proc~logicalvalueforkey FTValueDictionaryClass::FTValueDictionary%logicalValueForKey proc~logicalvalueforkey->proc~valuefromobject proc~quadvalueforkey FTValueDictionaryClass::FTValueDictionary%quadValueForKey proc~quadvalueforkey->proc~valuefromobject proc~realvalueforkey FTValueDictionaryClass::FTValueDictionary%realValueForKey proc~realvalueforkey->proc~valuefromobject proc~stringvalueforkey FTValueDictionaryClass::FTValueDictionary%stringValueForKey proc~stringvalueforkey->proc~valuefromobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/valuefromobject.html"},{"title":"valueClassName – FTObjectLibrary","text":"public  function valueClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTValue \" ) Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/valueclassname.html"},{"title":"initWithReal – FTObjectLibrary","text":"public  subroutine initWithReal(self, v) Public, generic name: initwithValue() Initialize the value object with a real number Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self real :: v Contents","tags":"","loc":"proc/initwithreal.html"},{"title":"initWithDoublePrecision – FTObjectLibrary","text":"public  subroutine initWithDoublePrecision(self, v) Public, generic name: initwithValue() Initialize the value object with a double \nprecision number Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self doubleprecision :: v Contents","tags":"","loc":"proc/initwithdoubleprecision.html"},{"title":"initWithQuad – FTObjectLibrary","text":"public  subroutine initWithQuad(self, v) Public, generic name: initwithValue() Initialize the value object with a quad precision\nnumber Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)) :: v Contents","tags":"","loc":"proc/initwithquad.html"},{"title":"initWithInteger – FTObjectLibrary","text":"public  subroutine initWithInteger(self, v) Public, generic name: initwithValue() Initialize the value object with an \ninteger number Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self integer :: v Contents","tags":"","loc":"proc/initwithinteger.html"},{"title":"initWithLogical – FTObjectLibrary","text":"public  subroutine initWithLogical(self, v) Public, generic name: initwithValue() Initialize the value object with a logical Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self logical :: v Contents","tags":"","loc":"proc/initwithlogical.html"},{"title":"initWithString – FTObjectLibrary","text":"public  subroutine initWithString(self, v) Public, generic name: initwithValue() Initialize the value object with a string Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self character(len=*) :: v Contents","tags":"","loc":"proc/initwithstring.html"},{"title":"releaseFTValue – FTObjectLibrary","text":"public  subroutine releaseFTValue(self) Arguments Type Intent Optional Attributes Name type( FTValue ), POINTER :: self Calls proc~~releaseftvalue~~CallsGraph proc~releaseftvalue FTValueClass::releaseFTValue interface~release FTObjectClass::release proc~releaseftvalue->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftvalue.html"},{"title":"destructValue – FTObjectLibrary","text":"public  subroutine destructValue(self) Public, generic name: destruct() Destructor for the class. Arguments Type Intent Optional Attributes Name type( FTValue ) :: self Contents","tags":"","loc":"proc/destructvalue.html"},{"title":"printValueDescription – FTObjectLibrary","text":"public  subroutine printValueDescription(self, iUnit) Prints the description of the value to unit iUnit. In this case, it prints the stringValue() of the object. Type Bound FTValue Arguments Type Intent Optional Attributes Name class( FTValue ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printvaluedescription.html"},{"title":"castToValue – FTObjectLibrary","text":"public  subroutine castToValue(obj, cast) Generic Name: cast Cast a pointer to the base class to an FTValue pointer Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTValue ), POINTER :: cast Called by proc~~casttovalue~~CalledByGraph proc~casttovalue FTValueClass::castToValue interface~cast~7 FTValueClass::cast interface~cast~7->proc~casttovalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/casttovalue.html"},{"title":"cast – FTObjectLibrary","text":"public interface cast Calls interface~~cast~7~~CallsGraph interface~cast~7 FTValueClass::cast proc~casttovalue FTValueClass::castToValue interface~cast~7->proc~casttovalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures castToValue Module Procedures public  subroutine castToValue (obj, cast) Generic Name: cast Read more… Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTValue ), POINTER :: cast","tags":"","loc":"interface/cast~7.html"},{"title":"stringCount – FTObjectLibrary","text":"public  function stringCount(self) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value integer Contents","tags":"","loc":"proc/stringcount.html"},{"title":"containsString – FTObjectLibrary","text":"public  function containsString(self, str) containsString returns .TRUE. if the set contains the string, .FALSE. \n otherwise. Usage: if ( set % containsString ( str )) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self character(len=*) :: str Return Value logical Contents","tags":"","loc":"proc/containsstring.html"},{"title":"strings – FTObjectLibrary","text":"public  function strings(self) result(s) strings returns a pointer to an array of strings that are in the set.\n Deallocate this array when done with it. Usage: CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) , DIMENSION ( : ) , POINTER :: s s => set % strings ... do something ... DEALLOCATE ( s ) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value character(len=FTDICT_KWD_STRING_LENGTH), DIMENSION(:), POINTER Contents","tags":"","loc":"proc/strings.html"},{"title":"unionWithSet – FTObjectLibrary","text":"public  function unionWithSet(self, set) result(newSet) unionWithSet returns a pointer to a new set that is the union of two sets.\n the new set has reference count of 1. Release when done. Usage: newSet => set1 % unionWithSet ( set2 ) ... do something ... call releaseFTStringSet ( newSet ) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self class( FTStringSet ) :: set Return Value type( FTStringSet ), POINTER Contents","tags":"","loc":"proc/unionwithset.html"},{"title":"intersectionWithSet – FTObjectLibrary","text":"public  function intersectionWithSet(self, set) result(newSet) intersectionWithSet returns a pointer to a new set that is the intersection of two sets.\n the new set has reference count of 1. Release when done. Usage: newSet => set1 % intersectionWithSet ( set2 ) ... do something ... call releaseFTStringSet ( newSet ) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self class( FTStringSet ) :: set Return Value type( FTStringSet ), POINTER Contents","tags":"","loc":"proc/intersectionwithset.html"},{"title":"setFromDifference – FTObjectLibrary","text":"public  function setFromDifference(self, set) result(newSet) setFromDifference returns a pointer to a new set that is the difference of two sets. the new set has reference count of 1. Release when done. Usage: newSet => set1 % setFromDifference ( set2 ) ... do something ... call releaseFTStringSet ( newSet ) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self class( FTStringSet ) :: set Return Value type( FTStringSet ), POINTER Contents","tags":"","loc":"proc/setfromdifference.html"},{"title":"isEmpty – FTObjectLibrary","text":"public  function isEmpty(self) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value logical Contents","tags":"","loc":"proc/isempty.html"},{"title":"FTStringSetFromObject – FTObjectLibrary","text":"public  function FTStringSetFromObject(obj) result(cast) Generic Name: cast Cast a pointer to the base class to an FTStringSet pointer Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTStringSet ), POINTER Contents","tags":"","loc":"proc/ftstringsetfromobject.html"},{"title":"FTStringSetClassName – FTObjectLibrary","text":"public  function FTStringSetClassName(self) result(s) Class name returns a string with the name of the type of the object Usage: PRINT * , obj % className () if ( obj % className = \" FTStringSet \" ) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/ftstringsetclassname.html"},{"title":"initFTStringSet – FTObjectLibrary","text":"public  subroutine initFTStringSet(self, FTStringSetSize) Designated initializer. Initializes the amount of storage, but\nthe FTStringSet remains empty. *Usage\n      CLASS(FTStringSet)  :: FTStringSet\n      integer             :: N = 11\n      logical             :: cs = .true.\n      CALL FTStringSet % initFTStringSet(N) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self integer :: FTStringSetSize Contents","tags":"","loc":"proc/initftstringset.html"},{"title":"initWithStrings – FTObjectLibrary","text":"public  subroutine initWithStrings(self, strings) initializer. Initializes the amount of storage from the strings passed Usage\n      CLASS(FTStringSet)  :: FTStringSet\n      CHARACTER(LEN= )    :: strings(:)\n      CALL FTStringSet % initWithStrings(strings) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self character(len=*) :: strings (:) Contents","tags":"","loc":"proc/initwithstrings.html"},{"title":"destructFTStringSet – FTObjectLibrary","text":"public  subroutine destructFTStringSet(self) Destructor for the class. This is called automatically when the\nreference count reaches zero. Do not call this yourself on pointers Arguments Type Intent Optional Attributes Name type( FTStringSet ) :: self Contents","tags":"","loc":"proc/destructftstringset.html"},{"title":"releaseFTStringSet – FTObjectLibrary","text":"public  subroutine releaseFTStringSet(self) Public, generic name: release(self) Call release(self) on an object to release control\nof an object. If its reference count is zero, then \nit is deallocated. Arguments Type Intent Optional Attributes Name type( FTStringSet ), POINTER :: self Calls proc~~releaseftstringset~~CallsGraph proc~releaseftstringset FTStringSetClass::releaseFTStringSet interface~release FTObjectClass::release proc~releaseftstringset->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftstringset.html"},{"title":"AddString – FTObjectLibrary","text":"public  subroutine AddString(self, str) AddString adds a string to the set if it is not already present Usage: CALL set % addString(str) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self character(len=*) :: str Calls proc~~addstring~~CallsGraph proc~addstring FTStringSetClass::FTStringSet%AddString interface~release FTObjectClass::release proc~addstring->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/addstring.html"},{"title":"printFTStringSet – FTObjectLibrary","text":"public  subroutine printFTStringSet(self, iUnit) Type Bound FTStringSet Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printftstringset.html"},{"title":"objectAtIndex – FTObjectLibrary","text":"public  function objectAtIndex(self, indx) result(obj) Access the object at the index indx *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: indx\n  CLASS(FTObject), POINTER    :: obj\n  obj => array % objectAtIndex(indx) Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: indx Return Value class( FTObject ), POINTER Contents","tags":"","loc":"proc/objectatindex.html"},{"title":"chunkSize – FTObjectLibrary","text":"public  function chunkSize(self) Returns the number of items to be added when the array needs to be re-sized *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: sze\n  sze =  array % chunkSize Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value integer Contents","tags":"","loc":"proc/chunksize.html"},{"title":"numberOfItems – FTObjectLibrary","text":"public  function numberOfItems(self) Generic name: count Returns the acutal number of items in the array. *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: sze\n  sze =  array % count() Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value integer Contents","tags":"","loc":"proc/numberofitems.html"},{"title":"allocatedSize – FTObjectLibrary","text":"public  function allocatedSize(self) Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value integer Contents","tags":"","loc":"proc/allocatedsize.html"},{"title":"objectArrayFromObject – FTObjectLibrary","text":"public  function objectArrayFromObject(obj) result(cast) Generic Name: cast Cast a pointer to the base class to an FTMutableObjectArray pointer Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTMutableObjectArray ), POINTER Contents","tags":"","loc":"proc/objectarrayfromobject.html"},{"title":"arrayClassName – FTObjectLibrary","text":"public  function arrayClassName(self) result(s) Class name returns a string with the name of the type of the object ### Usage: PRINT * , obj % className () if ( obj % className = \" FTMutableObjectArray \" ) Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Contents","tags":"","loc":"proc/arrayclassname.html"},{"title":"initObjectArrayWithSize – FTObjectLibrary","text":"public  subroutine initObjectArrayWithSize(self, arraySize) Designated initializer. Initializes the amount of storage, but\nthe array remains empty. *Usage CLASS(FTMutableObjectArray)  :: array\n  integer                      :: N = 11\n  CALL array % initWithSize(N) Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: arraySize Contents","tags":"","loc":"proc/initobjectarraywithsize.html"},{"title":"releaseFTMutableObjectArray – FTObjectLibrary","text":"public  subroutine releaseFTMutableObjectArray(self) Arguments Type Intent Optional Attributes Name type( FTMutableObjectArray ), POINTER :: self Calls proc~~releaseftmutableobjectarray~~CallsGraph proc~releaseftmutableobjectarray FTMutableObjectArrayClass::releaseFTMutableObjectArray interface~release FTObjectClass::release proc~releaseftmutableobjectarray->interface~release proc~releaseftobject FTObjectClass::releaseFTObject interface~release->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/releaseftmutableobjectarray.html"},{"title":"destructObjectArray – FTObjectLibrary","text":"public recursive subroutine destructObjectArray(self) Destructor for the class. This is called automatically when the\nreference count reaches zero. Do not call this yourself. Arguments Type Intent Optional Attributes Name type( FTMutableObjectArray ) :: self Calls proc~~destructobjectarray~~CallsGraph proc~destructobjectarray FTMutableObjectArrayClass::destructObjectArray proc~releaseftobject FTObjectClass::releaseFTObject proc~destructobjectarray->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/destructobjectarray.html"},{"title":"addObjectToArray – FTObjectLibrary","text":"public  subroutine addObjectToArray(self, obj) Add an object to the end of the array *Usage CLASS(FTMutableObjectArray)      :: array\n  CLASS(FTObject)        , POINTER :: obj\n  CLASS(FTObjectSubclass), POINTER :: p\n  obj => p\n  CALL array % addObject(obj) Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self class( FTObject ), POINTER :: obj Contents","tags":"","loc":"proc/addobjecttoarray.html"},{"title":"removeObjectAtIndex – FTObjectLibrary","text":"public  subroutine removeObjectAtIndex(self, indx) Remove an object at the index indx *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: indx\n  CALL array % removeObjectAtIndex(indx) Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: indx Calls proc~~removeobjectatindex~~CallsGraph proc~removeobjectatindex FTMutableObjectArrayClass::FTMutableObjectArray%removeObjectAtIndex proc~releaseftobject FTObjectClass::releaseFTObject proc~removeobjectatindex->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/removeobjectatindex.html"},{"title":"replaceObjectAtIndexWithObject – FTObjectLibrary","text":"public  subroutine replaceObjectAtIndexWithObject(self, indx, replacement) Replace an object at the index indx Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: indx\n  CALL array % replaceObjectAtIndexWithObject(indx) Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: indx class( FTObject ), POINTER :: replacement Calls proc~~replaceobjectatindexwithobject~~CallsGraph proc~replaceobjectatindexwithobject FTMutableObjectArrayClass::FTMutableObjectArray%replaceObjectAtIndexWithObject proc~releaseftobject FTObjectClass::releaseFTObject proc~replaceobjectatindexwithobject->proc~releaseftobject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/replaceobjectatindexwithobject.html"},{"title":"printArray – FTObjectLibrary","text":"public  subroutine printArray(self, iUnit) Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: iUnit Contents","tags":"","loc":"proc/printarray.html"},{"title":"setChunkSize – FTObjectLibrary","text":"public  subroutine setChunkSize(self, chunkSize) Set the number of items to be added when the array needs to be re-sized *Usage CLASS(FTMutableObjectArray) :: array\n  INTEGER                     :: sze = 42\n  CALL array % setChunkSize(sze) Type Bound FTMutableObjectArray Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: chunkSize Contents","tags":"","loc":"proc/setchunksize.html"},{"title":"castToMutableObjectArray – FTObjectLibrary","text":"public  subroutine castToMutableObjectArray(obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTMutableObjectArray ), POINTER :: cast Called by proc~~casttomutableobjectarray~~CalledByGraph proc~casttomutableobjectarray FTMutableObjectArrayClass::castToMutableObjectArray interface~cast~5 FTMutableObjectArrayClass::cast interface~cast~5->proc~casttomutableobjectarray proc~peeklastexception SharedExceptionManagerModule::peekLastException proc~peeklastexception->interface~cast~5 proc~poplastexception SharedExceptionManagerModule::popLastException proc~poplastexception->interface~cast~5 proc~printallexceptions SharedExceptionManagerModule::printAllExceptions proc~printallexceptions->interface~cast~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/casttomutableobjectarray.html"},{"title":"cast – FTObjectLibrary","text":"public interface cast Calls interface~~cast~5~~CallsGraph interface~cast~5 FTMutableObjectArrayClass::cast proc~casttomutableobjectarray FTMutableObjectArrayClass::castToMutableObjectArray interface~cast~5->proc~casttomutableobjectarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~cast~5~~CalledByGraph interface~cast~5 FTMutableObjectArrayClass::cast proc~peeklastexception SharedExceptionManagerModule::peekLastException proc~peeklastexception->interface~cast~5 proc~poplastexception SharedExceptionManagerModule::popLastException proc~poplastexception->interface~cast~5 proc~printallexceptions SharedExceptionManagerModule::printAllExceptions proc~printallexceptions->interface~cast~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures castToMutableObjectArray Module Procedures public  subroutine castToMutableObjectArray (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTMutableObjectArray ), POINTER :: cast","tags":"","loc":"interface/cast~5.html"},{"title":"sharedAssertionsManager – FTObjectLibrary","text":"public  function sharedAssertionsManager() Arguments None Return Value type( FTAssertionsManager ), POINTER Contents None","tags":"","loc":"proc/sharedassertionsmanager.html"},{"title":"numberOfAssertions – FTObjectLibrary","text":"public  function numberOfAssertions(self) Type Bound FTAssertionsManager Arguments Type Intent Optional Attributes Name class( FTAssertionsManager ) :: self Return Value integer Contents","tags":"","loc":"proc/numberofassertions.html"},{"title":"numberOfAssertionFailures – FTObjectLibrary","text":"public  function numberOfAssertionFailures(self) Type Bound FTAssertionsManager Arguments Type Intent Optional Attributes Name class( FTAssertionsManager ) :: self Return Value integer Contents","tags":"","loc":"proc/numberofassertionfailures.html"},{"title":"detachSharedAssertionsManager – FTObjectLibrary","text":"public  subroutine detachSharedAssertionsManager() Arguments None Contents None","tags":"","loc":"proc/detachsharedassertionsmanager.html"},{"title":"initializeSharedAssertionsManager – FTObjectLibrary","text":"public  subroutine initializeSharedAssertionsManager() Arguments None Called by proc~~initializesharedassertionsmanager~~CalledByGraph proc~initializesharedassertionsmanager FTAssertions::initializeSharedAssertionsManager proc~assertwithintolerancetwoquad FTAssertions::assertWithinToleranceTwoQuad proc~assertwithintolerancetwoquad->proc~initializesharedassertionsmanager proc~ftassert FTAssertions::FTAssert proc~ftassert->proc~initializesharedassertionsmanager interface~ftassertequal FTAssertions::FTAssertEqual interface~ftassertequal->proc~assertwithintolerancetwoquad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initializesharedassertionsmanager.html"},{"title":"finalizeSharedAssertionsManager – FTObjectLibrary","text":"public  subroutine finalizeSharedAssertionsManager() Arguments None Contents None","tags":"","loc":"proc/finalizesharedassertionsmanager.html"},{"title":"FTAssert – FTObjectLibrary","text":"public  subroutine FTAssert(test, msg) Arguments Type Intent Optional Attributes Name logical :: test character(len=*), optional :: msg Calls proc~~ftassert~~CallsGraph proc~ftassert FTAssertions::FTAssert proc~initializesharedassertionsmanager FTAssertions::initializeSharedAssertionsManager proc~ftassert->proc~initializesharedassertionsmanager Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/ftassert.html"},{"title":"assertWithinToleranceTwoQuad – FTObjectLibrary","text":"public  subroutine assertWithinToleranceTwoQuad(expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: expectedValue real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: actualValue real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: tol character(len=*), optional :: msg Calls proc~~assertwithintolerancetwoquad~~CallsGraph proc~assertwithintolerancetwoquad FTAssertions::assertWithinToleranceTwoQuad interface~isequal ComparisonsModule::isEqual proc~assertwithintolerancetwoquad->interface~isequal proc~initializesharedassertionsmanager FTAssertions::initializeSharedAssertionsManager proc~assertwithintolerancetwoquad->proc~initializesharedassertionsmanager Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~assertwithintolerancetwoquad~~CalledByGraph proc~assertwithintolerancetwoquad FTAssertions::assertWithinToleranceTwoQuad interface~ftassertequal FTAssertions::FTAssertEqual interface~ftassertequal->proc~assertwithintolerancetwoquad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/assertwithintolerancetwoquad.html"},{"title":"FTAssertEqual – FTObjectLibrary","text":"public interface FTAssertEqual Calls interface~~ftassertequal~~CallsGraph interface~ftassertequal FTAssertions::FTAssertEqual proc~assertwithintolerancetwoquad FTAssertions::assertWithinToleranceTwoQuad interface~ftassertequal->proc~assertwithintolerancetwoquad interface~isequal ComparisonsModule::isEqual proc~assertwithintolerancetwoquad->interface~isequal proc~initializesharedassertionsmanager FTAssertions::initializeSharedAssertionsManager proc~assertwithintolerancetwoquad->proc~initializesharedassertionsmanager Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures assertEqualTwoIntegers assertEqualTwoIntegerArrays1D assertEqualTwoIntegerArrays2D assertWithinToleranceTwoReal assertWithinToleranceTwoRealArrays1D assertWithinToleranceTwoRealArrays2D assertWithinToleranceTwoDouble assertWithinToleranceTwoDoubleArrays1D assertWithinToleranceTwoDoubleArrays2D assertWithinToleranceTwoQuad assertEqualTwoLogicals assertEqualString Module Procedures private  subroutine assertEqualTwoIntegers(expectedValue, actualValue, msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expectedValue integer, intent(in) :: actualValue character(len=*), optional :: msg private  subroutine assertEqualTwoIntegerArrays1D(expectedValue, actualValue) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: expectedValue integer, intent(in), DIMENSION(:) :: actualValue private  subroutine assertEqualTwoIntegerArrays2D(expectedValue, actualValue) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:,:) :: expectedValue integer, intent(in), DIMENSION(:,:) :: actualValue private  subroutine assertWithinToleranceTwoReal(expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name real, intent(in) :: expectedValue real, intent(in) :: actualValue real, intent(in) :: tol character(len=*), optional :: msg private  subroutine assertWithinToleranceTwoRealArrays1D(expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(:) :: expectedValue real, intent(in), DIMENSION(:) :: actualValue real, intent(in) :: tol character(len=*), optional :: msg private  subroutine assertWithinToleranceTwoRealArrays2D(expectedValue, actualValue, tol) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(:,:) :: expectedValue real, intent(in), DIMENSION(:,:) :: actualValue real, intent(in) :: tol private  subroutine assertWithinToleranceTwoDouble(expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expectedValue double precision, intent(in) :: actualValue double precision, intent(in) :: tol character(len=*), optional :: msg private  subroutine assertWithinToleranceTwoDoubleArrays1D(expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(:) :: expectedValue double precision, intent(in), DIMENSION(:) :: actualValue double precision, intent(in) :: tol character(len=*), optional :: msg private  subroutine assertWithinToleranceTwoDoubleArrays2D(expectedValue, actualValue, tol) Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(:,:) :: expectedValue double precision, intent(in), DIMENSION(:,:) :: actualValue double precision, intent(in) :: tol public  subroutine assertWithinToleranceTwoQuad (expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: expectedValue real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: actualValue real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: tol character(len=*), optional :: msg private  subroutine assertEqualTwoLogicals(expectedValue, actualValue, msg) Arguments Type Intent Optional Attributes Name logical, intent(in) :: expectedValue logical, intent(in) :: actualValue character(len=*), optional :: msg private  subroutine assertEqualString(expectedValue, actualValue, msg) Arguments Type Intent Optional Attributes Name character(len=*) :: expectedValue character(len=*) :: actualValue character(len=*), optional :: msg","tags":"","loc":"interface/ftassertequal.html"},{"title":"isEqual – FTObjectLibrary","text":"public interface isEqual Called by interface~~isequal~~CalledByGraph interface~isequal ComparisonsModule::isEqual proc~assertwithintolerancetwoquad FTAssertions::assertWithinToleranceTwoQuad proc~assertwithintolerancetwoquad->interface~isequal interface~ftassertequal FTAssertions::FTAssertEqual interface~ftassertequal->proc~assertwithintolerancetwoquad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures isEqualTwoIntegers isEqualTwoIntegerArrays1D isEqualTwoIntegerArrays2D isWithinToleranceTwoReal isWithinToleranceTwoRealArrays1D isWithinToleranceTwoRealArrays2D isWithinToleranceTwoDouble isWithinToleranceTwoDoubleArrays1D isWithinToleranceTwoDoubleArrays2D isEqualString isWithinToleranceTwoQuad Module Procedures private  function isEqualTwoIntegers(i, j) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical private  function isEqualTwoIntegerArrays1D(a, b, info) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: a integer, intent(in), DIMENSION(:) :: b type( assertInfoArray1D ), intent(inout), optional :: info Return Value logical private  function isEqualTwoIntegerArrays2D(a, b, info) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:,:) :: a integer, intent(in), DIMENSION(:,:) :: b type( assertInfoArray2D ), intent(inout), optional :: info Return Value logical private  function isWithinToleranceTwoReal(x, y, tol) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: tol Return Value logical private  function isWithinToleranceTwoRealArrays1D(a, b, tol, code) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(:) :: a real, intent(in), DIMENSION(:) :: b real, intent(in) :: tol integer, intent(out), optional :: code Return Value logical private  function isWithinToleranceTwoRealArrays2D(a, b, tol, code) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(:,:) :: a real, intent(in), DIMENSION(:,:) :: b real, intent(in) :: tol integer, intent(out), optional :: code Return Value logical private  function isWithinToleranceTwoDouble(x, y, tol) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: tol Return Value logical private  function isWithinToleranceTwoDoubleArrays1D(a, b, tol, code) Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(:) :: a double precision, intent(in), DIMENSION(:) :: b double precision, intent(in) :: tol integer, intent(out), optional :: code Return Value logical private  function isWithinToleranceTwoDoubleArrays2D(a, b, tol, code) Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(:,:) :: a double precision, intent(in), DIMENSION(:,:) :: b double precision, intent(in) :: tol integer, intent(out), optional :: code Return Value logical private  function isEqualString(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*) :: s1 character(len=*) :: s2 Return Value logical private  function isWithinToleranceTwoQuad(x, y, tol) Arguments Type Intent Optional Attributes Name real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: x real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: y real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: tol Return Value logical","tags":"","loc":"interface/isequal.html"},{"title":"FTObjectLibrary – FTObjectLibrary","text":"A module that simply USEs the entire library modules. Uses FTValueClass ComparisonsModule FTExceptionClass TestSuiteManagerClass FTObjectClass FTSparseMatrixClass FTDictionaryClass FTValueDictionaryClass FTMutableObjectArrayClass FTLinkedListClass FTAssertions FTStackClass FTLinkedListIteratorClass module~~ftobjectlibrary~~UsesGraph module~ftobjectlibrary FTObjectLibrary module~comparisonsmodule ComparisonsModule module~ftobjectlibrary->module~comparisonsmodule module~ftassertions FTAssertions module~ftobjectlibrary->module~ftassertions module~ftdictionaryclass FTDictionaryClass module~ftobjectlibrary->module~ftdictionaryclass module~ftexceptionclass FTExceptionClass module~ftobjectlibrary->module~ftexceptionclass module~ftlinkedlistclass FTLinkedListClass module~ftobjectlibrary->module~ftlinkedlistclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftobjectlibrary->module~ftlinkedlistiteratorclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftobjectlibrary->module~ftmutableobjectarrayclass module~ftobjectclass FTObjectClass module~ftobjectlibrary->module~ftobjectclass module~ftsparsematrixclass FTSparseMatrixClass module~ftobjectlibrary->module~ftsparsematrixclass module~ftstackclass FTStackClass module~ftobjectlibrary->module~ftstackclass module~ftvalueclass FTValueClass module~ftobjectlibrary->module~ftvalueclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftobjectlibrary->module~ftvaluedictionaryclass module~testsuitemanagerclass TestSuiteManagerClass module~ftobjectlibrary->module~testsuitemanagerclass iso_fortran_env iso_fortran_env module~comparisonsmodule->iso_fortran_env module~ftolconstants FTOLConstants module~comparisonsmodule->module~ftolconstants module~ftassertions->module~comparisonsmodule module~ftassertions->iso_fortran_env module~ftassertions->module~ftolconstants module~ftdictionaryclass->module~ftlinkedlistclass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftdictionaryclass->module~ftmutableobjectarrayclass module~ftkeyobjectpairclass FTKeyObjectPairClass module~ftdictionaryclass->module~ftkeyobjectpairclass module~hashmodule HashModule module~ftdictionaryclass->module~hashmodule module~ftexceptionclass->module~ftdictionaryclass module~ftexceptionclass->module~ftlinkedlistiteratorclass module~ftexceptionclass->module~ftstackclass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftmutableobjectarrayclass->module~ftobjectclass module~ftsparsematrixclass->module~ftlinkedlistclass module~ftsparsematrixclass->module~ftlinkedlistiteratorclass module~ftsparsematrixclass->module~ftobjectclass module~ftsparsematrixdata FTSparseMatrixData module~ftsparsematrixclass->module~ftsparsematrixdata module~ftstackclass->module~ftlinkedlistclass module~ftvalueclass->module~ftobjectclass ieee_arithmetic ieee_arithmetic module~ftvalueclass->ieee_arithmetic module~ftvalueclass->iso_fortran_env module~ftvalueclass->module~ftolconstants module~ftvaluedictionaryclass->module~ftdictionaryclass module~ftvaluedictionaryclass->module~ftvalueclass module~ftvaluedictionaryclass->iso_fortran_env module~testsuitemanagerclass->module~ftassertions module~ftkeyobjectpairclass->module~ftobjectclass module~ftlinkedlistrecordclass->module~ftobjectclass module~ftsparsematrixdata->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents None","tags":"","loc":"module/ftobjectlibrary.html"},{"title":"HashModule – FTObjectLibrary","text":"Used by module~~hashmodule~~UsedByGraph module~hashmodule HashModule module~ftdictionaryclass FTDictionaryClass module~ftdictionaryclass->module~hashmodule module~ftexceptionclass FTExceptionClass module~ftexceptionclass->module~ftdictionaryclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftdictionaryclass module~ftobjectlibrary->module~ftexceptionclass module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftstringsetclass FTStringSetClass module~ftstringsetclass->module~ftdictionaryclass module~ftvaluedictionaryclass->module~ftdictionaryclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions b3hs_hash_key_jenkins Functions public  function b3hs_hash_key_jenkins (key, range) result(code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key integer, intent(in) :: range Return Value integer","tags":"","loc":"module/hashmodule.html"},{"title":"FTSparseMatrixData – FTObjectLibrary","text":"FTSparseMatrixData is used by the FTSparseMatrix Class. Users will \nusually not interact with or use this class directly. Uses FTObjectClass module~~ftsparsematrixdata~~UsesGraph module~ftsparsematrixdata FTSparseMatrixData module~ftobjectclass FTObjectClass module~ftsparsematrixdata->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftsparsematrixdata~~UsedByGraph module~ftsparsematrixdata FTSparseMatrixData module~ftsparsematrixclass FTSparseMatrixClass module~ftsparsematrixclass->module~ftsparsematrixdata module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftsparsematrixclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces cast Derived Types MatrixData Functions matrixDataCast Subroutines initWithObjectAndKey releaseFTMatrixData destructMatrixData castObjectToMatrixData Interfaces public        interface cast public  subroutine castObjectToMatrixData (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( MatrixData ), POINTER :: cast Derived Types type, public, extends( FTObject ) :: MatrixData Components Type Visibility Attributes Name Initial integer, public :: key class( FTObject ), public, POINTER :: object Finalizations Procedures final :: destructMatrixData Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTObjectDescription Subroutine procedure\n                    ,                  public\n,                   :: className Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: initWithObjectAndKey Subroutine Functions public  function matrixDataCast (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( MatrixData ), POINTER Subroutines public  subroutine initWithObjectAndKey (self, object, key) Arguments Type Intent Optional Attributes Name class( MatrixData ) :: self class( FTObject ), POINTER :: object integer :: key public  subroutine releaseFTMatrixData (self) Arguments Type Intent Optional Attributes Name type( MatrixData ), POINTER :: self public  subroutine destructMatrixData (self) Arguments Type Intent Optional Attributes Name type( MatrixData ) :: self public  subroutine castObjectToMatrixData (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( MatrixData ), POINTER :: cast","tags":"","loc":"module/ftsparsematrixdata.html"},{"title":"FTSparseMatrixClass – FTObjectLibrary","text":"The sparse matrix stores an FTObject pointer associated\nwith two keys (i,j) as a hash table. Hash tables are data structures designed to enable storage and fast\nretrieval of key-value pairs. An example of a key-value pair is\na variable name ( gamma'') and its associated value ( 1.4'').\nThe table itself is typically an array.\nThe location of the value in a hash table associated with\na key, $k$, is specified by way of a hash function, $H(k)$.\nIn the case of a variable name and value, the hash function\nwould convert the name into an integer that tells where to\nfind the associated value in the table. A very simple example of a\nhash table is, in fact, a singly dimensioned array. The key is \nthe array index and the value is what is stored at that index.\nMultiple keys can be used to identify data; a two dimensional\narray provides an example of where two keys are used to access memory\nand retrieve the value at that location.\nIf we view a singly dimensioned array as a special case of a hash table,\nits hash function is just the array index, $H(j)=j$. A doubly dimensioned array\ncould be (and often is) stored columnwise as a singly dimensioned array by creating a hash\nfunction that maps the two indices to a single location in the array, e.g.,\n$H(i,j) = i + j*N$, where $N$ is the range of the first index, $i$. Two classes are included in FTObjectLibrary. The first, FTSparseMatrix, works with an ordered pair, (i,j), as the\nkeys. The second, FTMultiIndexTable, uses an array of integers as the keys. Both classes include enquiry functions to see of an object exists for the given keys. Otherwise,\nthe function that returns an object for a given key will return an UNASSOCIATED pointer if there\nis no object for the key. Be sure to retain any object returned by the objectForKeys methods if \nyou want to keep it beyond the lifespan of the matrix or table. For example, TYPE ( FTObject ) :: obj obj => matrix % objectForKeys ( i , j ) IF ( ASSOCIATED ( OBJ ) ) THEN CALL obj % retain () Cast obj to something useful ELSE Perform some kind of error recovery END IF The sparse matrix stores an FTObject pointer associated\nwith two keys (i,j) as a hash table. The size, N = the range of i. Definition (Subclass of FTObject) TYPE(FTSparseMatrix) :: SparseMatrix Usage Initialization CALL SparseMatrix % initWithSize(N) Destruction CALL releaseFTSparseMatrix ( SparseMatrix ) [ Pointers ] Adding an object CLASS(FTObject), POINTER :: obj\n     CALL SparseMatrix % addObjectForKeys(obj,i,j) Retrieving an object CLASS(FTObject), POINTER :: obj\n     obj => SparseMatrix % objectForKeys(i,j) Be sure to retain the object if you want it to live\n      beyond the life of the table. Testing the presence of keys LOGICAL :: exists\n     exists = SparseMatrix % containsKeys(i,j) Uses FTObjectClass FTLinkedListIteratorClass FTSparseMatrixData FTLinkedListClass module~~ftsparsematrixclass~~UsesGraph module~ftsparsematrixclass FTSparseMatrixClass module~ftlinkedlistclass FTLinkedListClass module~ftsparsematrixclass->module~ftlinkedlistclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftsparsematrixclass->module~ftlinkedlistiteratorclass module~ftobjectclass FTObjectClass module~ftsparsematrixclass->module~ftobjectclass module~ftsparsematrixdata FTSparseMatrixData module~ftsparsematrixclass->module~ftsparsematrixdata module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftsparsematrixdata->module~ftobjectclass module~ftlinkedlistrecordclass->module~ftobjectclass module~ftmutableobjectarrayclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftsparsematrixclass~~UsedByGraph module~ftsparsematrixclass FTSparseMatrixClass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftsparsematrixclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types FTSparseMatrix Functions objectInSparseMatrixForKeys SparseMatrixContainsKeys SparseMatrixSize SparseMatrixFromObject Hash1 Hash2 Subroutines initSparseMatrixWithSize addObjectToSparseMatrixForKeys releaseFTSparseMatrix destructSparseMatrix releaseSMMemberList Derived Types type, public, extends( FTObject ) :: FTSparseMatrix Components Type Visibility Attributes Name Initial type(FTLinkedListPtr), public, DIMENSION(:), ALLOCATABLE :: table Finalizations Procedures final :: destructSparseMatrix Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTObjectDescription Subroutine procedure\n                    ,                  public\n,                   :: className Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: initWithSize => initSparseMatrixWithSize Subroutine procedure\n                    ,                  public\n,                   :: containsKeys => SparseMatrixContainsKeys Function procedure\n                    ,                  public\n,                   :: addObjectForKeys => addObjectToSparseMatrixForKeys Subroutine procedure\n                    ,                  public\n,                   :: objectForKeys => objectInSparseMatrixForKeys Function procedure\n                    ,                  public\n,                   :: SparseMatrixSize Function Functions public  function objectInSparseMatrixForKeys (self, i, j) result(r) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self integer :: i integer :: j Return Value class( FTObject ), POINTER public  function SparseMatrixContainsKeys (self, i, j) result(r) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self integer :: i integer :: j Return Value logical public  function SparseMatrixSize (self) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self Return Value integer public  function SparseMatrixFromObject (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTSparseMatrix ), POINTER public  function Hash1 (idPair) Arguments Type Intent Optional Attributes Name integer, DIMENSION(2) :: idPair Return Value integer public  function Hash2 (idPair) Arguments Type Intent Optional Attributes Name integer, DIMENSION(2) :: idPair Return Value integer Subroutines public  subroutine initSparseMatrixWithSize (self, N) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self integer :: N public  subroutine addObjectToSparseMatrixForKeys (self, obj, i, j) Arguments Type Intent Optional Attributes Name class( FTSparseMatrix ) :: self class( FTObject ), POINTER :: obj integer :: i integer :: j public  subroutine releaseFTSparseMatrix (self) Arguments Type Intent Optional Attributes Name type( FTSparseMatrix ), POINTER :: self public  subroutine destructSparseMatrix (self) Arguments Type Intent Optional Attributes Name type( FTSparseMatrix ) :: self public  subroutine releaseSMMemberList (list) Arguments Type Intent Optional Attributes Name class( FTLinkedList ), POINTER :: list","tags":"","loc":"module/ftsparsematrixclass.html"},{"title":"FTStackClass – FTObjectLibrary","text":"Inherits from FTLinkedListClass : FTObjectClass Definition (Subclass of FTLinkedListClass): TYPE(FTStack) :: list Usage: Initialization ALLOCATE ( stack ) If stack is a pointer CALL stack % init () Destruction CALL releaseFTStack ( stack ) [ Pointers ] Pushing an object onto the stack TYPE(FTObject) :: objectPtr\n  objectPtr => r1\n  CALL stack % push(objectPtr) Peeking at the top of the stack objectPtr => stack % peek () No change of ownership SELECT TYPE ( objectPtr ) TYPE is (*SubclassType*) … Do something with ObjectPtr as subclass CLASS DEFAULT … Problem with casting END SELECT Popping the top of the stack objectPtr => stack % pop () Ownership transferred to caller SELECT TYPE ( objectPtr ) TYPE is (*SubclassType*) … Do something with ObjectPtr as subclass CLASS DEFAULT … Problem with casting END SELECT Uses FTLinkedListClass module~~ftstackclass~~UsesGraph module~ftstackclass FTStackClass module~ftlinkedlistclass FTLinkedListClass module~ftstackclass->module~ftlinkedlistclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftobjectclass FTObjectClass module~ftlinkedlistrecordclass->module~ftobjectclass module~ftmutableobjectarrayclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftstackclass~~UsedByGraph module~ftstackclass FTStackClass module~ftexceptionclass FTExceptionClass module~ftexceptionclass->module~ftstackclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftstackclass module~ftobjectlibrary->module~ftexceptionclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types FTStack Functions peek stackFromObject stackClassName Subroutines initFTStack releaseFTStack push pop printStackDescription Derived Types type, public, extends( FTLinkedList ) :: FTStack Components Type Visibility Attributes Name Initial class( FTLinkedListRecord ), public, POINTER :: head => NULL() class( FTLinkedListRecord ), public, POINTER :: tail => NULL() integer, public :: nRecords logical, public :: isCircular_ Type-Bound Procedures procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: add Subroutine procedure\n                    ,                  public\n,                   :: remove => removeObject Subroutine procedure\n                    ,                  public\n,                   :: reverse => reverseLinkedList Subroutine procedure\n                    ,                  public\n,                   :: removeRecord => removeLinkedListRecord Subroutine procedure\n                    ,                  public\n,                   :: count => numberOfRecords Function procedure\n                    ,                  public\n,                   :: description => FTLinkedListDescription Function procedure\n                    ,                  public\n,                   :: allObjects => allLinkedListObjects Function procedure\n                    ,                  public\n,                   :: removeAllObjects => removeAllLinkedListObjects Subroutine procedure\n                    ,                  public\n,                   :: addObjectsFromList Subroutine procedure\n                    ,                  public\n,                   :: makeCircular Subroutine procedure\n                    ,                  public\n,                   :: isCircular Function procedure\n                    ,                  public\n,                   :: insertObjectAfterRecord Subroutine procedure\n                    ,                  public\n,                   :: insertObjectAfterObject Subroutine procedure\n                    ,                  public\n,                   :: init => initFTStack Subroutine procedure\n                    ,                  public\n,                   :: printDescription => printStackDescription Subroutine procedure\n                    ,                  public\n,                   :: className => stackClassName Function procedure\n                    ,                  public\n,                   :: push Subroutine procedure\n                    ,                  public\n,                   :: pop Subroutine procedure\n                    ,                  public\n,                   :: peek Function Functions public  function peek (self) Arguments Type Intent Optional Attributes Name class( FTStack ) :: self Return Value class( FTObject ), POINTER public  function stackFromObject (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTStack ), POINTER public  function stackClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTStack ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Subroutines public  subroutine initFTStack (self) Public, generic name: init() Read more… Arguments Type Intent Optional Attributes Name class( FTStack ) :: self public  subroutine releaseFTStack (self) Arguments Type Intent Optional Attributes Name type( FTStack ), POINTER :: self public  subroutine push (self, obj) Arguments Type Intent Optional Attributes Name class( FTStack ) :: self class( FTObject ), POINTER :: obj public  subroutine pop (self, p) Arguments Type Intent Optional Attributes Name class( FTStack ) :: self class( FTObject ), POINTER :: p public  subroutine printStackDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTStack ) :: self integer :: iUnit","tags":"","loc":"module/ftstackclass.html"},{"title":"FTMultiIndexTableData – FTObjectLibrary","text":"Uses FTObjectClass module~~ftmultiindextabledata~~UsesGraph module~ftmultiindextabledata FTMultiIndexTableData module~ftobjectclass FTObjectClass module~ftmultiindextabledata->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftmultiindextabledata~~UsedByGraph module~ftmultiindextabledata FTMultiIndexTableData module~ftmultiindextableclass FTMultiIndexTableClass module~ftmultiindextableclass->module~ftmultiindextabledata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces cast Derived Types MultiIndexMatrixData Functions MultiIndexMatrixDataCast Subroutines initWithObjectAndKeys releaseFTMultiIndexMatrixData destructMultiIndexMatrixData castObjectToMultiIndexMatrixData Interfaces public        interface cast public  subroutine castObjectToMultiIndexMatrixData (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( MultiIndexMatrixData ), POINTER :: cast Derived Types type, public, extends( FTObject ) :: MultiIndexMatrixData Components Type Visibility Attributes Name Initial integer, public, ALLOCATABLE :: key (:) class( FTObject ), public, POINTER :: object Finalizations Procedures final :: destructMultiIndexMatrixData Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTObjectDescription Subroutine procedure\n                    ,                  public\n,                   :: className Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: initWithObjectAndKeys Subroutine Functions public  function MultiIndexMatrixDataCast (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( MultiIndexMatrixData ), POINTER Subroutines public  subroutine initWithObjectAndKeys (self, object, key) Arguments Type Intent Optional Attributes Name class( MultiIndexMatrixData ) :: self class( FTObject ), POINTER :: object integer :: key (:) public  subroutine releaseFTMultiIndexMatrixData (self) Arguments Type Intent Optional Attributes Name type( MultiIndexMatrixData ), POINTER :: self public  subroutine destructMultiIndexMatrixData (self) Arguments Type Intent Optional Attributes Name type( MultiIndexMatrixData ) :: self public  subroutine castObjectToMultiIndexMatrixData (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( MultiIndexMatrixData ), POINTER :: cast","tags":"","loc":"module/ftmultiindextabledata.html"},{"title":"FTMultiIndexTableClass – FTObjectLibrary","text":"The MultiIndexTable stores an FTObject pointer associated\nwith any number of integer keys(:) as a hash table. Usage Definition (Subclass of FTObject) TYPE(FTMultiIndexTable) :: multiIndexTable Initialization CALL MultiIndexTable % initWithSize(N) The size, N = the maximum value of all of the keys. Destruction CALL releaseFTMultiIndexTable ( MultiIndexTable ) [ Pointers ] Adding an object CLASS(FTObject), POINTER :: obj\n     INTEGER, DIMENSION(dim)  :: keys\n     CALL MultiIndexTable % addObjectForKeys(obj,keys) Retrieving an object CLASS(FTObject), POINTER :: obj\n     INTEGER, DIMENSION(dim)  :: keys\n     obj => MultiIndexTable % objectForKeys(keys) Be sure to retain the object if you want it to live\n      beyond the life of the table. Testing the presence of keys LOGICAL :: exists\n     exists = MultiIndexTable % containsKeys(keys) Uses FTObjectClass FTLinkedListClass FTMultiIndexTableData module~~ftmultiindextableclass~~UsesGraph module~ftmultiindextableclass FTMultiIndexTableClass module~ftlinkedlistclass FTLinkedListClass module~ftmultiindextableclass->module~ftlinkedlistclass module~ftmultiindextabledata FTMultiIndexTableData module~ftmultiindextableclass->module~ftmultiindextabledata module~ftobjectclass FTObjectClass module~ftmultiindextableclass->module~ftobjectclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftmultiindextabledata->module~ftobjectclass module~ftlinkedlistrecordclass->module~ftobjectclass module~ftmutableobjectarrayclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types FTMultiIndexTable Functions objectInMultiIndexTableForKeys MultiIndexTableContainsKeys MultiIndexTableSize MultiIndexTableFromObject keysMatch Subroutines initMultiIndexTableWithSize releaseFTMultiIndexTable destructMultiIndexTable addObjectToMultiIndexTableForKeys sortKeysAscending printMultiIndexTableDescription Derived Types type, public, extends( FTObject ) :: FTMultiIndexTable Components Type Visibility Attributes Name Initial class( FTLinkedList ), public, DIMENSION(:), ALLOCATABLE :: table Finalizations Procedures final :: destructMultiIndexTable Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n,                   :: className Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: initWithSize => initMultiIndexTableWithSize Subroutine procedure\n                    ,                  public\n,                   :: containsKeys => MultiIndexTableContainsKeys Function procedure\n                    ,                  public\n,                   :: addObjectForKeys => addObjectToMultiIndexTableForKeys Subroutine procedure\n                    ,                  public\n,                   :: objectForKeys => objectInMultiIndexTableForKeys Function procedure\n                    ,                  public\n,                   :: printDescription => printMultiIndexTableDescription Subroutine procedure\n                    ,                  public\n,                   :: MultiIndexTableSize Function Functions public  function objectInMultiIndexTableForKeys (self, keys) result(r) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: keys (:) Return Value class( FTObject ), POINTER public  function MultiIndexTableContainsKeys (self, keys) result(r) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: keys (:) Return Value logical public  function MultiIndexTableSize (self) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self Return Value integer public  function MultiIndexTableFromObject (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTMultiIndexTable ), POINTER public  function keysMatch (key1, key2) Arguments Type Intent Optional Attributes Name integer, DIMENSION(:) :: key1 integer, DIMENSION(:) :: key2 Return Value logical Subroutines public  subroutine initMultiIndexTableWithSize (self, N) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: N public  subroutine releaseFTMultiIndexTable (self) Arguments Type Intent Optional Attributes Name type( FTMultiIndexTable ), POINTER :: self public  subroutine destructMultiIndexTable (self) Arguments Type Intent Optional Attributes Name type( FTMultiIndexTable ) :: self public  subroutine addObjectToMultiIndexTableForKeys (self, obj, keys) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self class( FTObject ), POINTER :: obj integer :: keys (:) public  subroutine sortKeysAscending (keys) Arguments Type Intent Optional Attributes Name integer, DIMENSION(:) :: keys public  subroutine printMultiIndexTableDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTMultiIndexTable ) :: self integer :: iUnit","tags":"","loc":"module/ftmultiindextableclass.html"},{"title":"FTDataClass – FTObjectLibrary","text":"FTData defines a subclass of FTObject to contain immutable\ngeneric data, including derived types. The initializer\ncopies the data and takes ownership of that copy. FTData\ngives a way to use derived types without having to subclass\nFTObject. Uses FTObjectClass module~~ftdataclass~~UsesGraph module~ftdataclass FTDataClass module~ftobjectclass FTObjectClass module~ftdataclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables DATA_CLASS_TYPE_LENGTH Derived Types FTData Functions storedData storedDataSize dataType dataFromObject dataClassName dataIsOfType Subroutines initWithDataOfType destructData releaseFTData Variables Type Visibility Attributes Name Initial integer, public, parameter :: DATA_CLASS_TYPE_LENGTH = 32 Derived Types type, public, extends( FTObject ) :: FTData Finalizations Procedures final :: destructData Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTObjectDescription Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n                  :: initWithDataOfType Subroutine procedure\n                    ,                  public\n                  :: storedData Function procedure\n                    ,                  public\n                  :: storedDataSize Function procedure\n                    ,                  public\n                  :: className => dataClassName Function Functions public  function storedData (self) result(d) Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value character(len=1), POINTER, (:) public  function storedDataSize (self) Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value integer public  function dataType (self) result(t) Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value character(len=DATA_CLASS_TYPE_LENGTH) public  function dataFromObject (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTData ), POINTER public  function dataClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTData ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) public  function dataIsOfType (self, dataType) result(t) Arguments Type Intent Optional Attributes Name class( FTData ) :: self character(len=DATA_CLASS_TYPE_LENGTH) :: dataType Return Value logical Subroutines public  subroutine initWithDataOfType (self, genericData, dataType) Arguments Type Intent Optional Attributes Name class( FTData ) :: self character(len=1) :: genericData (:) character(len=*) :: dataType public  subroutine destructData (self) Arguments Type Intent Optional Attributes Name type( FTData ) :: self public  subroutine releaseFTData (self) Arguments Type Intent Optional Attributes Name type( FTData ), POINTER :: self","tags":"","loc":"module/ftdataclass.html"},{"title":"FTLinkedListRecordClass – FTObjectLibrary","text":"FTLinkedListRecord is the record type (object and next) for the\nLinkedList class. One will generally not instantiate a record oneself. They are \ncreated automatically when one adds an object to a linked list. Uses FTObjectClass module~~ftlinkedlistrecordclass~~UsesGraph module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftobjectclass FTObjectClass module~ftlinkedlistrecordclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftlinkedlistrecordclass~~UsedByGraph module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass FTLinkedListClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftdictionaryclass FTDictionaryClass module~ftdictionaryclass->module~ftlinkedlistclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftmultiindextableclass FTMultiIndexTableClass module~ftmultiindextableclass->module~ftlinkedlistclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftlinkedlistclass module~ftobjectlibrary->module~ftdictionaryclass module~ftobjectlibrary->module~ftlinkedlistiteratorclass module~ftsparsematrixclass FTSparseMatrixClass module~ftobjectlibrary->module~ftsparsematrixclass module~ftstackclass FTStackClass module~ftobjectlibrary->module~ftstackclass module~ftexceptionclass FTExceptionClass module~ftobjectlibrary->module~ftexceptionclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftsparsematrixclass->module~ftlinkedlistclass module~ftsparsematrixclass->module~ftlinkedlistiteratorclass module~ftstackclass->module~ftlinkedlistclass module~ftexceptionclass->module~ftdictionaryclass module~ftexceptionclass->module~ftlinkedlistiteratorclass module~ftexceptionclass->module~ftstackclass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftstringsetclass FTStringSetClass module~ftstringsetclass->module~ftdictionaryclass module~ftvaluedictionaryclass->module~ftdictionaryclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types FTLinkedListRecord Functions llRecordClassName Subroutines initWithObject destructFTLinkedListRecord releaseFTLinkedListRecord printFTLinkedRecordDescription Derived Types type, public, extends( FTObject ) :: FTLinkedListRecord Components Type Visibility Attributes Name Initial class( FTObject ), public, POINTER :: recordObject => NULL() class( FTLinkedListRecord ), public, POINTER :: next => NULL() class( FTLinkedListRecord ), public, POINTER :: previous => NULL() Finalizations Procedures final :: destructFTLinkedListRecord Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: initWithObject Subroutine procedure\n                    ,                  public\n,                   :: printDescription => printFTLinkedRecordDescription Subroutine procedure\n                    ,                  public\n,                   :: className => llRecordClassName Function Functions public  function llRecordClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTLinkedListRecord ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Subroutines public  subroutine initWithObject (self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedListRecord ) :: self class( FTObject ), POINTER :: obj public  subroutine destructFTLinkedListRecord (self) Arguments Type Intent Optional Attributes Name type( FTLinkedListRecord ) :: self public  subroutine releaseFTLinkedListRecord (self) Arguments Type Intent Optional Attributes Name type( FTLinkedListRecord ), POINTER :: self public recursive subroutine printFTLinkedRecordDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTLinkedListRecord ) :: self integer :: iUnit","tags":"","loc":"module/ftlinkedlistrecordclass.html"},{"title":"FTLinkedListClass – FTObjectLibrary","text":"FTLinkedList is a container class that stores objects in a linked list. Inherits from FTObjectClass Definition (Subclass of FTObject): TYPE(FTLinkedList) :: list Usage: Initialization CLASS(FTLinkedList), POINTER :: list\n     ALLOCATE(list)\n     CALL list % init Adding objects CLASS ( FTLinkedList ) , POINTER :: list , listToAdd CLASS ( FTObject ) , POINTER :: objectPtr objectPtr => r ! r is subclass of FTObject CALL list % Add ( objectPtr ) ! Pointer is retained by list CALL release ( r ) ! If caller relinquishes ownership CALL list % addObjectsFromList ( listToAdd ) Inserting objects CLASS ( FTLinkedList ) , POINTER :: list CLASS ( FTObject ) , POINTER :: objectPtr , obj CLASS ( FTLinkedListRecord ) , POINTER :: record objectPtr => r ! r is subclass of FTObject CALL list % insertObjectAfterRecord ( objectPtr , record ) ! Pointer is retained by list CALL release ( r ) ! If caller reliquishes ownership objectPtr => r ! r is subclass of FTObject CALL list % insertObjectAfterObject ( objectPtr , obj ) ! Pointer is retained by list CALL release ( r ) ! If caller reliquishes ownership Removing objects CLASS(FTLinkedList), POINTER :: list\n     CLASS(FTObject)    , POINTER :: objectPtr\n     objectPtr => r                 ! r is subclass of FTObject\n     CALL list % remove(objectPtr) Getting all objects as an object array CLASS(FTLinkedList)        , POINTER :: list\n     CLASS(FTMutableObjectArray), POINTER :: array\n     array => list % allObjects() ! Array has refCount = 1 Counting the number of objects in the list n = list % count() Destruction CALL releaseFTLinkedList ( list ) [ Pointers ] ! Uses FTLinkedListRecordClass FTMutableObjectArrayClass module~~ftlinkedlistclass~~UsesGraph module~ftlinkedlistclass FTLinkedListClass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftobjectclass FTObjectClass module~ftlinkedlistrecordclass->module~ftobjectclass module~ftmutableobjectarrayclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftlinkedlistclass~~UsedByGraph module~ftlinkedlistclass FTLinkedListClass module~ftdictionaryclass FTDictionaryClass module~ftdictionaryclass->module~ftlinkedlistclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftmultiindextableclass FTMultiIndexTableClass module~ftmultiindextableclass->module~ftlinkedlistclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftlinkedlistclass module~ftobjectlibrary->module~ftdictionaryclass module~ftobjectlibrary->module~ftlinkedlistiteratorclass module~ftsparsematrixclass FTSparseMatrixClass module~ftobjectlibrary->module~ftsparsematrixclass module~ftstackclass FTStackClass module~ftobjectlibrary->module~ftstackclass module~ftexceptionclass FTExceptionClass module~ftobjectlibrary->module~ftexceptionclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftsparsematrixclass->module~ftlinkedlistclass module~ftsparsematrixclass->module~ftlinkedlistiteratorclass module~ftstackclass->module~ftlinkedlistclass module~ftexceptionclass->module~ftdictionaryclass module~ftexceptionclass->module~ftlinkedlistiteratorclass module~ftexceptionclass->module~ftstackclass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftstringsetclass FTStringSetClass module~ftstringsetclass->module~ftdictionaryclass module~ftvaluedictionaryclass->module~ftdictionaryclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces cast Derived Types FTLinkedList Functions isCircular numberOfRecords FTLinkedListDescription allLinkedListObjects linkedListClassName linkedListFromObject Subroutines initFTLinkedList add addObjectsFromList insertObjectAfterRecord insertObjectAfterObject makeCircular removeObject1 removeObject removeLinkedListRecord removeAllLinkedListObjects releaseFTLinkedList destructFTLinkedList printFTLinkedListDescription reverseLinkedList castObjectToLinkedList Interfaces public        interface cast public  subroutine castObjectToLinkedList (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTLinkedList ), POINTER :: cast Derived Types type, public, extends( FTObject ) :: FTLinkedList Components Type Visibility Attributes Name Initial class( FTLinkedListRecord ), public, POINTER :: head => NULL() class( FTLinkedListRecord ), public, POINTER :: tail => NULL() integer, public :: nRecords logical, public :: isCircular_ Finalizations Procedures final :: destructFTLinkedList Type-Bound Procedures procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: init => initFTLinkedList Subroutine procedure\n                    ,                  public\n,                   :: add Subroutine procedure\n                    ,                  public\n,                   :: remove => removeObject Subroutine procedure\n                    ,                  public\n,                   :: reverse => reverseLinkedList Subroutine procedure\n                    ,                  public\n,                   :: removeRecord => removeLinkedListRecord Subroutine procedure\n                    ,                  public\n,                   :: count => numberOfRecords Function procedure\n                    ,                  public\n,                   :: description => FTLinkedListDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTLinkedListDescription Subroutine procedure\n                    ,                  public\n,                   :: className => linkedListClassName Function procedure\n                    ,                  public\n,                   :: allObjects => allLinkedListObjects Function procedure\n                    ,                  public\n,                   :: removeAllObjects => removeAllLinkedListObjects Subroutine procedure\n                    ,                  public\n,                   :: addObjectsFromList Subroutine procedure\n                    ,                  public\n,                   :: makeCircular Subroutine procedure\n                    ,                  public\n,                   :: isCircular Function procedure\n                    ,                  public\n,                   :: insertObjectAfterRecord Subroutine procedure\n                    ,                  public\n,                   :: insertObjectAfterObject Subroutine Functions public  function isCircular (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value logical public  function numberOfRecords (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value integer public  function FTLinkedListDescription (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) public  function allLinkedListObjects (self) result(array) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value class( FTMutableObjectArray ), POINTER public  function linkedListClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) public  function linkedListFromObject (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTLinkedList ), POINTER Subroutines public  subroutine initFTLinkedList (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self public  subroutine add (self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj public  subroutine addObjectsFromList (self, list) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTLinkedList ), POINTER :: list public  subroutine insertObjectAfterRecord (self, obj, after) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj class( FTLinkedListRecord ), POINTER :: after public  subroutine insertObjectAfterObject (self, obj, after) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj class( FTObject ), POINTER :: after public  subroutine makeCircular (self, circular) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self logical :: circular public  subroutine removeObject1 (self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj public  subroutine removeObject (self, obj) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTObject ), POINTER :: obj public  subroutine removeLinkedListRecord (self, listRecord) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self class( FTLinkedListRecord ), POINTER :: listRecord public  subroutine removeAllLinkedListObjects (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self public  subroutine releaseFTLinkedList (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ), POINTER :: self public  subroutine destructFTLinkedList (self) It is automatically called by release(). Arguments Type Intent Optional Attributes Name type( FTLinkedList ) :: self public recursive subroutine printFTLinkedListDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self integer :: iUnit public  subroutine reverseLinkedList (self) Arguments Type Intent Optional Attributes Name class( FTLinkedList ) :: self public  subroutine castObjectToLinkedList (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTLinkedList ), POINTER :: cast","tags":"","loc":"module/ftlinkedlistclass.html"},{"title":"FTLinkedListIteratorClass – FTObjectLibrary","text":"An object for stepping through a linked list. Definition (Subclass of FTObject): TYPE(FTLinkedListIterator) :: list Initialization CLASS(FTLinkedList)        , POINTER :: list\n     CLASS(FTLinkedListIterator), POINTER :: iterator\n     ALLOCATE(iterator)\n     CALL iterator % initWithFTLinkedList(list) Accessors ptr => iterator % list()\n     ptr => iterator % object()\n     ptr => iterator % currentRecord() Iterating CLASS ( FTObject ), POINTER :: objectPtr CALL iterator % setToStart DO WHILE (. NOT . iterator % isAtEnd ()) objectPtr => iterator % object () ! if the object is wanted recordPtr => iterator % currentRecord () ! if the record is wanted Do something with object or record CALL iterator % moveToNext () ! DON ' T FORGET THIS !! END DO Destruction CALL releaseFTLinkedListIterator ( iterator ) [ Pointers ] Uses FTLinkedListClass module~~ftlinkedlistiteratorclass~~UsesGraph module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftlinkedlistclass FTLinkedListClass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftobjectclass FTObjectClass module~ftlinkedlistrecordclass->module~ftobjectclass module~ftmutableobjectarrayclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftlinkedlistiteratorclass~~UsedByGraph module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftdictionaryclass FTDictionaryClass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftexceptionclass FTExceptionClass module~ftexceptionclass->module~ftlinkedlistiteratorclass module~ftexceptionclass->module~ftdictionaryclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftlinkedlistiteratorclass module~ftobjectlibrary->module~ftdictionaryclass module~ftobjectlibrary->module~ftexceptionclass module~ftsparsematrixclass FTSparseMatrixClass module~ftobjectlibrary->module~ftsparsematrixclass module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftsparsematrixclass->module~ftlinkedlistiteratorclass module~ftstringsetclass FTStringSetClass module~ftstringsetclass->module~ftdictionaryclass module~ftvaluedictionaryclass->module~ftdictionaryclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types FTLinkedListIterator Functions FTLinkedListIsAtEnd returnLinkedList FTLinkedListObject FTLinkedListCurrentRecord linkedListIteratorClassName Subroutines initEmpty initWithFTLinkedList releaseFTLinkedListIterator destructIterator releaseMemberList setToStart moveToNext setLinkedList removeCurrentRecord Derived Types type, public, extends( FTObject ) :: FTLinkedListIterator Components Type Visibility Attributes Name Initial class( FTLinkedList ), public, POINTER :: list => NULL() class( FTLinkedListRecord ), public, POINTER :: current => NULL() Finalizations Procedures final :: destructIterator Type-Bound Procedures procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTObjectDescription Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: init => initEmpty Subroutine procedure\n                    ,                  public\n,                   :: initWithFTLinkedList Subroutine procedure\n                    ,                  public\n,                   :: isAtEnd => FTLinkedListIsAtEnd Function procedure\n                    ,                  public\n,                   :: object => FTLinkedListObject Function procedure\n                    ,                  public\n,                   :: currentRecord => FTLinkedListCurrentRecord Function procedure\n                    ,                  public\n,                   :: linkedList => returnLinkedList Function procedure\n                    ,                  public\n,                   :: className => linkedListIteratorClassName Function procedure\n                    ,                  public\n,                   :: setLinkedList Subroutine procedure\n                    ,                  public\n,                   :: setToStart Subroutine procedure\n                    ,                  public\n,                   :: moveToNext Subroutine procedure\n                    ,                  public\n,                   :: removeCurrentRecord Subroutine Functions public  function FTLinkedListIsAtEnd (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value logical public  function returnLinkedList (self) result(o) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value class( FTLinkedList ), POINTER public  function FTLinkedListObject (self) result(o) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value class( FTObject ), POINTER public  function FTLinkedListCurrentRecord (self) result(o) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value class( FTLinkedListRecord ), POINTER public  function linkedListIteratorClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Subroutines public  subroutine initEmpty (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self public  subroutine initWithFTLinkedList (self, list) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self class( FTLinkedList ), POINTER :: list public  subroutine releaseFTLinkedListIterator (self) Arguments Type Intent Optional Attributes Name type( FTLinkedListIterator ), POINTER :: self public  subroutine destructIterator (self) Arguments Type Intent Optional Attributes Name type( FTLinkedListIterator ) :: self public  subroutine releaseMemberList (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self public  subroutine setToStart (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self public  subroutine moveToNext (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self public  subroutine setLinkedList (self, list) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self class( FTLinkedList ), POINTER :: list public  subroutine removeCurrentRecord (self) Arguments Type Intent Optional Attributes Name class( FTLinkedListIterator ) :: self","tags":"","loc":"module/ftlinkedlistiteratorclass.html"},{"title":"FTExceptionClass – FTObjectLibrary","text":"An FTException object gives a way to pass generic\ninformation about an exceptional situation. An FTException object gives a way to pass generic\ninformation about an exceptional situation. Methods for\ndealing with exceptions are defined in the SharedExceptionManagerModule\nmodule. An FTException object wraps: A severity indicator A name for the exception An optional dictionary that contains whatever information is deemed necessary. It is expected that classes will define exceptions that use instances\nof the FTException Class. Defined constants: FT_ERROR_NONE    = 0 FT_ERROR_WARNING = 1 FT_ERROR_FATAL   = 2 Initialization CALL e  %  initFTException(severity,exceptionName,infoDictionary) Plus the convenience initializers, which automatically create a FTValueDictionary with a single key called \"message\": CALL e % initWarningException(msg = \"message\")\n    CALL e % initFatalException(msg = \"message\") Plus an assertion exception CALL e % initAssertionFailureException(msg,expectedValueObject,observedValueObject,level) Destruction CALL releaseFTException ( e ) [ pointers ] Setting the infoDictionary CALL e  %  setInfoDictionary(infoDictionary) Getting the infoDictionary dict => e % infoDictionary Getting the name of the exception name = e % exceptionName() Getting the severity level of the exception level = e % severity() Severity levels are FT_ERROR_WARNING or FT_ERROR_FATAL Printing the exception CALL e % printDescription() Uses FTLinkedListIteratorClass FTDictionaryClass FTStackClass FTValueDictionaryClass module~~ftexceptionclass~~UsesGraph module~ftexceptionclass FTExceptionClass module~ftdictionaryclass FTDictionaryClass module~ftexceptionclass->module~ftdictionaryclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftexceptionclass->module~ftlinkedlistiteratorclass module~ftstackclass FTStackClass module~ftexceptionclass->module~ftstackclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftkeyobjectpairclass FTKeyObjectPairClass module~ftdictionaryclass->module~ftkeyobjectpairclass module~ftlinkedlistclass FTLinkedListClass module~ftdictionaryclass->module~ftlinkedlistclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftdictionaryclass->module~ftmutableobjectarrayclass module~hashmodule HashModule module~ftdictionaryclass->module~hashmodule module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftstackclass->module~ftlinkedlistclass module~ftvaluedictionaryclass->module~ftdictionaryclass iso_fortran_env iso_fortran_env module~ftvaluedictionaryclass->iso_fortran_env module~ftvalueclass FTValueClass module~ftvaluedictionaryclass->module~ftvalueclass module~ftobjectclass FTObjectClass module~ftkeyobjectpairclass->module~ftobjectclass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftmutableobjectarrayclass->module~ftobjectclass module~ftvalueclass->iso_fortran_env ieee_arithmetic ieee_arithmetic module~ftvalueclass->ieee_arithmetic module~ftvalueclass->module~ftobjectclass module~ftolconstants FTOLConstants module~ftvalueclass->module~ftolconstants module~ftlinkedlistrecordclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftexceptionclass~~UsedByGraph module~ftexceptionclass FTExceptionClass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftexceptionclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables FT_ERROR_NONE FT_ERROR_WARNING FT_ERROR_FATAL ERROR_MSG_STRING_LENGTH FTFatalErrorException FTWarningErrorException FTAssertionFailureException Interfaces cast Derived Types FTException Functions infoDictionary exceptionName severity exceptionFromObject exceptionClassName Subroutines initWarningException initFatalException initFTException initAssertionFailureException releaseFTException destructException setInfoDictionary releaseMemberDictionary printFTExceptionDescription castToException Variables Type Visibility Attributes Name Initial integer, public, parameter :: FT_ERROR_NONE = 0 integer, public, parameter :: FT_ERROR_WARNING = 1 integer, public, parameter :: FT_ERROR_FATAL = 2 integer, public, parameter :: ERROR_MSG_STRING_LENGTH = 132 character(len=21), public, parameter :: FTFatalErrorException = \"FTFatalErrorException\" character(len=23), public, parameter :: FTWarningErrorException = \"FTWarningErrorException\" character(len=27), public, parameter :: FTAssertionFailureException = \"FTAssertionFailureException\" Interfaces public        interface cast public  subroutine castToException (obj, cast) Cast the base class FTObject to the FTException class Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTException ), POINTER :: cast Derived Types type, public, extends( FTObject ) :: FTException Finalizations Procedures final :: destructException Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: initFTException Subroutine procedure\n                    ,                  public\n,                   :: initWarningException Subroutine procedure\n                    ,                  public\n,                   :: initFatalException Subroutine procedure\n                    ,                  public\n,                   :: initAssertionFailureException Subroutine procedure\n                    ,                  public\n,                   :: setInfoDictionary Subroutine procedure\n                    ,                  public\n,                   :: infoDictionary Function procedure\n                    ,                  public\n,                   :: exceptionName Function procedure\n                    ,                  public\n,                   :: severity Function procedure\n                    ,                  public\n,                   :: printDescription => printFTExceptionDescription Subroutine procedure\n                    ,                  public\n,                   :: className => exceptionClassName Function Functions public  function infoDictionary (self) Returns the exception's infoDictionary. Does\nnot transfer ownership/reference count is \nunchanged. Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value class( FTDictionary ), POINTER public  function exceptionName (self) Returns the string representing the name set\nfor the exception. Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value character(len=ERROR_MSG_STRING_LENGTH) public  function severity (self) Returns the severity level of the exception. Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value integer public  function exceptionFromObject (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTException ), POINTER public  function exceptionClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTException ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Subroutines public  subroutine initWarningException (self, msg) A convenience initializer for a warning error \nthat includes the key \"message\" in the\ninfoDictionary. Use this initializer as an \nexample of how to write one's own exception. Arguments Type Intent Optional Attributes Name class( FTException ) :: self character(len=*) :: msg public  subroutine initFatalException (self, msg) A convenience initializer for a fatal error \nthat includes the key \"message\" in the\ninfoDictionary.Use this initializer as an \nexample of how to write one's own exception. Arguments Type Intent Optional Attributes Name class( FTException ) :: self character(len=*) :: msg public  subroutine initFTException (self, severity, exceptionName, infoDictionary) The main initializer for the class Arguments Type Intent Optional Attributes Name class( FTException ) :: self integer :: severity character(len=*) :: exceptionName class( FTDictionary ), optional, POINTER :: infoDictionary public  subroutine initAssertionFailureException (self, msg, expectedValueObject, ObservedValueObject, level) A convenience initializer for an assertion error \nthat includes the keys: Read more… Arguments Type Intent Optional Attributes Name class( FTException ) :: self character(len=*) :: msg class( FTValue ), POINTER :: expectedValueObject class( FTValue ), POINTER :: ObservedValueObject integer :: level public  subroutine releaseFTException (self) Arguments Type Intent Optional Attributes Name type( FTException ), POINTER :: self public  subroutine destructException (self) The destructor for the class. Do not call this direectly. Call\nthe release() procedure instead Arguments Type Intent Optional Attributes Name type( FTException ) :: self public  subroutine setInfoDictionary (self, dict) Sets and retains the exception infoDictionary Arguments Type Intent Optional Attributes Name class( FTException ) :: self class( FTDictionary ), POINTER :: dict public  subroutine releaseMemberDictionary (self) Arguments Type Intent Optional Attributes Name class( FTException ) :: self public  subroutine printFTExceptionDescription (self, iUnit) A basic printing of the exception and the info\nheld in the infoDicitonary. Arguments Type Intent Optional Attributes Name class( FTException ) :: self integer :: iUnit public  subroutine castToException (obj, cast) Cast the base class FTObject to the FTException class Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTException ), POINTER :: cast","tags":"","loc":"module/ftexceptionclass.html"},{"title":"SharedExceptionManagerModule – FTObjectLibrary","text":"All exceptions are posted to the SharedExceptionManagerModule. To use exceptions,first initialize it\n        CALL initializeFTExceptions\nFrom that point on, all exceptions will be posted there. Note that the\nFTTestSuiteManager class will initialize the SharedExceptionManagerModule,\nso there is no need to do the initialization separately if the FTTestSuiteManager\nclass has been initialized. The exceptions are posted to a stack. To access the exceptions they will be\npeeked or popped from that stack. Initialization CALL initializeFTExceptions Finalization CALL destructFTExceptions Throwing an exception CALL throw(exception) Getting the number of exceptions n = errorCount() Getting the maximum exception severity s = maximumErrorSeverity() Catching all exceptions IF ( catch ()) THEN Do something with the exceptions END IF Getting the named exception caught CLASS(FTException), POINTER :: e\n     e => errorObject() Popping the top exception e => popLastException() Peeking the top exception e => peekLastException() Catching an exception with a given name IF ( catch ( name )) THEN ! Do something with the exception , e . g . e => errorObject () d => e % infoDictionary () userDictionary => valueDictionaryFromDictionary ( dict = d ) msg = userDictionary % stringValueForKey ( \"message\" , FTDICT_KWD_STRING_LENGTH ) END IF Printing all exceptions call printAllExceptions Uses FTExceptionClass module~~sharedexceptionmanagermodule~~UsesGraph module~sharedexceptionmanagermodule SharedExceptionManagerModule module~ftexceptionclass FTExceptionClass module~sharedexceptionmanagermodule->module~ftexceptionclass module~ftdictionaryclass FTDictionaryClass module~ftexceptionclass->module~ftdictionaryclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftexceptionclass->module~ftlinkedlistiteratorclass module~ftstackclass FTStackClass module~ftexceptionclass->module~ftstackclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftkeyobjectpairclass FTKeyObjectPairClass module~ftdictionaryclass->module~ftkeyobjectpairclass module~ftlinkedlistclass FTLinkedListClass module~ftdictionaryclass->module~ftlinkedlistclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftdictionaryclass->module~ftmutableobjectarrayclass module~hashmodule HashModule module~ftdictionaryclass->module~hashmodule module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftstackclass->module~ftlinkedlistclass module~ftvaluedictionaryclass->module~ftdictionaryclass iso_fortran_env iso_fortran_env module~ftvaluedictionaryclass->iso_fortran_env module~ftvalueclass FTValueClass module~ftvaluedictionaryclass->module~ftvalueclass module~ftobjectclass FTObjectClass module~ftkeyobjectpairclass->module~ftobjectclass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftmutableobjectarrayclass->module~ftobjectclass module~ftvalueclass->iso_fortran_env ieee_arithmetic ieee_arithmetic module~ftvalueclass->ieee_arithmetic module~ftvalueclass->module~ftobjectclass module~ftolconstants FTOLConstants module~ftvalueclass->module~ftolconstants module~ftlinkedlistrecordclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces catch Functions errorCount maximumErrorSeverity errorObject popLastException peekLastException Subroutines initializeFTExceptions destructFTExceptions throw setCurrentError printAllExceptions releaseCurrentError Interfaces public        interface catch private  function catchAll() Returns .TRUE. if there are any exceptions. Arguments None Return Value logical private  function catchErrorWithName(exceptionName) Returns .TRUE. if there is an exception with\nthe requested name. If so, it pops the \nexception and saves the pointer to it so that\nit can be accessed with the currentError()\nfunction. Arguments Type Intent Optional Attributes Name character(len=*) :: exceptionName Return Value logical Functions public  function errorCount () Returns the number of exceptions that have \nbeen thrown. Arguments None Return Value integer public  function maximumErrorSeverity () Returns the maxSeverity of exceptions that have \nbeen thrown. Arguments None Return Value integer public  function errorObject () Returns a pointer to the current exception. Arguments None Return Value class( FTException ), POINTER public  function popLastException () Get the last exception posted. This is popped from the stack.\nThe caller is responsible for releasing the object after popping Arguments None Return Value class( FTException ), POINTER public  function peekLastException () Get the last exception posted. This is NOT popped from the stack.\nThe caller does not own the object. Arguments None Return Value class( FTException ), POINTER Subroutines public  subroutine initializeFTExceptions () Called at start of execution. Will be called automatically if an \nexception is thrown. Arguments None public  subroutine destructFTExceptions () Called at the end of execution. This procedure will announce if there\nare uncaught exceptions raised and print them. Arguments None public  subroutine throw (exceptionToThrow) Throws the exception: exceptionToThrow Arguments Type Intent Optional Attributes Name type( FTException ), POINTER :: exceptionToThrow public  subroutine setCurrentError (e) Arguments Type Intent Optional Attributes Name class( FTException ), POINTER :: e public  subroutine printAllExceptions () Arguments None public  subroutine releaseCurrentError () Arguments None","tags":"","loc":"module/sharedexceptionmanagermodule.html"},{"title":"FTObjectClass – FTObjectLibrary","text":"FTObject is the root class for all object types. Overview FTObject defines the basic methods that are essential for reference counted objects. FTObject is generally not going to be instantiated by itself, but rather it will \nbe subclassed and one will work with instances of the subclasses. \nOtherwise, pointers of type FTObject that point to instances of subclasses\nwill be stored in the container classes. Tasks init() Initializes an object and any memory that it needs to allocate, etc. \n Should be orrerrided in subclasses.The base class implementation does nothing but\n increase the reference count of the object. destruct() Destructor of the object, which releases and deallocates owned objects and memory.\n Should be overrided in subclasses. The base class implementation does nothing but\n decrease the reference count of the object. printDescription(iUnit) Prints a description of the object to a specified file unit. The base class implementation\n does nothing but print \"FTObject\" copy() Creates a copy (pointer) to the object of CLASS(FTObject) sourced with the object. retain() Increases the reference count of the object. Any procedure or object that retain()'s\n an object gains an ownership stake in that object. This procedure is not overridable. release() Decreases the reference count of an object. To be called only by objects or procedures\n that have ownership in an object pointer, i.e., for which init() or retain() have been called.\n Override this procedure in subclasses for releasing the actual type. isUnreferenced() Test to see if there are no more owners of an object. refCount() Returns the number of owners of an object. Usually this is of interest only for debugging purposes.\n This procedure is not overridable. Subclassing FTObject In general, subclasses of FTObject override init() destruct() printDescription() release() They should also provide a cast() subroutine to convert from the base class to a subclass.\nThe cast() routine can look something like SUBROUTINE castToSubclass ( obj , cast ) IMPLICIT NONE CLASS ( FTObject ), POINTER :: obj CLASS ( SubClass ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( SubClass ) cast => e CLASS DEFAULT END SELECT END SUBROUTINE castToSubclass Subclassing init The init() procedure performs subclass specific operations to initialize an object. Subclasses that override init() must include \na call to the super class method. For example, overriding init looks like SUBROUTINE initSubclass ( self ) IMPLICIT NONE CLASS ( Subclass ) :: self CALL self % FTObject % init () Allocate and initialize all member objects ... Other Subclass specific code END SUBROUTINE initSubclass Subclassing destruct The destruct() procedure reverses the operations done in the init() procedure. It releases and\ndeallocates any pointers that it owns.  Subclasses that override destruct() must include \na call to the super class method. For example, overriding destruct looks like SUBROUTINE destructSubclass ( self ) IMPLICIT NONE CLASS ( Subclass ) :: self Release and deallocate ( if necessary ) all member objects END SUBROUTINE destructSubclass Subclassing printDescription(iUnit) printDescription is a method whose existence is to support debugging. Call printDescription(iUnit)\non any objects owned by self for a cascading of what is stored in the object. Casting an object from the base to a subclass Container classes and the copy function return pointers to a CLASS(FTObject). To use\nany subclass features one must \"cast\" to the subclass. We like to have a specific \ncast routine to do this as painlessly as possible. Each subclass should include a \nSUBROUTINE like this: SUBROUTINE castToSubclass ( obj , cast ) IMPLICIT NONE CLASS ( FTObject ), POINTER :: obj CLASS ( Subclass ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( Subclass ) cast => e CLASS DEFAULT END SELECT END SUBROUTINE castToValue Subclassing className The className() procedure returns the name of the class. Subclasses should override className() !> Created: January 7, 2013 11:30 AM \n@author \nDavid A. Kopriva Used by module~~ftobjectclass~~UsedByGraph module~ftobjectclass FTObjectClass module~ftdataclass FTDataClass module~ftdataclass->module~ftobjectclass module~ftkeyobjectpairclass FTKeyObjectPairClass module~ftkeyobjectpairclass->module~ftobjectclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistrecordclass->module~ftobjectclass module~ftmultiindextableclass FTMultiIndexTableClass module~ftmultiindextableclass->module~ftobjectclass module~ftmultiindextabledata FTMultiIndexTableData module~ftmultiindextableclass->module~ftmultiindextabledata module~ftlinkedlistclass FTLinkedListClass module~ftmultiindextableclass->module~ftlinkedlistclass module~ftmultiindextabledata->module~ftobjectclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftmutableobjectarrayclass->module~ftobjectclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftobjectclass module~ftobjectlibrary->module~ftmutableobjectarrayclass module~ftsparsematrixclass FTSparseMatrixClass module~ftobjectlibrary->module~ftsparsematrixclass module~ftvalueclass FTValueClass module~ftobjectlibrary->module~ftvalueclass module~ftdictionaryclass FTDictionaryClass module~ftobjectlibrary->module~ftdictionaryclass module~ftobjectlibrary->module~ftlinkedlistclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftexceptionclass FTExceptionClass module~ftobjectlibrary->module~ftexceptionclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftobjectlibrary->module~ftlinkedlistiteratorclass module~ftstackclass FTStackClass module~ftobjectlibrary->module~ftstackclass module~ftsparsematrixclass->module~ftobjectclass module~ftsparsematrixdata FTSparseMatrixData module~ftsparsematrixclass->module~ftsparsematrixdata module~ftsparsematrixclass->module~ftlinkedlistclass module~ftsparsematrixclass->module~ftlinkedlistiteratorclass module~ftsparsematrixdata->module~ftobjectclass module~ftstringsetclass FTStringSetClass module~ftstringsetclass->module~ftobjectclass module~ftstringsetclass->module~ftdictionaryclass module~ftvalueclass->module~ftobjectclass module~ftdictionaryclass->module~ftkeyobjectpairclass module~ftdictionaryclass->module~ftmutableobjectarrayclass module~ftdictionaryclass->module~ftlinkedlistclass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftvaluedictionaryclass->module~ftvalueclass module~ftvaluedictionaryclass->module~ftdictionaryclass module~ftexceptionclass->module~ftdictionaryclass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftexceptionclass->module~ftlinkedlistiteratorclass module~ftexceptionclass->module~ftstackclass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftstackclass->module~ftlinkedlistclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables DESCRIPTION_CHARACTER_LENGTH CLASS_NAME_CHARACTER_LENGTH Interfaces release Derived Types FTObject Functions className isUnreferenced refCount FTObjectDescription Subroutines initFTObject destructFTObject retainFTObject releaseFTObject printFTObjectDescription Variables Type Visibility Attributes Name Initial integer, public, parameter :: DESCRIPTION_CHARACTER_LENGTH = 1024 integer, public, parameter :: CLASS_NAME_CHARACTER_LENGTH = 32 Interfaces public        interface release public recursive subroutine releaseFTObject (self) releaseFTObject decreases the reference count by one and implies \nrelinquishing ownership by the caller. Call this if control\nover the existence of an object pointer is no longer desired by the caller.\nWhen the reference count goes to zero, the destructor of the object\nis called automatically and the object is deallocated. Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: self Derived Types type, public :: FTObject Finalizations Procedures final :: destructFTObject Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTObjectDescription Subroutine procedure\n                    ,                  public\n,                   :: className Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function Functions public  function className (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) public  function isUnreferenced (self) Owners of objects should call isUnreferenced after releasing a \n pointer object. If true, the object should be deallocated and then\n set to point to NULL() Read more… Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value logical public  function refCount (self) Returns the reference count for the object. Normally this is done\n only for debugging purposes. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value integer public  function FTObjectDescription (self) Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that\n represents the object. the base class implementation returns an empty\n string. Note that if the description is too long, the expected string\n will be trunctated. In general, one wants to use printDescription. Arguments Type Intent Optional Attributes Name class( FTObject ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) Subroutines public  subroutine initFTObject (self) Generic Name: init() Read more… Arguments Type Intent Optional Attributes Name class( FTObject ) :: self public  subroutine destructFTObject (self) Generic Name: destruct() Read more… Arguments Type Intent Optional Attributes Name type( FTObject ) :: self public  subroutine retainFTObject (self) Retain increases the reference count by one and implies ownership\n to the caller.\n ### Usage:\n       CALL obj\\ % retain() Arguments Type Intent Optional Attributes Name class( FTObject ) :: self public recursive subroutine releaseFTObject (self) releaseFTObject decreases the reference count by one and implies \nrelinquishing ownership by the caller. Call this if control\nover the existence of an object pointer is no longer desired by the caller.\nWhen the reference count goes to zero, the destructor of the object\nis called automatically and the object is deallocated. Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: self public  subroutine printFTObjectDescription (self, iUnit) Generic Name: printDescription() Read more… Arguments Type Intent Optional Attributes Name class( FTObject ) :: self integer :: iUnit","tags":"","loc":"module/ftobjectclass.html"},{"title":"FTValueDictionaryClass – FTObjectLibrary","text":"The FTValueDictionary subclass of FTDictionary adds convenient methods\n to easily add fundamental (Real, integer,…) values to a dictionary. As a subclass, all other methods are still available. Usage: Adding a value CALL dict % addValueForKey(1,\"integer\")\n CALL dict % addValueForKey(3.14,\"real\")\n CALL dict % addValueForKey(98.6d0,\"double\")\n CALL dict % addValueForKey(.true.,\"logical\")\n CALL dict % addValueForKey(\"Hello World\",\"string\") Accessing a value i = dict % integerValueForKey(\"integer\")\n r = dict % realValueForKey(\"real\")\n d = dict % doublePrecisionValueForKey(\"double\")\n l = dict % logicalValueForKey(\"logical\")\n s = dict % stringValueForKey(\"string\",15) Converting an FTDictionary to an FTValueDictionary valueDict => valueDictionaryFromDictionary(dict) Converting an FTObject to an FTValueDictionary valueDict => valueDictionaryFromObject(obj) Destruction call releaseFTValueDictionary ( dict ) [ Pointers ] Uses iso_fortran_env FTValueClass FTDictionaryClass module~~ftvaluedictionaryclass~~UsesGraph module~ftvaluedictionaryclass FTValueDictionaryClass iso_fortran_env iso_fortran_env module~ftvaluedictionaryclass->iso_fortran_env module~ftdictionaryclass FTDictionaryClass module~ftvaluedictionaryclass->module~ftdictionaryclass module~ftvalueclass FTValueClass module~ftvaluedictionaryclass->module~ftvalueclass module~ftkeyobjectpairclass FTKeyObjectPairClass module~ftdictionaryclass->module~ftkeyobjectpairclass module~ftlinkedlistclass FTLinkedListClass module~ftdictionaryclass->module~ftlinkedlistclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftdictionaryclass->module~ftmutableobjectarrayclass module~hashmodule HashModule module~ftdictionaryclass->module~hashmodule module~ftvalueclass->iso_fortran_env ieee_arithmetic ieee_arithmetic module~ftvalueclass->ieee_arithmetic module~ftobjectclass FTObjectClass module~ftvalueclass->module~ftobjectclass module~ftolconstants FTOLConstants module~ftvalueclass->module~ftolconstants module~ftkeyobjectpairclass->module~ftobjectclass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftmutableobjectarrayclass->module~ftobjectclass module~ftlinkedlistrecordclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftvaluedictionaryclass~~UsedByGraph module~ftvaluedictionaryclass FTValueDictionaryClass module~ftexceptionclass FTExceptionClass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftobjectlibrary->module~ftexceptionclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types FTValueDictionary Functions realValueForKey integerValueForKey doublePrecisionValueForKey quadValueForKey logicalValueForKey stringValueForKey valueDictionaryFromDictionary valueDictionaryFromObject valueDictionaryClassName Subroutines releaseFTValueDictionary addIntegerValueForKey addRealValueForKey addDoublePrecisionValueForKey addQuadValueForKey addStringValueForKey addLogicalValueForKey castDictionaryToValueDictionary castObjectToValueDictionary Derived Types type, public, extends( FTDictionary ) :: FTValueDictionary Components Type Visibility Attributes Name Initial integer, public :: numberOfEntries logical, public :: isCaseSensitive type( FTLinkedList ), public, DIMENSION(:), POINTER :: entries => NULL() Type-Bound Procedures procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: initWithSize Subroutine procedure\n                    ,                  public\n,                   :: init Subroutine procedure\n                    ,                  public\n,                   :: allKeys => AllKeys Function procedure\n                    ,                  public\n,                   :: allObjects => AllObjects Function procedure\n                    ,                  public\n,                   :: addObjectForKey Subroutine procedure\n                    ,                  public\n,                   :: description => FTDictionaryDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTDictionaryDescription Subroutine procedure\n                    ,                  public\n,                   :: objectForKey Function procedure\n                    ,                  public\n,                   :: containsKey Function procedure\n                    ,                  public\n,                   :: COUNT Function generic,\n                  public\n                  :: addValueForKey =>\n                    addRealValueForKey, addDoublePrecisionValueForKey, addIntegerValueForKey, addStringValueForKey, addLogicalValueForKey generic,\n                  public\n                  :: addValueForKey =>\n                    addQuadValueForKey procedure\n                    ,                  public\n,                   :: realValueForKey Function procedure\n                    ,                  public\n,                   :: doublePrecisionValueForKey Function procedure\n                    ,                  public\n,                   :: quadValueForKey Function procedure\n                    ,                  public\n,                   :: integerValueForKey Function procedure\n                    ,                  public\n,                   :: stringValueForKey Function procedure\n                    ,                  public\n,                   :: logicalValueForKey Function procedure\n                    ,                  public\n,                   :: className => valueDictionaryClassName Function Functions public  function realValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value real public  function integerValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value integer public  function doublePrecisionValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value doubleprecision public  function quadValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value real(kind=selected_real_kind(quad_digits)) public  function logicalValueForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key Return Value logical public  function stringValueForKey (self, key, requestedLength) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: key integer :: requestedLength Return Value character(len=requestedLength) public  function valueDictionaryFromDictionary (dict) result(valueDict) Arguments Type Intent Optional Attributes Name class( FTDictionary ), POINTER :: dict Return Value class( FTValueDictionary ), POINTER public  function valueDictionaryFromObject (obj) result(valueDict) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTValueDictionary ), POINTER public  function valueDictionaryClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Subroutines public  subroutine releaseFTValueDictionary (self) Public, generic name: release(self) Read more… Arguments Type Intent Optional Attributes Name type( FTValueDictionary ), POINTER :: self public  subroutine addIntegerValueForKey (self, i, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self integer :: i character(len=*) :: key public  subroutine addRealValueForKey (self, r, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self real :: r character(len=*) :: key public  subroutine addDoublePrecisionValueForKey (self, r, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self double precision :: r character(len=*) :: key public  subroutine addQuadValueForKey (self, r, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)) :: r character(len=*) :: key public  subroutine addStringValueForKey (self, s, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self character(len=*) :: s character(len=*) :: key public  subroutine addLogicalValueForKey (self, l, key) Arguments Type Intent Optional Attributes Name class( FTValueDictionary ) :: self logical :: l character(len=*) :: key public  subroutine castDictionaryToValueDictionary (dict, valueDict) Arguments Type Intent Optional Attributes Name class( FTDictionary ), POINTER :: dict class( FTValueDictionary ), POINTER :: valueDict public  subroutine castObjectToValueDictionary (obj, valueDict) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTValueDictionary ), POINTER :: valueDict","tags":"","loc":"module/ftvaluedictionaryclass.html"},{"title":"FTKeyObjectPairClass – FTObjectLibrary","text":"The FTKeyObjectPairClass is for use by the FTDictionary Class and will\ngenerally not be interacted with by the user. Uses FTObjectClass module~~ftkeyobjectpairclass~~UsesGraph module~ftkeyobjectpairclass FTKeyObjectPairClass module~ftobjectclass FTObjectClass module~ftkeyobjectpairclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftkeyobjectpairclass~~UsedByGraph module~ftkeyobjectpairclass FTKeyObjectPairClass module~ftdictionaryclass FTDictionaryClass module~ftdictionaryclass->module~ftkeyobjectpairclass module~ftexceptionclass FTExceptionClass module~ftexceptionclass->module~ftdictionaryclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftdictionaryclass module~ftobjectlibrary->module~ftexceptionclass module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftstringsetclass FTStringSetClass module~ftstringsetclass->module~ftdictionaryclass module~ftvaluedictionaryclass->module~ftdictionaryclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables FTDICT_KWD_STRING_LENGTH Derived Types FTKeyObjectPair Functions FTKeyObjectPairDescription key object Subroutines initWithObjectAndKey releaseFTKeyObjectPair destructFTKeyObjectPair printFTKeyObjectPairDescription Variables Type Visibility Attributes Name Initial integer, public, parameter :: FTDICT_KWD_STRING_LENGTH = 64 Derived Types type, public, extends( FTObject ) :: FTKeyObjectPair Components Type Visibility Attributes Name Initial character(len=FTDICT_KWD_STRING_LENGTH), public :: keyString class( FTObject ), public, POINTER :: valueObject => NULL() Finalizations Procedures final :: destructFTKeyObjectPair Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: className Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: initWithObjectAndKey Subroutine procedure\n                    ,                  public\n,                   :: description => FTKeyObjectPairDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTKeyObjectPairDescription Subroutine procedure\n                    ,                  public\n,                   :: key Function procedure\n                    ,                  public\n,                   :: object Function Functions public  function FTKeyObjectPairDescription (self) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self Return Value character(len=description_character_length) public  function key (self) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self Return Value character(len=ftdict_kwd_string_length) public  function object (self) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self Return Value class( FTObject ), POINTER Subroutines public  subroutine initWithObjectAndKey (self, v, key) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self class( FTObject ), POINTER :: v character(len=*) :: key public  subroutine releaseFTKeyObjectPair (self) Arguments Type Intent Optional Attributes Name type( FTKeyObjectPair ), POINTER :: self public  subroutine destructFTKeyObjectPair (self) Arguments Type Intent Optional Attributes Name type( FTKeyObjectPair ) :: self public recursive subroutine printFTKeyObjectPairDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTKeyObjectPair ) :: self integer :: iUnit","tags":"","loc":"module/ftkeyobjectpairclass.html"},{"title":"FTDictionaryClass – FTObjectLibrary","text":"A dictionary is a special case of a hash table that stores key-value pairs. It is an\nexample of what is called an ``associative container''. In the implementation of FTObjectLibrary,\nthe value can be any subclass of FTObject and the key is a character variable. The library\nincludes the base dictionary that can store and retrieve any subclass of FTObject. It also includes a\nsubclass that is designed to store and retrieve FTValue objects. FTDictionary (Inherits from FTObject) Initialization CLASS(FTDictionary), POINTER :: dict\n     ALLOCATE(dict)\n     CALL dict % initWithSize(N) ! N = size of dictionary. Should be power of two Adding entries CLASS(FTDictionary), POINTER :: dict\n     CLASS(FTObject)    , POINTER :: obj\n     CHARACTER(LEN=N)             :: key\n     obj => r                            ! r is subclass of FTObject\n     CALL dict % addObjectForKey(obj,key) Accessing entries obj => dict % objectForKey(key)\n     CALL cast(obj,v) ! v is the type of object to be extracted Destruction CALL releaseFTDictionary ( dict ) [ Pointer ] Accessing an object TYPE(FTObject) :: obj\n       obj => dict % objectForKey(key) Converting a base class pointer to a dictionary dict =>  dictionaryFromObject(obj) Getting all of the keys CHARACTER(LEN=FTDICT_KWD_STRING_LENGTH), POINTER :: keys(:)\n       keys =>  dict % allKeys() (The target of the pointer must be deallocated by the caller) Getting all of the objects CLASS(FTMutableObjectArray), POINTER :: objectArray\n       objectArray =>  dict % allObjects() ! The array is owned by the caller. (The target of the pointer must be released by the caller) Uses FTMutableObjectArrayClass FTLinkedListClass FTKeyObjectPairClass FTLinkedListIteratorClass HashModule module~~ftdictionaryclass~~UsesGraph module~ftdictionaryclass FTDictionaryClass module~ftkeyobjectpairclass FTKeyObjectPairClass module~ftdictionaryclass->module~ftkeyobjectpairclass module~ftlinkedlistclass FTLinkedListClass module~ftdictionaryclass->module~ftlinkedlistclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftdictionaryclass->module~ftmutableobjectarrayclass module~hashmodule HashModule module~ftdictionaryclass->module~hashmodule module~ftobjectclass FTObjectClass module~ftkeyobjectpairclass->module~ftobjectclass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftmutableobjectarrayclass->module~ftobjectclass module~ftlinkedlistrecordclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftdictionaryclass~~UsedByGraph module~ftdictionaryclass FTDictionaryClass module~ftexceptionclass FTExceptionClass module~ftexceptionclass->module~ftdictionaryclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftdictionaryclass module~ftobjectlibrary->module~ftexceptionclass module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftstringsetclass FTStringSetClass module~ftstringsetclass->module~ftdictionaryclass module~ftvaluedictionaryclass->module~ftdictionaryclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces cast Derived Types FTDictionary Functions COUNT objectForKey containsKey FTDictionaryDescription AllObjects AllKeys dictionaryFromObject dictionaryClassName Subroutines init initWithSize releaseFTDictionary destructFTDictionary addObjectForKey printFTDictionaryDescription castToDictionary Interfaces public        interface cast public  subroutine castToDictionary (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTDictionary ), POINTER :: cast Derived Types type, public, extends( FTObject ) :: FTDictionary Components Type Visibility Attributes Name Initial integer, public :: numberOfEntries logical, public :: isCaseSensitive type( FTLinkedList ), public, DIMENSION(:), POINTER :: entries => NULL() Finalizations Procedures final :: destructFTDictionary Type-Bound Procedures procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n,                   :: initWithSize Subroutine procedure\n                    ,                  public\n,                   :: init Subroutine procedure\n                    ,                  public\n,                   :: allKeys => AllKeys Function procedure\n                    ,                  public\n,                   :: allObjects => AllObjects Function procedure\n                    ,                  public\n,                   :: addObjectForKey Subroutine procedure\n                    ,                  public\n,                   :: description => FTDictionaryDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printFTDictionaryDescription Subroutine procedure\n                    ,                  public\n,                   :: objectForKey Function procedure\n                    ,                  public\n,                   :: containsKey Function procedure\n                    ,                  public\n,                   :: className => dictionaryClassName Function procedure\n                    ,                  public\n,                   :: COUNT Function Functions public  function COUNT (self) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value integer public  function objectForKey (self, key) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self character(len=*) :: key Return Value class( FTObject ), POINTER public  function containsKey (self, key) result(r) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self character(len=*) :: key Return Value logical public  function FTDictionaryDescription (self) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=description_character_length) public  function AllObjects (self) result(objectArray) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value class( FTMutableObjectArray ), POINTER public  function AllKeys (self) result(keys) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=FTDICT_KWD_STRING_LENGTH), POINTER, (:) public  function dictionaryFromObject (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTDictionary ), POINTER public  function dictionaryClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Subroutines public  subroutine init (self) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self public  subroutine initWithSize (self, sze) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self integer, intent(in) :: sze public  subroutine releaseFTDictionary (self) Arguments Type Intent Optional Attributes Name type( FTDictionary ), POINTER :: self public  subroutine destructFTDictionary (self) Arguments Type Intent Optional Attributes Name type( FTDictionary ) :: self public  subroutine addObjectForKey (self, object, key) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self class( FTObject ), POINTER :: object character(len=*) :: key public recursive subroutine printFTDictionaryDescription (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTDictionary ) :: self integer :: iUnit public  subroutine castToDictionary (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTDictionary ), POINTER :: cast","tags":"","loc":"module/ftdictionaryclass.html"},{"title":"FTValueClass – FTObjectLibrary","text":"A not completely F2003/2008 version of an immutable class\nto store primitive values: integer, real, double precision, logical,\ncharacter. (To Add: complex) This version does not use CLASS(*) or deferred length strings\nso that it can be used with gfortran 4.7/4.8 Usage: Initialization TYPE(FTValue) :: r, i, s, l, d\n\n   CALL r % initValue(3.14)\n   CALL i % initValue(6)\n   CALL d % initValue(3.14d0)\n   CALL l % initValue(.true.)\n   CALL s % initValue(\"A string\") Destruction call releaseFTValue ( r ) [ Pointers ] Accessors real = r % realValue()\n   int  = i % integerValue()\n   doub = d % doublePrecisionValue()\n   logc = l % logicalValue()\n   str  = s % stringValue(nChars) Description str = v % description()\n   call v % printDescription(unit) Casting CLASS(FTVALUE) , POINTER :: v\n   CLASS(FTObject), POINTER :: obj\n   call cast(obj,v) The class will attempt to convert between the different types: CALL r % initWithReal ( 3.14 ) print * , r % stringValue ( 8 ) Logical variables rules : real , doublePrecision , integer values logicalValue = . FALSE . if input = 0 logicalValue = . TRUE . if input /= 0 String values can be converted to numeric types. If the string is\nnot a numeric, Huge(1) will be returned, for integers and NaN for reals. @author David Kopriva Uses iso_fortran_env ieee_arithmetic FTObjectClass FTOLConstants module~~ftvalueclass~~UsesGraph module~ftvalueclass FTValueClass ieee_arithmetic ieee_arithmetic module~ftvalueclass->ieee_arithmetic iso_fortran_env iso_fortran_env module~ftvalueclass->iso_fortran_env module~ftobjectclass FTObjectClass module~ftvalueclass->module~ftobjectclass module~ftolconstants FTOLConstants module~ftvalueclass->module~ftolconstants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftvalueclass~~UsedByGraph module~ftvalueclass FTValueClass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftvalueclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftexceptionclass FTExceptionClass module~ftobjectlibrary->module~ftexceptionclass module~ftvaluedictionaryclass->module~ftvalueclass module~ftexceptionclass->module~ftvaluedictionaryclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables FTVALUE_NOT_INTEGER FTVALUE_NOT_REAL FTVALUE_NOT_DOUBLEPRECISION FTVALUE_STRING_LENGTH FT_REAL_KIND FT_DOUBLE_PRECISION_KIND Interfaces cast Derived Types FTValue Functions realValue doublePrecisionValue quadValue integerValue logicalValue stringValue FTValueDescription valueFromObject valueClassName Subroutines initWithReal initWithDoublePrecision initWithQuad initWithInteger initWithLogical initWithString releaseFTValue destructValue printValueDescription castToValue Variables Type Visibility Attributes Name Initial integer, public, parameter :: FTVALUE_NOT_INTEGER = HUGE(1) real, public, parameter :: FTVALUE_NOT_REAL = HUGE(1.0) double precision, public, parameter :: FTVALUE_NOT_DOUBLEPRECISION = HUGE(1.0D0) integer, public, parameter :: FTVALUE_STRING_LENGTH = 512 integer, public, parameter :: FT_REAL_KIND = SELECTED_REAL_KIND(6) integer, public, parameter :: FT_DOUBLE_PRECISION_KIND = SELECTED_REAL_KIND(15) Interfaces public        interface cast public  subroutine castToValue (obj, cast) Generic Name: cast Cast a pointer to the base class to an FTValue pointer Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTValue ), POINTER :: cast Derived Types type, public, extends( FTObject ) :: FTValue Finalizations Procedures final :: destructValue Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function generic,\n                  public\n                  :: initWithValue =>\n                    initWithReal, initWithDoublePrecision, initWithString, initWithLogical, initWithInteger generic,\n                  public\n                  :: initWithValue =>\n                    initWithQuad procedure\n                    ,                  public\n,                   :: realValue Function procedure\n                    ,                  public\n,                   :: doublePrecisionValue Function procedure\n                    ,                  public\n,                   :: quadValue Function procedure\n                    ,                  public\n,                   :: stringValue Function procedure\n                    ,                  public\n,                   :: logicalValue Function procedure\n                    ,                  public\n,                   :: integerValue Function procedure\n                    ,                  public\n,                   :: description => FTValueDescription Function procedure\n                    ,                  public\n,                   :: printDescription => printValueDescription Subroutine procedure\n                    ,                  public\n,                   :: className => valueClassName Function Functions public  function realValue (self) Get the real value stored in the object, or convert the value\nin the object to a real if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value real public  function doublePrecisionValue (self) Get the double precision value stored in the object, or convert the value\nin the object to a double precision if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value doubleprecision public  function quadValue (self) Get the double precision value stored in the object, or convert the value\nin the object to a double precision if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value doubleprecision public  function integerValue (self) Get the integer value stored in the object, or convert the value\nin the object to an integer if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value integer public  function logicalValue (self) Get the logical value stored in the object, or convert the value\nin the object to a logical if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value logical public  function stringValue (self, requestedLength) result(s) Get the string value of length requestedLength stored in the object, or \nconvert the value\nin the object to a string of that length if it is of a different type. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self integer :: requestedLength Return Value character(len=requestedLength) public  function FTValueDescription (self) Returns the description of the value. In this case, it returns the \nstringValue() of the object. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value character(len=DESCRIPTION_CHARACTER_LENGTH) public  function valueFromObject (obj) result(cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTValue ), POINTER public  function valueClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTValue ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Subroutines public  subroutine initWithReal (self, v) Public, generic name: initwithValue() Read more… Arguments Type Intent Optional Attributes Name class( FTValue ) :: self real :: v public  subroutine initWithDoublePrecision (self, v) Public, generic name: initwithValue() Read more… Arguments Type Intent Optional Attributes Name class( FTValue ) :: self doubleprecision :: v public  subroutine initWithQuad (self, v) Public, generic name: initwithValue() Read more… Arguments Type Intent Optional Attributes Name class( FTValue ) :: self real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)) :: v public  subroutine initWithInteger (self, v) Public, generic name: initwithValue() Read more… Arguments Type Intent Optional Attributes Name class( FTValue ) :: self integer :: v public  subroutine initWithLogical (self, v) Public, generic name: initwithValue() Read more… Arguments Type Intent Optional Attributes Name class( FTValue ) :: self logical :: v public  subroutine initWithString (self, v) Public, generic name: initwithValue() Read more… Arguments Type Intent Optional Attributes Name class( FTValue ) :: self character(len=*) :: v public  subroutine releaseFTValue (self) Arguments Type Intent Optional Attributes Name type( FTValue ), POINTER :: self public  subroutine destructValue (self) Public, generic name: destruct() Read more… Arguments Type Intent Optional Attributes Name type( FTValue ) :: self public  subroutine printValueDescription (self, iUnit) Prints the description of the value to unit iUnit. In this case, it prints the stringValue() of the object. Arguments Type Intent Optional Attributes Name class( FTValue ) :: self integer :: iUnit public  subroutine castToValue (obj, cast) Generic Name: cast Read more… Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTValue ), POINTER :: cast","tags":"","loc":"module/ftvalueclass.html"},{"title":"FTStringSetClass – FTObjectLibrary","text":"FTStringSet is a class for an unordered collection of strings. Use a FTStringSet\nto store strings as an alternative to arrays when the order is not important, but\ntesting for membership is. Definition TYPE ( FTStringSet ) :: varName Usage Initialization CLASS(FTStringSet)  :: FTStringSet\n   integer             :: N = 11\n   logical             :: cs = .true.\n   CALL FTStringSet % initFTStringSet(N,cs)\n\n   CLASS(FTStringSet)  :: FTStringSet\n   CHARACTER(LEN=*)    :: strings(:)\n   CALL FTStringSet % initWithStrings(strings) Destruction CALL FTStringSet % destuct () [ Non Pointers ] CALL releaseFTStringSet ( stringSet ) [ Pointers ] Adding Strings CALL set % addString(str) Testing membership: if ( set % containsString ( str )) THEN Getting an array of members CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) , DIMENSION ( : ) , POINTER :: s s => set % strings ... do something ... DEALLOCATE ( s ) Set operations, union, intersection, difference newSet => set1 % unionWithSet ( set2 ) ... do something ... call releaseFTStringSet ( newSet ) newSet => set1 % intersectionWithSet ( set2 ) ... do something ... call releaseFTStringSet ( newSet ) newSet => set1 % setFromDifference ( set2 ) ... do something ... call releaseFTStringSet ( newSet ) Uses FTObjectClass FTDictionaryClass module~~ftstringsetclass~~UsesGraph module~ftstringsetclass FTStringSetClass module~ftdictionaryclass FTDictionaryClass module~ftstringsetclass->module~ftdictionaryclass module~ftobjectclass FTObjectClass module~ftstringsetclass->module~ftobjectclass module~ftkeyobjectpairclass FTKeyObjectPairClass module~ftdictionaryclass->module~ftkeyobjectpairclass module~ftlinkedlistclass FTLinkedListClass module~ftdictionaryclass->module~ftlinkedlistclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftdictionaryclass->module~ftmutableobjectarrayclass module~hashmodule HashModule module~ftdictionaryclass->module~hashmodule module~ftkeyobjectpairclass->module~ftobjectclass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftlinkedlistrecordclass FTLinkedListRecordClass module~ftlinkedlistclass->module~ftlinkedlistrecordclass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftmutableobjectarrayclass->module~ftobjectclass module~ftlinkedlistrecordclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types FTStringSet Functions stringCount containsString strings unionWithSet intersectionWithSet setFromDifference isEmpty FTStringSetFromObject FTStringSetClassName Subroutines initFTStringSet initWithStrings destructFTStringSet releaseFTStringSet AddString printFTStringSet Derived Types type, public, extends( FTObject ) :: FTStringSet Finalizations Procedures final :: destructFTStringSet Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n                  :: initFTStringSet Subroutine procedure\n                    ,                  public\n                  :: initWithStrings Subroutine procedure\n                    ,                  public\n                  :: addString => AddString Subroutine procedure\n                    ,                  public\n                  :: containsString Function procedure\n                    ,                  public\n                  :: strings Function procedure\n                    ,                  public\n                  :: unionWithSet Function procedure\n                    ,                  public\n                  :: intersectionWithSet Function procedure\n                    ,                  public\n                  :: setFromDifference Function procedure\n                    ,                  public\n                  :: isEmpty Function procedure\n                    ,                  public\n                  :: count => stringCount Function procedure\n                    ,                  public\n                  :: printDescription => printFTStringSet Subroutine procedure\n                    ,                  public\n                  :: className => FTStringSetClassName Function Functions public  function stringCount (self) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value integer public  function containsString (self, str) containsString returns .TRUE. if the set contains the string, .FALSE. \n otherwise. Read more… Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self character(len=*) :: str Return Value logical public  function strings (self) result(s) strings returns a pointer to an array of strings that are in the set.\n Deallocate this array when done with it. Read more… Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value character(len=FTDICT_KWD_STRING_LENGTH), DIMENSION(:), POINTER public  function unionWithSet (self, set) result(newSet) unionWithSet returns a pointer to a new set that is the union of two sets.\n the new set has reference count of 1. Release when done. Read more… Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self class( FTStringSet ) :: set Return Value type( FTStringSet ), POINTER public  function intersectionWithSet (self, set) result(newSet) intersectionWithSet returns a pointer to a new set that is the intersection of two sets.\n the new set has reference count of 1. Release when done. Read more… Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self class( FTStringSet ) :: set Return Value type( FTStringSet ), POINTER public  function setFromDifference (self, set) result(newSet) setFromDifference returns a pointer to a new set that is the difference of two sets. the new set has reference count of 1. Release when done. Read more… Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self class( FTStringSet ) :: set Return Value type( FTStringSet ), POINTER public  function isEmpty (self) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value logical public  function FTStringSetFromObject (obj) result(cast) Generic Name: cast Read more… Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTStringSet ), POINTER public  function FTStringSetClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Subroutines public  subroutine initFTStringSet (self, FTStringSetSize) Designated initializer. Initializes the amount of storage, but\nthe FTStringSet remains empty. Read more… Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self integer :: FTStringSetSize public  subroutine initWithStrings (self, strings) initializer. Initializes the amount of storage from the strings passed Usage\n      CLASS(FTStringSet)  :: FTStringSet\n      CHARACTER(LEN= )    :: strings(:)\n      CALL FTStringSet % initWithStrings(strings) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self character(len=*) :: strings (:) public  subroutine destructFTStringSet (self) Destructor for the class. This is called automatically when the\nreference count reaches zero. Do not call this yourself on pointers Arguments Type Intent Optional Attributes Name type( FTStringSet ) :: self public  subroutine releaseFTStringSet (self) Public, generic name: release(self) Read more… Arguments Type Intent Optional Attributes Name type( FTStringSet ), POINTER :: self public  subroutine AddString (self, str) AddString adds a string to the set if it is not already present Read more… Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self character(len=*) :: str public  subroutine printFTStringSet (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTStringSet ) :: self integer :: iUnit","tags":"","loc":"module/ftstringsetclass.html"},{"title":"FTMutableObjectArrayClass – FTObjectLibrary","text":"FTMutableObjectArray is a mutable array class to which objects\ncan be added, removed, replaced and accessed according to their \nindex in the array. Fortran has pointers to arrays, but not arrays of pointers. To do the latter, one creates\na wrapper derived type and creates an array of that wrapper type. Fortran arrays are great, but\nthey are of fixed length, and they don't easily implement reference counting to keep track of\nmemory. For that, we have the FTMutableObjectArray. Performance reasons dictate that you \nwill use regular arrays for numeric types and the like, but for generic objects we would use\nan Object Array. You initialize a FTMutableObjectArray with the number of objects that you expect it to hold.\nHowever, it can re-size itself if necessary. To be efficient, it adds more than one entry at a time\ngiven by the ``chunkSize'', which you can choose for yourself. (The default is 10.) Definition TYPE(FTMutableObjectArray) :: array Usage Initialization CLASS(FTMutableObjectArray)  :: array\n  INTEGER                      :: N = 11\n  CALL array % initWithSize(N) Destruction CALL array % destuct () [ Non Pointers ] call releaseFTMutableObjectArray ( array ) [ Pointers ] Adding an Object TYPE(FTObject) :: obj\n       obj => r1\n       CALL array % addObject(obj) Removing an Object TYPE(FTObject) :: obj\n       CALL array % removeObjectAtIndex(i) Accessing an Object TYPE(FTObject) :: obj\n       obj => array % objectAtIndex(i) Replacing an Object TYPE(FTObject) :: obj\n       obj => r1\n       CALL array % replaceObjectAtIndexWithObject(i,obj) Setting the Chunk Size CALL array % setChunkSize(size) Finding The Number Of Items In The Array n =  array % count() Finding The Actual Allocated Size Of The Array n =  array % allocatedSize() Uses FTObjectClass module~~ftmutableobjectarrayclass~~UsesGraph module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftobjectclass FTObjectClass module~ftmutableobjectarrayclass->module~ftobjectclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftmutableobjectarrayclass~~UsedByGraph module~ftmutableobjectarrayclass FTMutableObjectArrayClass module~ftdictionaryclass FTDictionaryClass module~ftdictionaryclass->module~ftmutableobjectarrayclass module~ftlinkedlistclass FTLinkedListClass module~ftdictionaryclass->module~ftlinkedlistclass module~ftlinkedlistiteratorclass FTLinkedListIteratorClass module~ftdictionaryclass->module~ftlinkedlistiteratorclass module~ftlinkedlistclass->module~ftmutableobjectarrayclass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftmutableobjectarrayclass module~ftobjectlibrary->module~ftdictionaryclass module~ftobjectlibrary->module~ftlinkedlistclass module~ftexceptionclass FTExceptionClass module~ftobjectlibrary->module~ftexceptionclass module~ftobjectlibrary->module~ftlinkedlistiteratorclass module~ftsparsematrixclass FTSparseMatrixClass module~ftobjectlibrary->module~ftsparsematrixclass module~ftstackclass FTStackClass module~ftobjectlibrary->module~ftstackclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftobjectlibrary->module~ftvaluedictionaryclass module~ftexceptionclass->module~ftdictionaryclass module~ftexceptionclass->module~ftlinkedlistiteratorclass module~ftexceptionclass->module~ftstackclass module~ftexceptionclass->module~ftvaluedictionaryclass module~ftlinkedlistiteratorclass->module~ftlinkedlistclass module~ftmultiindextableclass FTMultiIndexTableClass module~ftmultiindextableclass->module~ftlinkedlistclass module~ftsparsematrixclass->module~ftlinkedlistclass module~ftsparsematrixclass->module~ftlinkedlistiteratorclass module~ftstackclass->module~ftlinkedlistclass module~ftstringsetclass FTStringSetClass module~ftstringsetclass->module~ftdictionaryclass module~ftvaluedictionaryclass->module~ftdictionaryclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces cast Derived Types FTMutableObjectArray Functions objectAtIndex chunkSize numberOfItems allocatedSize objectArrayFromObject arrayClassName Subroutines initObjectArrayWithSize releaseFTMutableObjectArray destructObjectArray addObjectToArray removeObjectAtIndex replaceObjectAtIndexWithObject printArray setChunkSize castToMutableObjectArray Interfaces public        interface cast public  subroutine castToMutableObjectArray (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTMutableObjectArray ), POINTER :: cast Derived Types type, public, extends( FTObject ) :: FTMutableObjectArray Finalizations Procedures final :: destructObjectArray Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => initFTObject Subroutine procedure\n                    ,                  public\n,                   :: description => FTObjectDescription Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: copy =>\n                    copyFTObject Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: retain => retainFTObject Subroutine procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: isUnreferenced Function procedure\n                    ,                  public\n, NON_OVERRIDABLE                  :: refCount Function procedure\n                    ,                  public\n                  :: initWithSize => initObjectArrayWithSize Subroutine procedure\n                    ,                  public\n                  :: addObject => addObjectToArray Subroutine procedure\n                    ,                  public\n                  :: replaceObjectAtIndexWithObject Subroutine procedure\n                    ,                  public\n                  :: removeObjectAtIndex Subroutine procedure\n                    ,                  public\n                  :: objectAtIndex Function procedure\n                    ,                  public\n                  :: printDescription => printArray Subroutine procedure\n                    ,                  public\n                  :: className => arrayClassName Function procedure\n                    ,                  public\n                  :: setChunkSize Subroutine procedure\n                    ,                  public\n                  :: chunkSize Function procedure\n                    ,                  public\n                  :: COUNT => numberOfItems Function procedure\n                    ,                  public\n                  :: allocatedSize Function Functions public  function objectAtIndex (self, indx) result(obj) Access the object at the index indx Read more… Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: indx Return Value class( FTObject ), POINTER public  function chunkSize (self) Returns the number of items to be added when the array needs to be re-sized Read more… Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value integer public  function numberOfItems (self) Generic name: count Read more… Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value integer public  function allocatedSize (self) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value integer public  function objectArrayFromObject (obj) result(cast) Generic Name: cast Read more… Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj Return Value class( FTMutableObjectArray ), POINTER public  function arrayClassName (self) result(s) Class name returns a string with the name of the type of the object Read more… Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self Return Value character(len=CLASS_NAME_CHARACTER_LENGTH) Subroutines public  subroutine initObjectArrayWithSize (self, arraySize) Designated initializer. Initializes the amount of storage, but\nthe array remains empty. Read more… Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: arraySize public  subroutine releaseFTMutableObjectArray (self) Arguments Type Intent Optional Attributes Name type( FTMutableObjectArray ), POINTER :: self public recursive subroutine destructObjectArray (self) Destructor for the class. This is called automatically when the\nreference count reaches zero. Do not call this yourself. Arguments Type Intent Optional Attributes Name type( FTMutableObjectArray ) :: self public  subroutine addObjectToArray (self, obj) Add an object to the end of the array Read more… Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self class( FTObject ), POINTER :: obj public  subroutine removeObjectAtIndex (self, indx) Remove an object at the index indx Read more… Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: indx public  subroutine replaceObjectAtIndexWithObject (self, indx, replacement) Replace an object at the index indx Read more… Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: indx class( FTObject ), POINTER :: replacement public  subroutine printArray (self, iUnit) Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: iUnit public  subroutine setChunkSize (self, chunkSize) Set the number of items to be added when the array needs to be re-sized Read more… Arguments Type Intent Optional Attributes Name class( FTMutableObjectArray ) :: self integer :: chunkSize public  subroutine castToMutableObjectArray (obj, cast) Arguments Type Intent Optional Attributes Name class( FTObject ), POINTER :: obj class( FTMutableObjectArray ), POINTER :: cast","tags":"","loc":"module/ftmutableobjectarrayclass.html"},{"title":"FTOLConstants – FTObjectLibrary","text":"Defines constants to be used by the library Used by module~~ftolconstants~~UsedByGraph module~ftolconstants FTOLConstants module~comparisonsmodule ComparisonsModule module~comparisonsmodule->module~ftolconstants module~ftassertions FTAssertions module~ftassertions->module~ftolconstants module~ftassertions->module~comparisonsmodule module~ftvalueclass FTValueClass module~ftvalueclass->module~ftolconstants module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~comparisonsmodule module~ftobjectlibrary->module~ftassertions module~ftobjectlibrary->module~ftvalueclass module~ftvaluedictionaryclass FTValueDictionaryClass module~ftobjectlibrary->module~ftvaluedictionaryclass module~testsuitemanagerclass TestSuiteManagerClass module~ftobjectlibrary->module~testsuitemanagerclass module~ftexceptionclass FTExceptionClass module~ftobjectlibrary->module~ftexceptionclass module~ftvaluedictionaryclass->module~ftvalueclass module~testsuitemanagerclass->module~ftassertions module~ftexceptionclass->module~ftvaluedictionaryclass module~sharedexceptionmanagermodule SharedExceptionManagerModule module~sharedexceptionmanagermodule->module~ftexceptionclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables FT_ORDERED_ASCENDING FT_ORDERED_DESCENDING FT_ORDERED_SAME QUAD_DIGITS Variables Type Visibility Attributes Name Initial integer, public, parameter :: FT_ORDERED_ASCENDING = 1 integer, public, parameter :: FT_ORDERED_DESCENDING = -1 integer, public, parameter :: FT_ORDERED_SAME = 0 integer, public, parameter :: QUAD_DIGITS = 30","tags":"","loc":"module/ftolconstants.html"},{"title":"TestSuiteManagerClass – FTObjectLibrary","text":"The TestSuiteManager class defines methods to easily\n put together and run a suite of unit tests. The tests are managed by an instance of the TestSuiteManager class. It is designed to be used with minimal fuss. You Initialize the test suite Add test subroutines Have the testSuiteManager perform the tests Finalize the test suite manager Usage: Definition TYPE(TestSuiteManager) :: testSuite Initialization call testSuite % init() Creating a test A test is a subroutine with interface ABSTRACT INTERFACE SUBROUTINE testSuiteSubroutine () CHARACTER ( LEN = 1 ), POINTER , OPTIONAL :: optData (:) END SUBROUTINE testSuiteSubroutine END INTERFACE that (typically) includes unit test calls. You add\n   a test suite function by the add subroutine CALL testSuite % addTestSubroutineWithName(SubroutineName, description) where SubroutineName = a subroutine with the interface as above, and description = a CHARACTER(LEN=128) character string that names the test Alternately optional data acan be added to the call CALL testSuite % addTestSubroutineWithName(SubroutineName, description, optData) where OptData is CHARACTER(LEN=1), POINTER :: optData(:) The optional data can contain anything if it is encoded using the TRANSFER function. This is a standard\n trick in fortran. Setting the output location Set the unit to which the output is written by CALL testSuite % setOutputUnit(iUnit) Running tests To run the tests call CALL testSuite % performTests() OR\n     CALL testSuite % performTests(numFailed) Finalizing the test suite When done, call CALL finalizeSharedAssertionsManager Uses FTAssertions module~~testsuitemanagerclass~~UsesGraph module~testsuitemanagerclass TestSuiteManagerClass module~ftassertions FTAssertions module~testsuitemanagerclass->module~ftassertions iso_fortran_env iso_fortran_env module~ftassertions->iso_fortran_env module~comparisonsmodule ComparisonsModule module~ftassertions->module~comparisonsmodule module~ftolconstants FTOLConstants module~ftassertions->module~ftolconstants module~comparisonsmodule->iso_fortran_env module~comparisonsmodule->module~ftolconstants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~testsuitemanagerclass~~UsedByGraph module~testsuitemanagerclass TestSuiteManagerClass module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~testsuitemanagerclass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types TestSuiteManager Derived Types type, public :: TestSuiteManager Components Type Visibility Attributes Name Initial integer, public :: numberOfTests integer, public :: stdOut = 6 type(TestCaseRecord), public, POINTER :: testCasesHead => NULL() type(TestCaseRecord), public, POINTER :: testCasesTail => NULL() Finalizations Procedures final :: finalizeTestSuiteManager Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init =>\n                    initializeTestSuiteManager Subroutine procedure\n                    ,                  public\n,                   :: addTestSubroutineWithName Subroutine procedure\n                    ,                  public\n,                   :: performTests Subroutine procedure\n                    ,                  public\n,                   :: setOutputUnit Subroutine","tags":"","loc":"module/testsuitemanagerclass.html"},{"title":"FTAssertions – FTObjectLibrary","text":"Assertions are functions that return true or false\n that can be placed in a program to test whether\n a predicate is true. To use the assertions module, it must be initialized,\n usually in the main program. When it is no longer needed,\n it is finalized. Assertions are posted to the module as they\n are called, and can be summarized later at an appropriate time. Initialization CALL initializeSharedAssertionsManager Finalization CALL finalizeSharedAssertionsManager Asserting CALL FTAssertEqual(expectedValue,resultValue,message) Summarizing Assertions CALL SummarizeFTAssertions(title,unit) Additional enquiry functions INTEGER :: nf, nA\n   nF = numberOfAssertionFailures()\n   nA = numberOfAssertions() Uses iso_fortran_env FTOLConstants ComparisonsModule module~~ftassertions~~UsesGraph module~ftassertions FTAssertions iso_fortran_env iso_fortran_env module~ftassertions->iso_fortran_env module~comparisonsmodule ComparisonsModule module~ftassertions->module~comparisonsmodule module~ftolconstants FTOLConstants module~ftassertions->module~ftolconstants module~comparisonsmodule->iso_fortran_env module~comparisonsmodule->module~ftolconstants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ftassertions~~UsedByGraph module~ftassertions FTAssertions module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~ftassertions module~testsuitemanagerclass TestSuiteManagerClass module~ftobjectlibrary->module~testsuitemanagerclass module~testsuitemanagerclass->module~ftassertions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables FT_ASSERTION_STRING_LENGTH Interfaces FTAssertEqual Derived Types FTAssertionsManager Functions sharedAssertionsManager numberOfAssertions numberOfAssertionFailures Subroutines detachSharedAssertionsManager initializeSharedAssertionsManager finalizeSharedAssertionsManager FTAssert assertWithinToleranceTwoQuad Variables Type Visibility Attributes Name Initial integer, public, parameter :: FT_ASSERTION_STRING_LENGTH = 128 Interfaces public        interface FTAssertEqual private  subroutine assertEqualTwoIntegers(expectedValue, actualValue, msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expectedValue integer, intent(in) :: actualValue character(len=*), optional :: msg private  subroutine assertEqualTwoIntegerArrays1D(expectedValue, actualValue) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: expectedValue integer, intent(in), DIMENSION(:) :: actualValue private  subroutine assertEqualTwoIntegerArrays2D(expectedValue, actualValue) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:,:) :: expectedValue integer, intent(in), DIMENSION(:,:) :: actualValue private  subroutine assertWithinToleranceTwoReal(expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name real, intent(in) :: expectedValue real, intent(in) :: actualValue real, intent(in) :: tol character(len=*), optional :: msg private  subroutine assertWithinToleranceTwoRealArrays1D(expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(:) :: expectedValue real, intent(in), DIMENSION(:) :: actualValue real, intent(in) :: tol character(len=*), optional :: msg private  subroutine assertWithinToleranceTwoRealArrays2D(expectedValue, actualValue, tol) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(:,:) :: expectedValue real, intent(in), DIMENSION(:,:) :: actualValue real, intent(in) :: tol private  subroutine assertWithinToleranceTwoDouble(expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expectedValue double precision, intent(in) :: actualValue double precision, intent(in) :: tol character(len=*), optional :: msg private  subroutine assertWithinToleranceTwoDoubleArrays1D(expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(:) :: expectedValue double precision, intent(in), DIMENSION(:) :: actualValue double precision, intent(in) :: tol character(len=*), optional :: msg private  subroutine assertWithinToleranceTwoDoubleArrays2D(expectedValue, actualValue, tol) Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(:,:) :: expectedValue double precision, intent(in), DIMENSION(:,:) :: actualValue double precision, intent(in) :: tol public  subroutine assertWithinToleranceTwoQuad (expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: expectedValue real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: actualValue real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: tol character(len=*), optional :: msg private  subroutine assertEqualTwoLogicals(expectedValue, actualValue, msg) Arguments Type Intent Optional Attributes Name logical, intent(in) :: expectedValue logical, intent(in) :: actualValue character(len=*), optional :: msg private  subroutine assertEqualString(expectedValue, actualValue, msg) Arguments Type Intent Optional Attributes Name character(len=*) :: expectedValue character(len=*) :: actualValue character(len=*), optional :: msg Derived Types type, public :: FTAssertionsManager Type-Bound Procedures procedure\n                    ,                  public\n                  :: init Subroutine procedure\n                    ,                  public\n                  :: finalize Subroutine procedure\n                    ,                  public\n                  :: numberOfAssertionFailures Function procedure\n                    ,                  public\n                  :: numberOfAssertions Function procedure\n                    ,                  public\n                  :: summarizeAssertions Subroutine Functions public  function sharedAssertionsManager () Arguments None Return Value type( FTAssertionsManager ), POINTER public  function numberOfAssertions (self) Arguments Type Intent Optional Attributes Name class( FTAssertionsManager ) :: self Return Value integer public  function numberOfAssertionFailures (self) Arguments Type Intent Optional Attributes Name class( FTAssertionsManager ) :: self Return Value integer Subroutines public  subroutine detachSharedAssertionsManager () Arguments None public  subroutine initializeSharedAssertionsManager () Arguments None public  subroutine finalizeSharedAssertionsManager () Arguments None public  subroutine FTAssert (test, msg) Arguments Type Intent Optional Attributes Name logical :: test character(len=*), optional :: msg public  subroutine assertWithinToleranceTwoQuad (expectedValue, actualValue, tol, msg) Arguments Type Intent Optional Attributes Name real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: expectedValue real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: actualValue real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: tol character(len=*), optional :: msg","tags":"","loc":"module/ftassertions.html"},{"title":"ComparisonsModule – FTObjectLibrary","text":"Defines procedures that test equality of different kinds of arguments.\nProcedures defined here are USEd by the FTAssertions Module. Uses iso_fortran_env FTOLConstants module~~comparisonsmodule~~UsesGraph module~comparisonsmodule ComparisonsModule iso_fortran_env iso_fortran_env module~comparisonsmodule->iso_fortran_env module~ftolconstants FTOLConstants module~comparisonsmodule->module~ftolconstants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~comparisonsmodule~~UsedByGraph module~comparisonsmodule ComparisonsModule module~ftassertions FTAssertions module~ftassertions->module~comparisonsmodule module~ftobjectlibrary FTObjectLibrary module~ftobjectlibrary->module~comparisonsmodule module~ftobjectlibrary->module~ftassertions module~testsuitemanagerclass TestSuiteManagerClass module~ftobjectlibrary->module~testsuitemanagerclass module~testsuitemanagerclass->module~ftassertions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables ASSERT_SUCCESS ASSERT_SIZE_DIFFERS ASSERT_VALUES_DIFFER compareCodeStrings Interfaces isEqual Derived Types assertInfoArray1D assertInfoArray2D Variables Type Visibility Attributes Name Initial integer, public, parameter :: ASSERT_SUCCESS = 0 integer, public, parameter :: ASSERT_SIZE_DIFFERS = 1 integer, public, parameter :: ASSERT_VALUES_DIFFER = 2 character(len=21), public, parameter :: compareCodeStrings (0:2) = [ASSERT_VALUES_OK_NAME, ASSERT_SIZE_DIFFERS_NAME, ASSERT_VALUES_DIFFERS_NAME] Interfaces public        interface isEqual private  function isEqualTwoIntegers(i, j) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical private  function isEqualTwoIntegerArrays1D(a, b, info) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: a integer, intent(in), DIMENSION(:) :: b type( assertInfoArray1D ), intent(inout), optional :: info Return Value logical private  function isEqualTwoIntegerArrays2D(a, b, info) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:,:) :: a integer, intent(in), DIMENSION(:,:) :: b type( assertInfoArray2D ), intent(inout), optional :: info Return Value logical private  function isWithinToleranceTwoReal(x, y, tol) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: tol Return Value logical private  function isWithinToleranceTwoRealArrays1D(a, b, tol, code) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(:) :: a real, intent(in), DIMENSION(:) :: b real, intent(in) :: tol integer, intent(out), optional :: code Return Value logical private  function isWithinToleranceTwoRealArrays2D(a, b, tol, code) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(:,:) :: a real, intent(in), DIMENSION(:,:) :: b real, intent(in) :: tol integer, intent(out), optional :: code Return Value logical private  function isWithinToleranceTwoDouble(x, y, tol) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: tol Return Value logical private  function isWithinToleranceTwoDoubleArrays1D(a, b, tol, code) Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(:) :: a double precision, intent(in), DIMENSION(:) :: b double precision, intent(in) :: tol integer, intent(out), optional :: code Return Value logical private  function isWithinToleranceTwoDoubleArrays2D(a, b, tol, code) Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(:,:) :: a double precision, intent(in), DIMENSION(:,:) :: b double precision, intent(in) :: tol integer, intent(out), optional :: code Return Value logical private  function isEqualString(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*) :: s1 character(len=*) :: s2 Return Value logical private  function isWithinToleranceTwoQuad(x, y, tol) Arguments Type Intent Optional Attributes Name real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: x real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: y real(kind=SELECTED_REAL_KIND(QUAD_DIGITS)), intent(in) :: tol Return Value logical Derived Types type, public :: assertInfoArray1D Components Type Visibility Attributes Name Initial character(len=128), public :: failureName integer, public :: failureType logical, public, DIMENSION(:), ALLOCATABLE :: locations type, public :: assertInfoArray2D Components Type Visibility Attributes Name Initial character(len=128), public :: failureName integer, public :: failureType logical, public, DIMENSION(:,:), ALLOCATABLE :: locations","tags":"","loc":"module/comparisonsmodule.html"},{"title":"FTObjectLibrary.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftobjectlibrary.f90~~EfferentGraph sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~assert.f90 Assert.f90 sourcefile~ftobjectlibrary.f90->sourcefile~assert.f90 sourcefile~comparisons.f90 Comparisons.f90 sourcefile~ftobjectlibrary.f90->sourcefile~comparisons.f90 sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftobjectclass.f90 sourcefile~ftsparsematrixclass.f90 FTSparseMatrixClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftsparsematrixclass.f90 sourcefile~ftstackclass.f90 FTStackClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftstackclass.f90 sourcefile~ftvalueclass.f90 FTValueClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvalueclass.f90 sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~testsuitemanagerclass.f90 TestSuiteManagerClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~testsuitemanagerclass.f90 sourcefile~assert.f90->sourcefile~comparisons.f90 sourcefile~ftolconstants.f90 FTOLConstants.f90 sourcefile~assert.f90->sourcefile~ftolconstants.f90 sourcefile~comparisons.f90->sourcefile~ftolconstants.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectclass.f90 sourcefile~hash.f90 Hash.f90 sourcefile~ftdictionaryclass.f90->sourcefile~hash.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftstackclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftsparsematrixclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftsparsematrixclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftstackclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftvalueclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftvalueclass.f90->sourcefile~ftolconstants.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftvalueclass.f90 sourcefile~testsuitemanagerclass.f90->sourcefile~assert.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTObjectLibrary Source Code FTObjectLibrary.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      FTObjectLibrary.f90 !      Created: May 8, 2014 at 2:49 PM !      By: David Kopriva ! !//////////////////////////////////////////////////////////////////////// ! !>A module that simply USEs the entire library modules. !> Module FTObjectLibrary USE FTAssertions USE ComparisonsModule USE FTValueDictionaryClass USE TestSuiteManagerClass USE FTObjectClass USE FTDictionaryClass USE FTSparseMatrixClass USE FTMutableObjectArrayClass USE FTStackClass USE FTLinkedListClass USE FTLinkedListIteratorClass USE FTValueClass USE FTExceptionClass IMPLICIT NONE END MODULE FTObjectLibrary","tags":"","loc":"sourcefile/ftobjectlibrary.f90.html"},{"title":"Hash.f90 – FTObjectLibrary","text":"Files dependent on this one sourcefile~~hash.f90~~AfferentGraph sourcefile~hash.f90 Hash.f90 sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~hash.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftstringsetclass.f90 FTStringSetClass.f90 sourcefile~ftstringsetclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftdictionaryclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules HashModule Source Code Hash.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      hash !      Created: January 28, 2013 12:39 PM !      By: David Kopriva ! !      Code by Rich Townsend, 2005 !      See: https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng ! !//////////////////////////////////////////////////////////////////////// ! MODULE HashModule CONTAINS function b3hs_hash_key_jenkins ( key , range ) result ( code ) INTEGER , PARAMETER :: KIND_I32 = SELECTED_INT_KIND ( 10 ) character ( * ), intent ( in ) :: key integer , intent ( in ) :: range integer :: code integer :: len_key integer ( KIND_I32 ) :: a integer ( KIND_I32 ) :: b integer ( KIND_I32 ) :: c INTEGER :: c_i integer :: k ! Hash the key into a code, using the algorithm ! described by Bob Jenkins at: !  http://burtleburtle.net/bob/hash/doobs.html ! ! Note that range should be a power of 2, and ! that the 32-bit algorithm is used len_key = LEN_TRIM ( key ) a = - 1640531527_KIND_I32 ! 0x9E3779B9 b = a c = 305419896_KIND_I32 ! 0x12345678 k = 1 char_loop : do if ( len_key < 12 ) exit char_loop ! Pack the key into 32 bits a = a + ICHAR ( key ( k + 0 : k + 0 )) + ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + & & ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) b = b + ICHAR ( key ( k + 4 : k + 4 )) + ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + & & ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) c = c + ICHAR ( key ( k + 8 : k + 8 )) + ISHFT ( ICHAR ( key ( k + 9 : k + 9 )), 8 ) + & & ISHFT ( ICHAR ( key ( k + 10 : k + 10 )), 16 ) + ISHFT ( ICHAR ( key ( k + 11 : k + 11 )), 24 ) ! Mix it up call b3hs_hash_key_jenkins_mix_ () k = k + 12 len_key = len_key - 12 end do char_loop c = c + len_key ! Process remaining bits select case ( len_key ) case ( 11 ) c = c + ISHFT ( ICHAR ( key ( k + 10 : k + 10 )), 24 ) + ISHFT ( ICHAR ( key ( k + 9 : k + 9 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 8 : k + 8 )), 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 10 ) c = c + ISHFT ( ICHAR ( key ( k + 9 : k + 9 )), 16 ) + ISHFT ( ICHAR ( key ( k + 8 : k + 8 )), 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 9 ) c = c + ISHFT ( ICHAR ( key ( k + 8 : k + 8 )), 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 7 ) b = b + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + & & ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 6 ) b = b + ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 5 ) b = b + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 4 ) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 3 ) a = a + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + & & ICHAR ( key ( k : k )) case ( 2 ) a = a + ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 1 ) a = a + ICHAR ( key ( k : k )) end select call b3hs_hash_key_jenkins_mix_ () c_i = INT ( c ) code = IAND ( c_i , RANGE - 1 ) + 1 ! Finish return contains subroutine b3hs_hash_key_jenkins_mix_ ! Mix a, b and c a = IEOR ( a - b - c , ISHFT ( c , - 13 )) b = IEOR ( b - c - a , ISHFT ( a , 8 )) c = IEOR ( c - a - b , ISHFT ( b , - 13 )) a = IEOR ( a - b - c , ISHFT ( c , - 12 )) b = IEOR ( b - c - a , ISHFT ( a , 16 )) c = IEOR ( c - a - b , ISHFT ( b , - 5 )) a = IEOR ( a - b - c , ISHFT ( c , - 3 )) b = IEOR ( b - c - a , ISHFT ( a , 10 )) c = IEOR ( c - a - b , ISHFT ( b , - 15 )) ! Finish return end subroutine b3hs_hash_key_jenkins_mix_ end function b3hs_hash_key_jenkins END MODULE HashModule","tags":"","loc":"sourcefile/hash.f90.html"},{"title":"FTSparseMatrixClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftsparsematrixclass.f90~~EfferentGraph sourcefile~ftsparsematrixclass.f90 FTSparseMatrixClass.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftsparsematrixclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftsparsematrixclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ftsparsematrixclass.f90~~AfferentGraph sourcefile~ftsparsematrixclass.f90 FTSparseMatrixClass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftsparsematrixclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTSparseMatrixData FTSparseMatrixClass Source Code FTSparseMatrixClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      SparseMatrixClass.f90 !      Created: July 29, 2013 10:59 AM !      By: David Kopriva ! ! !//////////////////////////////////////////////////////////////////////// ! !>FTSparseMatrixData is used by the FTSparseMatrix Class. Users will !>usually not interact with or use this class directly. !> Module FTSparseMatrixData USE FTObjectClass IMPLICIT NONE ! !     --------------- !     Type definition !     --------------- ! TYPE , EXTENDS ( FTObject ) :: MatrixData INTEGER :: key CLASS ( FTObject ), POINTER :: object ! !        ======== CONTAINS !        ======== ! PROCEDURE :: initWithObjectAndKey FINAL :: destructMatrixData END TYPE MatrixData INTERFACE cast MODULE PROCEDURE castObjectToMatrixData END INTERFACE cast ! !     ======== CONTAINS !     ======== ! ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithObjectAndKey ( self , object , key ) ! !        ---------------------- !        Designated initializer !        ---------------------- ! IMPLICIT NONE CLASS ( MatrixData ) :: self CLASS ( FTObject ), POINTER :: object INTEGER :: key CALL self % FTObject % init () self % key = key self % object => object CALL self % object % retain () END SUBROUTINE initWithObjectAndKey ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTMatrixData ( self ) IMPLICIT NONE TYPE ( MatrixData ), POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTMatrixData ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructMatrixData ( self ) IMPLICIT NONE TYPE ( MatrixData ) :: self IF ( ASSOCIATED ( self % object ) ) THEN CALL releaseFTObject ( self = self % object ) END IF END SUBROUTINE destructMatrixData ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE castObjectToMatrixData ( obj , cast ) IMPLICIT NONE ! !        ----------------------------------------------------- !        Cast the base class FTObject to the FTException class !        ----------------------------------------------------- ! CLASS ( FTObject ) , POINTER :: obj CLASS ( MatrixData ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( MatrixData ) cast => e CLASS DEFAULT END SELECT END SUBROUTINE castObjectToMatrixData ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION matrixDataCast ( obj ) RESULT ( cast ) IMPLICIT NONE ! !        ----------------------------------------------------- !        Cast the base class FTObject to the FTException class !        ----------------------------------------------------- ! CLASS ( FTObject ) , POINTER :: obj CLASS ( MatrixData ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( MatrixData ) cast => e CLASS DEFAULT END SELECT END FUNCTION matrixDataCast END Module FTSparseMatrixData !@mark - !>The sparse matrix stores an FTObject pointer associated !>with two keys (i,j) as a hash table. !> !>Hash tables are data structures designed to enable storage and fast !>retrieval of key-value pairs. An example of a key-value pair is !>a variable name (``gamma'') and its associated value (``1.4''). !>The table itself is typically an array. !>The location of the value in a hash table associated with !>a key, $k$, is specified by way of a hash function, $H(k)$. !>In the case of a variable name and value, the hash function !>would convert the name into an integer that tells where to !>find the associated value in the table. !> !>A very simple example of a !>hash table is, in fact, a singly dimensioned array. The key is !>the array index and the value is what is stored at that index. !>Multiple keys can be used to identify data; a two dimensional !>array provides an example of where two keys are used to access memory !>and retrieve the value at that location. !>If we view a singly dimensioned array as a special case of a hash table, !>its hash function is just the array index, $H(j)=j$. A doubly dimensioned array !>could be (and often is) stored columnwise as a singly dimensioned array by creating a hash !>function that maps the two indices to a single location in the array, e.g., !>$H(i,j) = i + j*N$, where $N$ is the range of the first index, $i$. !> !>Two classes are included in FTObjectLibrary. The first, FTSparseMatrix, works with an ordered pair, (i,j), as the !>keys. The second, FTMultiIndexTable, uses an array of integers as the keys. !> !>Both classes include enquiry functions to see of an object exists for the given keys. Otherwise, !>the function that returns an object for a given key will return an UNASSOCIATED pointer if there !>is no object for the key. Be sure to retain any object returned by the objectForKeys methods if !>you want to keep it beyond the lifespan of the matrix or table. For example, !> !>           TYPE(FTObject) :: obj !>           obj => matrix % objectForKeys(i,j) !>           IF ( ASSOCIATED(OBJ) ) THEN !>               CALL obj % retain() !>                 Cast obj to something useful !>           ELSE !>              Perform some kind of error recovery !>           END IF !>The sparse matrix stores an FTObject pointer associated !>with two keys (i,j) as a hash table. The size, N = the range of i. !> !>##Definition (Subclass of FTObject) !> !>         TYPE(FTSparseMatrix) :: SparseMatrix !>#Usage !>##Initialization !> !>         CALL SparseMatrix % initWithSize(N) !> !>##Destruction !> !>         CALL releaseFTSparseMatrix(SparseMatrix) [Pointers] !> !>##Adding an object !> !>         CLASS(FTObject), POINTER :: obj !>         CALL SparseMatrix % addObjectForKeys(obj,i,j) !> !>##Retrieving an object !> !>         CLASS(FTObject), POINTER :: obj !>         obj => SparseMatrix % objectForKeys(i,j) !> !>Be sure to retain the object if you want it to live !>      beyond the life of the table. !> !>##Testing the presence of keys !> !>         LOGICAL :: exists !>         exists = SparseMatrix % containsKeys(i,j) ! !//////////////////////////////////////////////////////////////////////// ! Module FTSparseMatrixClass USE FTObjectClass USE FTLinkedListClass USE FTLinkedListIteratorClass USE FTSparseMatrixData IMPLICIT NONE ! !     ---------------------- !     Class type definitions !     ---------------------- ! TYPE FTLinkedListPtr CLASS ( FTLinkedList ), POINTER :: list END TYPE FTLinkedListPtr PRIVATE :: FTLinkedListPtr TYPE , EXTENDS ( FTObject ) :: FTSparseMatrix TYPE ( FTLinkedListPtr ) , DIMENSION (:), ALLOCATABLE :: table TYPE ( FTLinkedListIterator ), PRIVATE :: iterator ! !        ======== CONTAINS !        ======== ! PROCEDURE :: initWithSize => initSparseMatrixWithSize FINAL :: destructSparseMatrix PROCEDURE :: containsKeys => SparseMatrixContainsKeys PROCEDURE :: addObjectForKeys => addObjectToSparseMatrixForKeys PROCEDURE :: objectForKeys => objectInSparseMatrixForKeys PROCEDURE :: SparseMatrixSize END TYPE FTSparseMatrix ! !     ======== CONTAINS !     ======== ! ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initSparseMatrixWithSize ( self , N ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTSparseMatrix ) :: self INTEGER :: N ! !        --------------- !        Local variables !        --------------- ! INTEGER :: j CALL self % FTObject % init () ALLOCATE ( self % table ( N )) DO j = 1 , N ALLOCATE ( self % table ( j ) % list ) CALL self % table ( j ) % list % init () END DO CALL self % iterator % init () END SUBROUTINE initSparseMatrixWithSize ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addObjectToSparseMatrixForKeys ( self , obj , i , j ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTSparseMatrix ) :: self CLASS ( FTObject ), POINTER :: obj ! !        --------------- !        Local variables !        --------------- ! CLASS ( MatrixData ), POINTER :: mData CLASS ( FTObject ) , POINTER :: ptr INTEGER :: i , j IF ( . NOT . self % containsKeys ( i , j ) ) THEN ALLOCATE ( mData ) CALL mData % initWithObjectAndKey ( obj , j ) ptr => mData CALL self % table ( i ) % list % add ( ptr ) CALL releaseFTObject ( ptr ) END IF END SUBROUTINE addObjectToSparseMatrixForKeys ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION objectInSparseMatrixForKeys ( self , i , j ) RESULT ( r ) ! !     --------------------------------------------------------------- !     Returns the stored FTObject for the keys (i,j). Returns NULL() !     if the object isn't in the table. Retain the object if it needs !     a strong reference by the caller. !     --------------------------------------------------------------- ! IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTSparseMatrix ) :: self INTEGER :: i , j CLASS ( FTObject ), POINTER :: r ! !        --------------- !        Local variables !        --------------- ! CLASS ( MatrixData ) , POINTER :: mData CLASS ( FTObject ) , POINTER :: obj CLASS ( FTLinkedList ), POINTER :: list r => NULL () IF (. NOT . ALLOCATED ( self % table )) RETURN list => self % table ( i ) % list IF (. NOT . ASSOCIATED ( list )) RETURN IF ( list % COUNT () == 0 ) RETURN ! !        ---------------------------- !        Step through the linked list !        ---------------------------- ! r => NULL () CALL self % iterator % setLinkedList ( self % table ( i ) % list ) DO WHILE (. NOT . self % iterator % isAtEnd ()) obj => self % iterator % object () CALL cast ( obj , mData ) IF ( mData % key == j ) THEN r => mData % object EXIT END IF CALL self % iterator % moveToNext () END DO END FUNCTION objectInSparseMatrixForKeys ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION SparseMatrixContainsKeys ( self , i , j ) RESULT ( r ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTSparseMatrix ) :: self INTEGER :: i , j LOGICAL :: r ! !        --------------- !        Local variables !        --------------- ! CLASS ( FTObject ) , POINTER :: obj CLASS ( MatrixData ) , POINTER :: mData CLASS ( FTLinkedList ), POINTER :: list r = . FALSE . IF (. NOT . ALLOCATED ( self % table )) RETURN IF (. NOT . ASSOCIATED ( self % table ( i ) % list )) RETURN IF ( self % table ( i ) % list % COUNT () == 0 ) RETURN ! !        ---------------------------- !        Step through the linked list !        ---------------------------- ! list => self % table ( i ) % list CALL self % iterator % setLinkedList ( list ) CALL self % iterator % setToStart () DO WHILE (. NOT . self % iterator % isAtEnd ()) obj => self % iterator % object () CALL cast ( obj , mData ) IF ( mData % key == j ) THEN r = . TRUE . RETURN END IF CALL self % iterator % moveToNext () END DO END FUNCTION SparseMatrixContainsKeys ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTSparseMatrix ( self ) IMPLICIT NONE TYPE ( FTSparseMatrix ), POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTSparseMatrix ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructSparseMatrix ( self ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! TYPE ( FTSparseMatrix ) :: self ! !        --------------- !        Local variables !        --------------- ! INTEGER :: j IF ( ALLOCATED ( self % table )) THEN DO j = 1 , SIZE ( self % table ) IF ( ASSOCIATED ( self % table ( j ) % list ) ) THEN CALL releaseSMMemberList ( list = self % table ( j ) % list ) END IF END DO END IF IF ( ALLOCATED ( self % table )) DEALLOCATE ( self % table ) END SUBROUTINE destructSparseMatrix ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseSMMemberList ( list ) IMPLICIT NONE CLASS ( FTLinkedList ), POINTER :: list CLASS ( FTObject ) , POINTER :: obj obj => list CALL releaseFTObject ( self = obj ) IF (. NOT . ASSOCIATED ( obj )) list => NULL () END SUBROUTINE releaseSMMemberList ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION SparseMatrixSize ( self ) IMPLICIT NONE CLASS ( FTSparseMatrix ) :: self IF ( ALLOCATED ( self % table ) ) THEN SparseMatrixSize = SIZE ( self % table ) ELSE SparseMatrixSize = 0 END IF END FUNCTION SparseMatrixSize ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION SparseMatrixFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTSparseMatrix ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTSparseMatrix ) cast => e CLASS DEFAULT END SELECT END FUNCTION SparseMatrixFromObject ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION Hash1 ( idPair ) INTEGER , DIMENSION ( 2 ) :: idPair Hash1 = MAXVAL ( idPair ) END FUNCTION Hash1 ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION Hash2 ( idPair ) INTEGER , DIMENSION ( 2 ) :: idPair Hash2 = MINVAL ( idPair ) END FUNCTION Hash2 END Module FTSparseMatrixClass","tags":"","loc":"sourcefile/ftsparsematrixclass.f90.html"},{"title":"FTStackClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftstackclass.f90~~EfferentGraph sourcefile~ftstackclass.f90 FTStackClass.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftstackclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ftstackclass.f90~~AfferentGraph sourcefile~ftstackclass.f90 FTStackClass.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftstackclass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftstackclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTStackClass Source Code FTStackClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      FTStackClass.f90 !      Created: January 25, 2013 12:56 PM !      By: David Kopriva ! !>Inherits from FTLinkedListClass : FTObjectClass !> !>##Definition (Subclass of FTLinkedListClass): !>   TYPE(FTStack) :: list !> !>#Usage: !> !>##Initialization !> !>      ALLOCATE(stack)  If stack is a pointer !>      CALL stack  %  init() !> !>##Destruction !>      CALL releaseFTStack(stack) [Pointers] !> !>##Pushing an object onto the stack !> !>      TYPE(FTObject) :: objectPtr !>      objectPtr => r1 !>      CALL stack % push(objectPtr) !> !>##Peeking at the top of the stack !> !>      objectPtr => stack % peek()  No change of ownership !>      SELECT TYPE(objectPtr) !>         TYPE is (*SubclassType*) !>            … Do something with ObjectPtr as subclass !>         CLASS DEFAULT !>            … Problem with casting !>      END SELECT !> !>##Popping the top of the stack !> !>      objectPtr => stack % pop()  Ownership transferred to caller !>      SELECT TYPE(objectPtr) !>         TYPE is (*SubclassType*) !>            … Do something with ObjectPtr as subclass !>         CLASS DEFAULT !>            … Problem with casting !>      END SELECT ! !//////////////////////////////////////////////////////////////////////// ! Module FTStackClass USE FTLinkedListClass IMPLICIT NONE TYPE , EXTENDS ( FTLinkedList ) :: FTStack ! !        ======== CONTAINS !        ======== ! PROCEDURE :: init => initFTStack PROCEDURE :: printDescription => printStackDescription PROCEDURE :: className => stackClassName PROCEDURE :: push PROCEDURE :: pop PROCEDURE :: peek END TYPE FTStack ! !     ---------- !     Procedures !     ---------- ! !     ======== CONTAINS !     ======== ! ! !------------------------------------------------ !> Public, generic name: init() !> !> Initialize the stack. !------------------------------------------------ ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initFTStack ( self ) IMPLICIT NONE CLASS ( FTStack ) :: self ! !        -------------------------------------------- !        Call the initializer of the superclass first !        -------------------------------------------- ! CALL self % FTLinkedList % init () ! !        --------------------------------- !        Then initialize ivars of subclass !        --------------------------------- ! !None to intialize END SUBROUTINE initFTStack ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTStack ( self ) IMPLICIT NONE TYPE ( FTStack ) , POINTER :: self CLASS ( FTObject ), POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTStack ! !     ----------------------------------- !     push: Push an object onto the stack !     ----------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE push ( self , obj ) ! !        ---------------------------------- !        Add object to the head of the list !        ---------------------------------- ! IMPLICIT NONE CLASS ( FTStack ) :: self CLASS ( FTObject ) , POINTER :: obj CLASS ( FTLinkedListRecord ), POINTER :: newRecord => NULL () CLASS ( FTLinkedListRecord ), POINTER :: tmp => NULL () ALLOCATE ( newRecord ) CALL newRecord % initWithObject ( obj ) IF ( . NOT . ASSOCIATED ( self % head ) ) THEN self % head => newRecord self % tail => newRecord ELSE tmp => self % head self % head => newRecord self % head % next => tmp tmp % previous => newRecord END IF self % nRecords = self % nRecords + 1 END SUBROUTINE push ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION peek ( self ) ! !        ----------------------------------------- !        Return the object at the head of the list !        ** No change of ownership ** !        ----------------------------------------- ! IMPLICIT NONE CLASS ( FTStack ) :: self CLASS ( FTObject ), POINTER :: peek IF ( . NOT . ASSOCIATED ( self % head ) ) THEN peek => NULL () RETURN END IF peek => self % head % recordObject END FUNCTION peek ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE pop ( self , p ) ! !        --------------------------------------------------- !        Remove the head of the list and return the object !        that it points to. Calling routine gains ownership !        of the object. !        --------------------------------------------------- ! IMPLICIT NONE CLASS ( FTStack ) :: self CLASS ( FTObject ) , POINTER :: p , obj CLASS ( FTLinkedListRecord ), POINTER :: tmp => NULL () IF ( . NOT . ASSOCIATED ( self % head ) ) THEN p => NULL () RETURN END IF p => self % head % recordObject IF (. NOT . ASSOCIATED ( p )) RETURN CALL p % retain () tmp => self % head self % head => self % head % next obj => tmp CALL release ( obj ) self % nRecords = self % nRecords - 1 END SUBROUTINE pop ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION stackFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the LinkedList class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ), POINTER :: obj CLASS ( FTStack ) , POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTStack ) cast => e CLASS DEFAULT END SELECT END FUNCTION stackFromObject ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE printStackDescription ( self , iUnit ) IMPLICIT NONE CLASS ( FTStack ) :: self INTEGER :: iUnit CALL self % FTLinkedList % printDescription ( iUnit = iUnit ) END SUBROUTINE printStackDescription ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTStack\") !> FUNCTION stackClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTStack ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s IF ( self % refCount () . ge . 0 ) CONTINUE s = \"FTStack\" END FUNCTION stackClassName END Module FTStackClass","tags":"","loc":"sourcefile/ftstackclass.f90.html"},{"title":"FTMultiIndexTable.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftmultiindextable.f90~~EfferentGraph sourcefile~ftmultiindextable.f90 FTMultiIndexTable.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftmultiindextable.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftmultiindextable.f90->sourcefile~ftobjectclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTMultiIndexTableData FTMultiIndexTableClass Source Code FTMultiIndexTable.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      MultiIndexTableClass.f90 !      Created: July 29, 2013 10:59 AM !      By: David Kopriva ! ! !//////////////////////////////////////////////////////////////////////// ! Module FTMultiIndexTableData USE FTObjectClass IMPLICIT NONE ! !     --------------- !     Type definition !     --------------- ! TYPE , EXTENDS ( FTObject ) :: MultiIndexMatrixData INTEGER , ALLOCATABLE :: key (:) CLASS ( FTObject ), POINTER :: object ! !        ======== CONTAINS !        ======== ! PROCEDURE :: initWithObjectAndKeys FINAL :: destructMultiIndexMatrixData END TYPE MultiIndexMatrixData INTERFACE cast MODULE PROCEDURE castObjectToMultiIndexMatrixData END INTERFACE cast ! !     ======== CONTAINS !     ======== ! ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithObjectAndKeys ( self , object , key ) ! !        ---------------------- !        Designated initializer !        ---------------------- ! IMPLICIT NONE CLASS ( MultiIndexMatrixData ) :: self CLASS ( FTObject ), POINTER :: object INTEGER :: key (:) CALL self % FTObject % init () ALLOCATE ( self % key ( SIZE ( key ))) self % key = key self % object => object CALL self % object % retain () END SUBROUTINE initWithObjectAndKeys ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTMultiIndexMatrixData ( self ) IMPLICIT NONE TYPE ( MultiIndexMatrixData ), POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTMultiIndexMatrixData ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructMultiIndexMatrixData ( self ) IMPLICIT NONE TYPE ( MultiIndexMatrixData ) :: self IF ( ASSOCIATED ( self % object ) ) CALL releaseFTObject ( self % object ) IF ( ALLOCATED ( self % key ) ) DEALLOCATE ( self % key ) END SUBROUTINE destructMultiIndexMatrixData ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE castObjectToMultiIndexMatrixData ( obj , cast ) IMPLICIT NONE ! !        ----------------------------------------------------- !        Cast the base class FTObject to the FTException class !        ----------------------------------------------------- ! CLASS ( FTObject ) , POINTER :: obj CLASS ( MultiIndexMatrixData ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( MultiIndexMatrixData ) cast => e CLASS DEFAULT END SELECT END SUBROUTINE castObjectToMultiIndexMatrixData ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION MultiIndexMatrixDataCast ( obj ) RESULT ( cast ) IMPLICIT NONE ! !        ----------------------------------------------------- !        Cast the base class FTObject to the FTException class !        ----------------------------------------------------- ! CLASS ( FTObject ) , POINTER :: obj CLASS ( MultiIndexMatrixData ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( MultiIndexMatrixData ) cast => e CLASS DEFAULT END SELECT END FUNCTION MultiIndexMatrixDataCast END Module FTMultiIndexTableData !@mark - !>The MultiIndexTable stores an FTObject pointer associated !>with any number of integer keys(:) as a hash table. !> !>#Usage !>## Definition (Subclass of FTObject) !> !>         TYPE(FTMultiIndexTable) :: multiIndexTable !> !>##Initialization !> !>         CALL MultiIndexTable % initWithSize(N) !> !>The size, N = the maximum value of all of the keys. !> !>## Destruction !> !>         CALL releaseFTMultiIndexTable(MultiIndexTable)     [Pointers] !> !>##Adding an object !> !>         CLASS(FTObject), POINTER :: obj !>         INTEGER, DIMENSION(dim)  :: keys !>         CALL MultiIndexTable % addObjectForKeys(obj,keys) !> !>##Retrieving an object !> !>         CLASS(FTObject), POINTER :: obj !>         INTEGER, DIMENSION(dim)  :: keys !>         obj => MultiIndexTable % objectForKeys(keys) !> !>Be sure to retain the object if you want it to live !>      beyond the life of the table. !> !>##Testing the presence of keys !> !>         LOGICAL :: exists !>         exists = MultiIndexTable % containsKeys(keys) ! !//////////////////////////////////////////////////////////////////////// ! Module FTMultiIndexTableClass USE FTObjectClass USE FTLinkedListClass USE FTMultiIndexTableData IMPLICIT NONE ! !     --------------------- !     Class type definition !     --------------------- ! TYPE , EXTENDS ( FTObject ) :: FTMultiIndexTable CLASS ( FTLinkedList ), DIMENSION (:), ALLOCATABLE :: table ! !        ======== CONTAINS !        ======== ! PROCEDURE :: initWithSize => initMultiIndexTableWithSize FINAL :: destructMultiIndexTable PROCEDURE :: containsKeys => MultiIndexTableContainsKeys PROCEDURE :: addObjectForKeys => addObjectToMultiIndexTableForKeys PROCEDURE :: objectForKeys => objectInMultiIndexTableForKeys PROCEDURE :: printDescription => printMultiIndexTableDescription PROCEDURE :: MultiIndexTableSize END TYPE FTMultiIndexTable ! !     ======== CONTAINS !     ======== ! ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initMultiIndexTableWithSize ( self , N ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTMultiIndexTable ) :: self INTEGER :: N ! !        --------------- !        Local variables !        --------------- ! INTEGER :: j CALL self % FTObject % init () ALLOCATE ( self % table ( N )) DO j = 1 , N CALL self % table ( j ) % init () END DO END SUBROUTINE initMultiIndexTableWithSize ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTMultiIndexTable ( self ) IMPLICIT NONE TYPE ( FTMultiIndexTable ), POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTMultiIndexTable ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructMultiIndexTable ( self ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! TYPE ( FTMultiIndexTable ) :: self ! !        --------------- !        Local variables !        --------------- ! IF ( ALLOCATED ( self % table )) THEN DEALLOCATE ( self % table ) END IF END SUBROUTINE destructMultiIndexTable ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addObjectToMultiIndexTableForKeys ( self , obj , keys ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTMultiIndexTable ) :: self CLASS ( FTObject ), POINTER :: obj INTEGER :: keys (:) ! !        --------------- !        Local variables !        --------------- ! CLASS ( MultiIndexMatrixData ), POINTER :: mData CLASS ( FTObject ) , POINTER :: ptr INTEGER :: i INTEGER :: orderedKeys ( SIZE ( keys )) orderedKeys = keys CALL sortKeysAscending ( orderedKeys ) i = orderedKeys ( 1 ) IF ( . NOT . self % containsKeys ( orderedKeys ) ) THEN ALLOCATE ( mData ) CALL mData % initWithObjectAndKeys ( obj , orderedKeys ) ptr => mData CALL self % table ( i ) % add ( ptr ) CALL releaseFTObject ( ptr ) END IF END SUBROUTINE addObjectToMultiIndexTableForKeys ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION objectInMultiIndexTableForKeys ( self , keys ) RESULT ( r ) ! !     --------------------------------------------------------------- !     Returns the stored FTObject for the keys (i,j). Returns NULL() !     if the object isn't in the table. Retain the object if it needs !     a strong reference by the caller. !     --------------------------------------------------------------- ! IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTMultiIndexTable ) :: self INTEGER :: keys (:) CLASS ( FTObject ), POINTER :: r ! !        --------------- !        Local variables !        --------------- ! CLASS ( MultiIndexMatrixData ) , POINTER :: mData CLASS ( FTObject ) , POINTER :: obj CLASS ( FTLinkedListRecord ) , POINTER :: currentRecord INTEGER :: i INTEGER :: orderedKeys ( SIZE ( keys )) orderedKeys = keys CALL sortKeysAscending ( orderedKeys ) r => NULL () i = orderedKeys ( 1 ) IF (. NOT . ALLOCATED ( self % table )) RETURN IF ( self % table ( i ) % COUNT () == 0 ) RETURN ! !        ---------------------------- !        Step through the linked list !        ---------------------------- ! r => NULL () currentRecord => self % table ( i ) % head DO WHILE ( ASSOCIATED ( currentRecord )) obj => currentRecord % recordObject CALL cast ( obj , mData ) IF ( keysMatch ( key1 = mData % key , key2 = orderedKeys ) ) THEN r => mData % object EXIT END IF currentRecord => currentRecord % next END DO END FUNCTION objectInMultiIndexTableForKeys ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION MultiIndexTableContainsKeys ( self , keys ) RESULT ( r ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTMultiIndexTable ) :: self INTEGER :: keys (:) LOGICAL :: r ! !        --------------- !        Local variables !        --------------- ! CLASS ( FTObject ) , POINTER :: obj CLASS ( MultiIndexMatrixData ) , POINTER :: mData CLASS ( FTLinkedListRecord ) , POINTER :: currentRecord INTEGER :: i INTEGER :: orderedKeys ( SIZE ( keys )) orderedKeys = keys CALL sortKeysAscending ( orderedKeys ) r = . FALSE . i = orderedKeys ( 1 ) IF (. NOT . ALLOCATED ( self % table )) RETURN IF ( self % table ( i ) % COUNT () == 0 ) RETURN ! !        ---------------------------- !        Step through the linked list !        ---------------------------- ! currentRecord => self % table ( i ) % head DO WHILE ( ASSOCIATED ( currentRecord )) obj => currentRecord % recordObject CALL cast ( obj , mData ) IF ( keysMatch ( key1 = mData % key , key2 = orderedKeys )) THEN r = . TRUE . EXIT END IF currentRecord => currentRecord % next END DO END FUNCTION MultiIndexTableContainsKeys ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION MultiIndexTableSize ( self ) IMPLICIT NONE CLASS ( FTMultiIndexTable ) :: self IF ( ALLOCATED ( self % table ) ) THEN MultiIndexTableSize = SIZE ( self % table ) ELSE MultiIndexTableSize = 0 END IF END FUNCTION MultiIndexTableSize ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION MultiIndexTableFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTMultiIndexTable ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTMultiIndexTable ) cast => e CLASS DEFAULT END SELECT END FUNCTION MultiIndexTableFromObject ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION keysMatch ( key1 , key2 ) IMPLICIT NONE INTEGER , DIMENSION (:) :: key1 , key2 INTEGER :: match keysMatch = . FALSE . match = MAXVAL ( ABS ( key1 - key2 )) IF ( match == 0 ) keysMatch = . TRUE . END FUNCTION keysMatch ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE sortKeysAscending ( keys ) ! !     ---------------------------------------------------- !     Use an insertion sort for the keys, since the number !     of them should be small !     ---------------------------------------------------- ! IMPLICIT NONE INTEGER , DIMENSION (:) :: keys INTEGER :: i , j , N , t N = SIZE ( keys ) SELECT CASE ( N ) CASE ( 1 ) return CASE ( 2 ) IF ( keys ( 1 ) > keys ( 2 ) ) THEN t = keys ( 1 ) keys ( 1 ) = keys ( 2 ) keys ( 2 ) = t END IF CASE DEFAULT DO i = 2 , N t = keys ( i ) j = i DO WHILE ( j > 1 . AND . keys ( j - 1 ) > t ) keys ( j ) = keys ( j - 1 ) j = j - 1 IF ( j == 1 ) EXIT END DO keys ( j ) = t END DO END SELECT END SUBROUTINE sortKeysAscending ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE printMultiIndexTableDescription ( self , iUnit ) IMPLICIT NONE CLASS ( FTMultiIndexTable ) :: self INTEGER :: iUnit INTEGER :: i DO i = 1 , SIZE ( self % table ) CALL self % table ( i ) % printDescription ( iUnit ) END DO END SUBROUTINE printMultiIndexTableDescription END Module FTMultiIndexTableClass","tags":"","loc":"sourcefile/ftmultiindextable.f90.html"},{"title":"FTDataClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftdataclass.f90~~EfferentGraph sourcefile~ftdataclass.f90 FTDataClass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftdataclass.f90->sourcefile~ftobjectclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTDataClass Source Code FTDataClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      FTDataClass.f90 !      Created: July 11, 2013 2:00 PM !      By: David Kopriva ! !>FTData defines a subclass of FTObject to contain immutable !>generic data, including derived types. !> !>The initializer !>copies the data and takes ownership of that copy. FTData !>gives a way to use derived types without having to subclass !>FTObject. ! !//////////////////////////////////////////////////////////////////////// ! Module FTDataClass USE FTObjectClass IMPLICIT NONE ! !     --------- !     Constants !     --------- ! INTEGER , PARAMETER :: DATA_CLASS_TYPE_LENGTH = 32 ! !     --------------------- !     Class type definition !     --------------------- ! TYPE , EXTENDS ( FTObject ) :: FTData PRIVATE CHARACTER ( LEN = DATA_CLASS_TYPE_LENGTH ) :: dataType CHARACTER ( LEN = 1 ), POINTER :: dataStorage (:) INTEGER :: dataSize ! !        ======== CONTAINS !        ======== ! PROCEDURE , PUBLIC :: initWithDataOfType PROCEDURE , PUBLIC :: storedData PROCEDURE , PUBLIC :: storedDataSize PROCEDURE , PUBLIC :: className => dataClassName FINAL :: destructData END TYPE FTData CONTAINS ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithDataOfType ( self , genericData , dataType ) IMPLICIT NONE CLASS ( FTData ) :: self CHARACTER ( LEN =* ) :: dataType CHARACTER ( LEN = 1 ) :: genericData (:) INTEGER :: dataSize CALL self % FTObject % init () dataSize = SIZE ( genericData ) ALLOCATE ( self % dataStorage ( dataSize )) self % dataStorage = genericData self % dataType = dataType self % dataSize = dataSize END SUBROUTINE initWithDataOfType ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructData ( self ) IMPLICIT NONE TYPE ( FTData ) :: self DEALLOCATE ( self % dataStorage ) END SUBROUTINE destructData ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTData ( self ) IMPLICIT NONE TYPE ( FTData ) , POINTER :: self CLASS ( FTObject ), POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTData !@mark - ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION storedData ( self ) RESULT ( d ) IMPLICIT NONE CLASS ( FTData ) :: self CHARACTER ( LEN = 1 ), POINTER :: d (:) d => self % dataStorage END FUNCTION storedData ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION storedDataSize ( self ) IMPLICIT NONE CLASS ( FTData ) :: self storedDataSize = self % dataSize END FUNCTION storedDataSize ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION dataType ( self ) RESULT ( t ) IMPLICIT NONE CLASS ( FTData ) :: self CHARACTER ( LEN = DATA_CLASS_TYPE_LENGTH ) :: t t = self % dataType END FUNCTION dataType ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION dataFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTData ) , POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTData ) cast => e CLASS DEFAULT END SELECT END FUNCTION dataFromObject ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTData\") !> FUNCTION dataClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTData ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTData\" IF ( self % refCount () >= 0 ) CONTINUE END FUNCTION dataClassName ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION dataIsOfType ( self , dataType ) RESULT ( t ) IMPLICIT NONE CLASS ( FTData ) :: self CHARACTER ( LEN = DATA_CLASS_TYPE_LENGTH ) :: dataType LOGICAL :: t IF ( dataType == self % dataType ) THEN t = . TRUE . ELSE t = . FALSE . END IF END FUNCTION dataIsOfType END Module FTDataClass","tags":"","loc":"sourcefile/ftdataclass.f90.html"},{"title":"FTLinkedListClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftlinkedlistclass.f90~~EfferentGraph sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ftlinkedlistclass.f90~~AfferentGraph sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftstackclass.f90 FTStackClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftstackclass.f90 sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftmultiindextable.f90 FTMultiIndexTable.f90 sourcefile~ftmultiindextable.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 sourcefile~ftsparsematrixclass.f90 FTSparseMatrixClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftsparsematrixclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftstackclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftsparsematrixclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftstackclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftstringsetclass.f90 FTStringSetClass.f90 sourcefile~ftstringsetclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftdictionaryclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTLinkedListRecordClass FTLinkedListClass FTLinkedListIteratorClass Source Code FTLinkedListClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      FTLinkedListClass.f90 !      Created: January 7, 2013 2:56 PM !      By: David Kopriva ! ! ! !//////////////////////////////////////////////////////////////////////// ! !@mark - ! !>FTLinkedListRecord is the record type (object and next) for the !>LinkedList class. !> !>One will generally not instantiate a record oneself. They are !>created automatically when one adds an object to a linked list. !> Module FTLinkedListRecordClass USE FTObjectClass IMPLICIT NONE ! !     ----------------------------- !     Record class for linked lists !     ----------------------------- ! TYPE , EXTENDS ( FTObject ) :: FTLinkedListRecord CLASS ( FTObject ) , POINTER :: recordObject => NULL () CLASS ( FTLinkedListRecord ), POINTER :: next => NULL (), previous => NULL () ! !        ======== CONTAINS !        ======== ! PROCEDURE :: initWithObject FINAL :: destructFTLinkedListRecord PROCEDURE :: printDescription => printFTLinkedRecordDescription PROCEDURE :: className => llRecordClassName END TYPE FTLinkedListRecord ! !     ---------- !     Procedures !     ---------- ! CONTAINS ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithObject ( self , obj ) IMPLICIT NONE CLASS ( FTLinkedListRecord ) :: self CLASS ( FTObject ), POINTER :: obj ! !        ------------------------------- !        Always call the superclass init !        ------------------------------- ! CALL self % FTObject % init () ! !        ------------------------ !        Subclass initializations !        ------------------------ ! CALL obj % retain () self % recordObject => obj self % next => NULL () self % previous => NULL () END SUBROUTINE initWithObject ! !//////////////////////////////////////////////////////////////////////// ! !< The destructor must only be called from within subclass destructors ! SUBROUTINE destructFTLinkedListRecord ( self ) IMPLICIT NONE TYPE ( FTLinkedListRecord ) :: self IF ( ASSOCIATED ( self % recordObject ) ) CALL releaseFTObject ( self % recordObject ) self % next => NULL () self % previous => NULL () END SUBROUTINE destructFTLinkedListRecord ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTLinkedListRecord ( self ) IMPLICIT NONE TYPE ( FTLinkedListRecord ), POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTLinkedListRecord ! !//////////////////////////////////////////////////////////////////////// ! RECURSIVE SUBROUTINE printFTLinkedRecordDescription ( self , iUnit ) IMPLICIT NONE CLASS ( FTLinkedListRecord ) :: self INTEGER :: iUnit IF ( ASSOCIATED ( self % recordObject ) ) THEN CALL self % recordObject % printDescription ( iUnit ) END IF END SUBROUTINE printFTLinkedRecordDescription ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTLinkedListRecord\") !> FUNCTION llRecordClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTLinkedListRecord ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTLinkedListRecord\" END FUNCTION llRecordClassName END MODULE FTLinkedListRecordClass !@mark - ! ! !     -------------------------------------------------- !     Implements the basics of a linked list of objects !     -------------------------------------------------- ! !> !>FTLinkedList is a container class that stores objects in a linked list. !> !>Inherits from FTObjectClass !> !>##Definition (Subclass of FTObject): !> !>         TYPE(FTLinkedList) :: list !> !>#Usage: !> !>##Initialization !> !>         CLASS(FTLinkedList), POINTER :: list !>         ALLOCATE(list) !>         CALL list % init !> !>##Adding objects !> !>         CLASS(FTLinkedList), POINTER :: list, listToAdd !>         CLASS(FTObject)    , POINTER :: objectPtr !> !>         objectPtr => r                ! r is subclass of FTObject !>         CALL list % Add(objectPtr)    ! Pointer is retained by list !>         CALL release(r)               ! If caller relinquishes ownership !> !>         CALL list % addObjectsFromList(listToAdd) !> !>##Inserting objects !> !>         CLASS(FTLinkedList)      , POINTER :: list !>         CLASS(FTObject)          , POINTER :: objectPtr, obj !>         CLASS(FTLinkedListRecord), POINTER :: record !> !>         objectPtr => r                                        ! r is subclass of FTObject !>         CALL list % insertObjectAfterRecord(objectPtr,record) ! Pointer is retained by list !>         CALL release(r)                                       ! If caller reliquishes ownership !> !>         objectPtr => r                                     ! r is subclass of FTObject !>         CALL list % insertObjectAfterObject(objectPtr,obj) ! Pointer is retained by list !>         CALL release(r)                                    ! If caller reliquishes ownership !> !>##Removing objects !> !>         CLASS(FTLinkedList), POINTER :: list !>         CLASS(FTObject)    , POINTER :: objectPtr !>         objectPtr => r                 ! r is subclass of FTObject !>         CALL list % remove(objectPtr) !> !>##Getting all objects as an object array !> !>         CLASS(FTLinkedList)        , POINTER :: list !>         CLASS(FTMutableObjectArray), POINTER :: array !>         array => list % allObjects() ! Array has refCount = 1 !> !>##Counting the number of objects in the list !> !>         n = list % count() !> !>##Destruction !> !>         CALL releaseFTLinkedList(list) [Pointers] !>! Module FTLinkedListClass ! USE FTLinkedListRecordClass USE FTMutableObjectArrayClass IMPLICIT NONE ! !     ----------------- !     Class object type !     ----------------- ! TYPE , EXTENDS ( FTObject ) :: FTLinkedList CLASS ( FTLinkedListRecord ), POINTER :: head => NULL (), tail => NULL () INTEGER :: nRecords LOGICAL :: isCircular_ ! !        ======== CONTAINS !        ======== ! PROCEDURE :: init => initFTLinkedList PROCEDURE :: add PROCEDURE :: remove => removeObject PROCEDURE :: reverse => reverseLinkedList PROCEDURE :: removeRecord => removeLinkedListRecord FINAL :: destructFTLinkedList PROCEDURE :: count => numberOfRecords PROCEDURE :: description => FTLinkedListDescription PROCEDURE :: printDescription => printFTLinkedListDescription PROCEDURE :: className => linkedListClassName PROCEDURE :: allObjects => allLinkedListObjects PROCEDURE :: removeAllObjects => removeAllLinkedListObjects PROCEDURE :: addObjectsFromList PROCEDURE :: makeCircular PROCEDURE :: isCircular PROCEDURE :: insertObjectAfterRecord PROCEDURE :: insertObjectAfterObject END TYPE FTLinkedList INTERFACE cast MODULE PROCEDURE castObjectToLinkedList END INTERFACE cast ! !     ---------- !     Procedures !     ---------- ! CONTAINS ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initFTLinkedList ( self ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self ! !        ------------------------------- !        Always call the superclass init !        ------------------------------- ! CALL self % FTObject % init () ! !        -------------------------------------- !        Then call the subclass initializations !        -------------------------------------- ! self % nRecords = 0 self % isCircular_ = . FALSE . self % head => NULL (); self % tail => NULL () END SUBROUTINE initFTLinkedList ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE add ( self , obj ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self CLASS ( FTObject ) , POINTER :: obj CLASS ( FTLinkedListRecord ), POINTER :: newRecord => NULL () ALLOCATE ( newRecord ) CALL newRecord % initWithObject ( obj ) IF ( . NOT . ASSOCIATED ( self % head ) ) THEN self % head => newRecord ELSE self % tail % next => newRecord newRecord % previous => self % tail END IF self % tail => newRecord self % nRecords = self % nRecords + 1 END SUBROUTINE add ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addObjectsFromList ( self , list ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self CLASS ( FTLinkedList ) , POINTER :: list CLASS ( FTLinkedListRecord ), POINTER :: recordPtr => NULL () CLASS ( FtObject ) , POINTER :: obj => NULL () LOGICAL :: circular IF (. NOT . ASSOCIATED ( list % head )) RETURN circular = list % isCircular () CALL list % makeCircular (. FALSE .) recordPtr => list % head DO WHILE ( ASSOCIATED ( recordPtr )) obj => recordPtr % recordObject CALL self % add ( obj ) recordPtr => recordPtr % next END DO CALL list % makeCircular ( circular ) END SUBROUTINE addObjectsFromList ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE insertObjectAfterRecord ( self , obj , after ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self CLASS ( FTObject ) , POINTER :: obj CLASS ( FTLinkedListRecord ), POINTER :: newRecord => NULL () CLASS ( FTLinkedListRecord ), POINTER :: after , next => NULL () ALLOCATE ( newRecord ) CALL newRecord % initWithObject ( obj ) next => after % next newRecord % next => next newRecord % previous => after after % next => newRecord next % previous => newRecord IF ( . NOT . ASSOCIATED ( newRecord % next ) ) THEN self % tail => newRecord END IF self % nRecords = self % nRecords + 1 END SUBROUTINE insertObjectAfterRecord ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE insertObjectAfterObject ( self , obj , after ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self CLASS ( FTObject ) , POINTER :: obj , after CLASS ( FTLinkedListRecord ), POINTER :: current => NULL (), previous => NULL () IF ( . NOT . ASSOCIATED ( self % head ) ) THEN CALL self % add ( obj ) RETURN END IF current => self % head previous => NULL () ! !        ------------------------------------------------------------- !        Find the object in the list by a linear search and !        add the new object after it. !        It will be deallocated if necessary. !        ------------------------------------------------------------- ! DO WHILE ( ASSOCIATED ( current )) IF ( ASSOCIATED ( current % recordObject , after ) ) THEN CALL self % insertObjectAfterRecord ( obj = obj , after = current ) RETURN END IF previous => current current => current % next END DO END SUBROUTINE insertObjectAfterObject ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE makeCircular ( self , circular ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self LOGICAL :: circular IF ( circular ) THEN self % head % previous => self % tail self % tail % next => self % head self % isCircular_ = . TRUE . ELSE self % head % previous => NULL () self % tail % next => NULL () self % isCircular_ = . FALSE . END IF END SUBROUTINE makeCircular ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isCircular ( self ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self isCircular = self % isCircular_ END FUNCTION isCircular ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE removeObject1 ( self , obj ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self CLASS ( FTObject ) , POINTER :: obj CLASS ( FTLinkedListRecord ), POINTER :: current => NULL (), previous => NULL () IF ( . NOT . ASSOCIATED ( self % head ) ) RETURN current => self % head previous => NULL () ! !        ------------------------------------------------------------- !        Find the object in the list by a linear search and remove it. !        It will be deallocated if necessary. !        ------------------------------------------------------------- ! DO WHILE ( ASSOCIATED ( current )) IF ( ASSOCIATED ( current % recordObject , obj ) ) THEN IF ( ASSOCIATED ( previous ) ) THEN previous % next => current % next ELSE self % head => current % next END IF IF ( ASSOCIATED ( current , self % tail ) ) THEN self % tail => previous END IF obj => current CALL release ( obj ) self % nRecords = self % nRecords - 1 EXIT END IF previous => current current => current % next END DO END SUBROUTINE removeObject1 ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE removeObject ( self , obj ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self CLASS ( FTObject ) , POINTER :: obj CLASS ( FTLinkedListRecord ), POINTER :: current => NULL (), previous => NULL () IF ( . NOT . ASSOCIATED ( self % head ) ) RETURN current => self % head previous => NULL () ! !        ------------------------------------------------------------- !        Find the object in the list by a linear search and remove it. !        It will be deallocated if necessary. !        ------------------------------------------------------------- ! DO WHILE ( ASSOCIATED ( current )) IF ( ASSOCIATED ( current % recordObject , obj ) ) THEN CALL self % removeRecord ( current ) EXIT END IF previous => current current => current % next END DO END SUBROUTINE removeObject ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE removeLinkedListRecord ( self , listRecord ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTLinkedList ) :: self CLASS ( FTLinkedListRecord ), POINTER :: listRecord ! !        --------------- !        Local variables !        --------------- ! CLASS ( FTLinkedListRecord ), POINTER :: previous => NULL (), next => NULL () CLASS ( FTObject ) , POINTER :: obj ! !        --------------------------------------------------- !        Turn cirularity off and then back on !        to work around an what appears to be an !        ifort bug testing the association of two pointers. !        --------------------------------------------------- ! LOGICAL :: circ circ = self % isCircular () IF ( circ ) CALL self % makeCircular (. FALSE .) previous => listRecord % previous next => listRecord % next IF ( . NOT . ASSOCIATED ( listRecord % previous ) ) THEN self % head => next IF ( ASSOCIATED ( next ) ) THEN self % head % previous => NULL () END IF END IF IF ( . NOT . ASSOCIATED ( listRecord % next ) ) THEN self % tail => previous IF ( ASSOCIATED ( previous ) ) THEN self % tail % next => NULL () END IF END IF IF ( ASSOCIATED ( previous ) . AND . ASSOCIATED ( next ) ) THEN previous % next => next next % previous => previous END IF obj => listRecord CALL release ( obj ) self % nRecords = self % nRecords - 1 IF ( circ ) CALL self % makeCircular (. TRUE .) END SUBROUTINE removeLinkedListRecord ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE removeAllLinkedListObjects ( self ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self CLASS ( FTLinkedListRecord ), POINTER :: listRecord => NULL (), tmp => NULL () LOGICAL :: circular CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self % head )) RETURN circular = self % isCircular () CALL self % makeCircular (. FALSE .) listRecord => self % head DO WHILE ( ASSOCIATED ( listRecord )) tmp => listRecord % next obj => listRecord CALL release ( obj ) IF (. NOT . ASSOCIATED ( listRecord )) THEN self % nRecords = self % nRecords - 1 END IF listRecord => tmp END DO self % head => NULL (); self % tail => NULL () END SUBROUTINE removeAllLinkedListObjects ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION numberOfRecords ( self ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self numberOfRecords = self % nRecords END FUNCTION numberOfRecords ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTLinkedList ( self ) IMPLICIT NONE CLASS ( FTLinkedList ), POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTLinkedList ! !//////////////////////////////////////////////////////////////////////// ! !< The destructor must only be called from within the destructors of subclasses !> It is automatically called by release(). ! SUBROUTINE destructFTLinkedList ( self ) IMPLICIT NONE TYPE ( FTLinkedList ) :: self CALL self % removeAllObjects () END SUBROUTINE destructFTLinkedList ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION FTLinkedListDescription ( self ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self CLASS ( FTLinkedListRecord ), POINTER :: listRecord => NULL () CHARACTER ( LEN = DESCRIPTION_CHARACTER_LENGTH ) :: FTLinkedListDescription FTLinkedListDescription = \"\" IF (. NOT . ASSOCIATED ( self % head )) RETURN listRecord => self % head FTLinkedListDescription = TRIM ( listRecord % recordObject % description ()) listRecord => listRecord % next DO WHILE ( ASSOCIATED ( listRecord )) FTLinkedListDescription = TRIM ( FTLinkedListDescription ) // & CHAR ( 13 ) // & TRIM ( listRecord % recordObject % description ()) listRecord => listRecord % next END DO END FUNCTION FTLinkedListDescription ! !//////////////////////////////////////////////////////////////////////// ! RECURSIVE SUBROUTINE printFTLinkedListDescription ( self , iUnit ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self INTEGER :: iUnit CLASS ( FTLinkedListRecord ), POINTER :: listRecord => NULL () LOGICAL :: circular IF (. NOT . ASSOCIATED ( self % head )) RETURN circular = . FALSE . IF ( self % isCircular_ ) circular = . TRUE . CALL self % makeCircular (. FALSE .) listRecord => self % head DO WHILE ( ASSOCIATED ( listRecord )) CALL listRecord % printDescription ( iUnit ) IF (. NOT . ASSOCIATED ( listRecord )) EXIT !TODO Don't understand why this is necessary. Why is record being unassociated? listRecord => listRecord % next END DO CALL self % makeCircular ( circular ) END SUBROUTINE printFTLinkedListDescription ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE reverseLinkedList ( self ) ! !     ------------------------ !     Reverses the linked list !     ------------------------ ! IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTLinkedList ) :: self ! !        --------------- !        Local variables !        --------------- ! CLASS ( FTLinkedListRecord ), POINTER :: current => NULL (), tmp => NULL () IF (. NOT . ASSOCIATED ( self % head )) RETURN IF ( self % isCircular_ ) THEN self % head % previous => NULL () self % tail % next => NULL () END IF current => self % head DO WHILE ( ASSOCIATED ( current )) tmp => current % next current % next => current % previous current % previous => tmp current => tmp END DO tmp => self % head self % head => self % tail self % tail => tmp CALL self % makeCircular ( self % isCircular_ ) END SUBROUTINE reverseLinkedList ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION allLinkedListObjects ( self ) RESULT ( array ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTLinkedList ) :: self CLASS ( FTMutableObjectArray ), POINTER :: array ! !        --------------- !        Local variables !        --------------- ! INTEGER :: N CLASS ( FTLinkedListRecord ), POINTER :: listRecord => NULL () CLASS ( FTObject ) , POINTER :: obj => NULL () LOGICAL :: circular array => NULL () IF (. NOT . ASSOCIATED ( self % head )) RETURN circular = . FALSE . IF ( self % isCircular_ ) circular = . TRUE . CALL self % makeCircular (. FALSE .) array => NULL () N = self % count () IF ( N == 0 ) RETURN ALLOCATE ( array ) CALL array % initWithSize ( arraySize = N ) listRecord => self % head DO WHILE ( ASSOCIATED ( listRecord )) obj => listRecord % recordObject CALL array % addObject ( obj ) listRecord => listRecord % next END DO CALL self % makeCircular ( circular ) END FUNCTION allLinkedListObjects ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTLinkedList\") !> FUNCTION linkedListClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTLinkedList ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTLinkedList\" END FUNCTION linkedListClassName !@mark - ! type conversions ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE castObjectToLinkedList ( obj , cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the LinkedList class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTLinkedList ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTLinkedList ) cast => e CLASS DEFAULT END SELECT END SUBROUTINE castObjectToLinkedList ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION linkedListFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the LinkedList class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTLinkedList ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTLinkedList ) cast => e CLASS DEFAULT END SELECT END FUNCTION linkedListFromObject ! END MODULE FTLinkedListClass ! !@mark - ! !//////////////////////////////////////////////////////////////////////// ! !>An object for stepping through a linked list. !> !>###Definition (Subclass of FTObject): !>   TYPE(FTLinkedListIterator) :: list !> !> !>###Initialization !> !>         CLASS(FTLinkedList)        , POINTER :: list !>         CLASS(FTLinkedListIterator), POINTER :: iterator !>         ALLOCATE(iterator) !>         CALL iterator % initWithFTLinkedList(list) !> !>###Accessors !> !>         ptr => iterator % list() !>         ptr => iterator % object() !>         ptr => iterator % currentRecord() !> !>###Iterating !> !>         CLASS(FTObject), POINTER :: objectPtr !>         CALL iterator % setToStart !>         DO WHILE (.NOT.iterator % isAtEnd()) !>            objectPtr => iterator % object()        ! if the object is wanted !>            recordPtr => iterator % currentRecord() ! if the record is wanted !> !>             Do something with object or record !> !>            CALL iterator % moveToNext() ! DON'T FORGET THIS!! !>         END DO !> !>###Destruction !> !>         CALL releaseFTLinkedListIterator(iterator) [Pointers] ! !//////////////////////////////////////////////////////////////////////// ! Module FTLinkedListIteratorClass USE FTLinkedListClass IMPLICIT NONE ! !     ----------------- !     Class object type !     ----------------- ! TYPE , EXTENDS ( FTObject ) :: FTLinkedListIterator CLASS ( FTLinkedList ) , POINTER :: list => NULL () CLASS ( FTLinkedListRecord ), POINTER :: current => NULL () ! !        ======== CONTAINS !        ======== ! PROCEDURE :: init => initEmpty PROCEDURE :: initWithFTLinkedList FINAL :: destructIterator PROCEDURE :: isAtEnd => FTLinkedListIsAtEnd PROCEDURE :: object => FTLinkedListObject PROCEDURE :: currentRecord => FTLinkedListCurrentRecord PROCEDURE :: linkedList => returnLinkedList PROCEDURE :: className => linkedListIteratorClassName PROCEDURE :: setLinkedList PROCEDURE :: setToStart PROCEDURE :: moveToNext PROCEDURE :: removeCurrentRecord END TYPE FTLinkedListIterator ! !     ---------- !     Procedures !     ---------- ! CONTAINS ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initEmpty ( self ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self ! !        -------------------------------------------- !        Always call the superclass initializer first !        -------------------------------------------- ! CALL self % FTObject % init () ! !        ---------------------------------------------- !        Then call the initializations for the subclass !        ---------------------------------------------- ! self % list => NULL () self % current => NULL () END SUBROUTINE initEmpty ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithFTLinkedList ( self , list ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self CLASS ( FTLinkedList ), POINTER :: list ! !        -------------------------------------------- !        Always call the superclass initializer first !        -------------------------------------------- ! CALL self % FTObject % init () ! !        ---------------------------------------------- !        Then call the initializations for the subclass !        ---------------------------------------------- ! self % list => NULL () self % current => NULL () CALL self % setLinkedList ( list ) CALL self % setToStart () END SUBROUTINE initWithFTLinkedList ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTLinkedListIterator ( self ) IMPLICIT NONE TYPE ( FTLinkedListIterator ), POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTLinkedListIterator ! !//////////////////////////////////////////////////////////////////////// ! !< The destuctor must not be called except at the end of destructors of ! subclasses. ! SUBROUTINE destructIterator ( self ) IMPLICIT NONE TYPE ( FTLinkedListIterator ) :: self CALL releaseMemberList ( self ) self % current => NULL () END SUBROUTINE destructIterator ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseMemberList ( self ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self CLASS ( FTObject ), POINTER :: obj IF ( ASSOCIATED ( self % list ) ) THEN obj => self % list CALL releaseFTObject ( self = obj ) IF (. NOT . ASSOCIATED ( obj )) self % list => NULL () END IF END SUBROUTINE releaseMemberList ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE setToStart ( self ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self self % current => self % list % head END SUBROUTINE setToStart ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE moveToNext ( self ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self IF ( ASSOCIATED ( self % current ) ) THEN self % current => self % current % next ELSE self % current => NULL () END IF IF ( ASSOCIATED ( self % current , self % list % head ) ) THEN self % current => NULL () END IF END SUBROUTINE moveToNext ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION FTLinkedListIsAtEnd ( self ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self IF ( ASSOCIATED ( self % current ) ) THEN FTLinkedListIsAtEnd = . false . ELSE FTLinkedListIsAtEnd = . true . END IF END FUNCTION FTLinkedListIsAtEnd ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE setLinkedList ( self , list ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self CLASS ( FTLinkedList ), POINTER :: list ! !        ----------------------------------- !        Remove current list if there is one !        ----------------------------------- ! IF ( ASSOCIATED ( list ) ) THEN IF ( ASSOCIATED ( self % list , list ) ) THEN CALL self % setToStart () ELSE IF ( ASSOCIATED ( self % list ) ) THEN CALL releaseMemberList ( self ) self % list => list CALL self % list % retain () CALL self % setToStart ELSE self % list => list CALL self % list % retain () CALL self % setToStart () END IF ELSE IF ( ASSOCIATED ( self % list ) ) THEN CALL releaseMemberList ( self ) END IF self % list => NULL () END IF END SUBROUTINE setLinkedList ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION returnLinkedList ( self ) RESULT ( o ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self CLASS ( FTLinkedList ), POINTER :: o o => self % list END FUNCTION returnLinkedList ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION FTLinkedListObject ( self ) RESULT ( o ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self CLASS ( FTObject ), POINTER :: o o => self % current % recordObject END FUNCTION FTLinkedListObject ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION FTLinkedListCurrentRecord ( self ) RESULT ( o ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self CLASS ( FTLinkedListRecord ), POINTER :: o o => self % current END FUNCTION FTLinkedListCurrentRecord ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE removeCurrentRecord ( self ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self CLASS ( FTLinkedListRecord ), POINTER :: r , n r => self % current n => self % current % next CALL self % list % removeRecord ( r ) self % current => n END SUBROUTINE removeCurrentRecord ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTLinkedListIterator\") !> FUNCTION linkedListIteratorClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTLinkedListIterator ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTLinkedListIterator\" END FUNCTION linkedListIteratorClassName END MODULE FTLinkedListIteratorClass","tags":"","loc":"sourcefile/ftlinkedlistclass.f90.html"},{"title":"FTExceptionClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftexceptionclass.f90~~EfferentGraph sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftstackclass.f90 FTStackClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftstackclass.f90 sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectclass.f90 sourcefile~hash.f90 Hash.f90 sourcefile~ftdictionaryclass.f90->sourcefile~hash.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftstackclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvalueclass.f90 FTValueClass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftvalueclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftvalueclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftolconstants.f90 FTOLConstants.f90 sourcefile~ftvalueclass.f90->sourcefile~ftolconstants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ftexceptionclass.f90~~AfferentGraph sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTExceptionClass SharedExceptionManagerModule Source Code FTExceptionClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      FTExceptionClass.f90 !      Created: January 29, 2013 5:06 PM !      By: David Kopriva ! ! !>An FTException object gives a way to pass generic !>information about an exceptional situation. !> !>An FTException object gives a way to pass generic !>information about an exceptional situation. Methods for !>dealing with exceptions are defined in the SharedExceptionManagerModule !>module. !> !>An FTException object wraps: !> !>- A severity indicator !>- A name for the exception !>- An optional dictionary that contains whatever information is deemed necessary. !> !>It is expected that classes will define exceptions that use instances !>of the FTException Class. !> !>### Defined constants: !> !>-   FT_ERROR_NONE    = 0 !>-   FT_ERROR_WARNING = 1 !>-   FT_ERROR_FATAL   = 2 !> !>### Initialization !> !>            CALL e  %  initFTException(severity,exceptionName,infoDictionary) !> !>Plus the convenience initializers, which automatically create a FTValueDictionary with a single key called \"message\": !> !>        CALL e % initWarningException(msg = \"message\") !>        CALL e % initFatalException(msg = \"message\") !> !>Plus an assertion exception !> !>        CALL e % initAssertionFailureException(msg,expectedValueObject,observedValueObject,level) !> !>### Destruction !> !>        CALL releaseFTException(e) [pointers] !> !>###Setting the infoDictionary !> !>        CALL e  %  setInfoDictionary(infoDictionary) !>###Getting the infoDictionary !> !>        dict => e % infoDictionary !>###Getting the name of the exception !> !>        name = e % exceptionName() !>###Getting the severity level of the exception !> !>        level = e % severity() !> Severity levels are FT_ERROR_WARNING or FT_ERROR_FATAL !>###Printing the exception !> !>        CALL e % printDescription() !> ! !//////////////////////////////////////////////////////////////////////// ! Module FTExceptionClass USE FTStackClass USE FTDictionaryClass USE FTValueDictionaryClass USE FTLinkedListIteratorClass IMPLICIT NONE ! !     ---------------- !     Global constants !     ---------------- ! INTEGER , PARAMETER :: FT_ERROR_NONE = 0 , FT_ERROR_WARNING = 1 , FT_ERROR_FATAL = 2 INTEGER , PARAMETER :: ERROR_MSG_STRING_LENGTH = 132 CHARACTER ( LEN = 21 ), PARAMETER :: FTFatalErrorException = \"FTFatalErrorException\" CHARACTER ( LEN = 23 ), PARAMETER :: FTWarningErrorException = \"FTWarningErrorException\" CHARACTER ( LEN = 27 ), PARAMETER :: FTAssertionFailureException = \"FTAssertionFailureException\" ! !     --------------- !     Error base type !     --------------- ! TYPE , EXTENDS ( FTObject ) :: FTException INTEGER , PRIVATE :: severity_ CHARACTER ( LEN = ERROR_MSG_STRING_LENGTH ), PRIVATE :: exceptionName_ CLASS ( FTDictionary ), POINTER , PRIVATE :: infoDictionary_ => NULL () ! !        -------- CONTAINS !        -------- ! PROCEDURE :: initFTException PROCEDURE :: initWarningException PROCEDURE :: initFatalException PROCEDURE :: initAssertionFailureException FINAL :: destructException PROCEDURE :: setInfoDictionary PROCEDURE :: infoDictionary PROCEDURE :: exceptionName PROCEDURE :: severity PROCEDURE :: printDescription => printFTExceptionDescription PROCEDURE :: className => exceptionClassName END TYPE FTException INTERFACE cast MODULE PROCEDURE castToException END INTERFACE cast ! !     ======== CONTAINS !     ======== ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWarningException ( self , msg ) ! ! --------------------------------------------- !>A convenience initializer for a warning error !>that includes the key \"message\" in the !>infoDictionary. Use this initializer as an !>example of how to write one's own exception. ! -------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ) :: self CHARACTER ( LEN =* ) :: msg CLASS ( FTValueDictionary ), POINTER :: userDictionary => NULL () CLASS ( FTDictionary ) , POINTER :: dictPtr => NULL () ALLOCATE ( userDictionary ) CALL userDictionary % initWithSize ( 64 ) CALL userDictionary % addValueForKey ( msg , \"message\" ) dictPtr => userDictionary CALL self % initFTException ( severity = FT_ERROR_WARNING ,& exceptionName = FTWarningErrorException ,& infoDictionary = dictPtr ) CALL releaseMemberDictionary ( self ) END SUBROUTINE initWarningException ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initFatalException ( self , msg ) ! ! --------------------------------------------- !>A convenience initializer for a fatal error !>that includes the key \"message\" in the !>infoDictionary.Use this initializer as an !>example of how to write one's own exception. ! -------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ) :: self CHARACTER ( LEN =* ) :: msg CLASS ( FTValueDictionary ), POINTER :: userDictionary => NULL () CLASS ( FTDictionary ) , POINTER :: dictPtr => NULL () ALLOCATE ( userDictionary ) CALL userDictionary % initWithSize ( 8 ) CALL userDictionary % addValueForKey ( msg , \"message\" ) dictPtr => userDictionary CALL self % initFTException ( severity = FT_ERROR_FATAL ,& exceptionName = FTFatalErrorException ,& infoDictionary = dictPtr ) CALL releaseMemberDictionary ( self ) END SUBROUTINE initFatalException ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initFTException ( self , severity , exceptionName , infoDictionary ) ! ! ----------------------------------- !>The main initializer for the class ! ----------------------------------- ! IMPLICIT NONE CLASS ( FTException ) :: self INTEGER :: severity CHARACTER ( LEN =* ) :: exceptionName CLASS ( FTDictionary ), POINTER , OPTIONAL :: infoDictionary CALL self % FTObject % init () self % severity_ = severity self % exceptionName_ = exceptionName self % infoDictionary_ => NULL () IF ( PRESENT ( infoDictionary ) . AND . ASSOCIATED ( infoDictionary )) THEN CALL self % setInfoDictionary ( infoDictionary ) END IF END SUBROUTINE initFTException ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initAssertionFailureException ( self , msg , expectedValueObject , observedValueObject , level ) ! ! ------------------------------------------------ !>A convenience initializer for an assertion error !>that includes the keys: !> !>-\"message\" !>-\"expectedValue\" !>-\"observedValue\" !> !>in the infoDictionary ! ! ------------------------------------------------ ! IMPLICIT NONE CLASS ( FTException ) :: self CLASS ( FTValue ), POINTER :: expectedValueObject , ObservedValueObject INTEGER :: level CHARACTER ( LEN =* ) :: msg CLASS ( FTValueDictionary ), POINTER :: userDictionary => NULL () CLASS ( FTDictionary ) , POINTER :: dictPtr => NULL () CLASS ( FTObject ) , POINTER :: objectPtr => NULL () ALLOCATE ( userDictionary ) CALL userDictionary % initWithSize ( 8 ) CALL userDictionary % addValueForKey ( msg , \"message\" ) objectPtr => expectedValueObject CALL userDictionary % addObjectForKey ( object = objectPtr , key = \"expectedValue\" ) objectPtr => ObservedValueObject CALL userDictionary % addObjectForKey ( object = objectPtr , key = \"observedValue\" ) dictPtr => userDictionary CALL self % initFTException ( severity = level ,& exceptionName = FTAssertionFailureException ,& infoDictionary = dictPtr ) CALL releaseMemberDictionary ( self ) END SUBROUTINE initAssertionFailureException ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTException ( self ) IMPLICIT NONE TYPE ( FTException ) , POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTException ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructException ( self ) ! ! -------------------------------------------------------------- !>The destructor for the class. Do not call this direectly. Call !>the release() procedure instead ! -------------------------------------------------------------- ! IMPLICIT NONE TYPE ( FTException ) :: self CALL releaseMemberDictionary ( self ) END SUBROUTINE destructException ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE setInfoDictionary ( self , dict ) ! ! --------------------------------------------- !>Sets and retains the exception infoDictionary ! --------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ) :: self CLASS ( FTDictionary ), POINTER :: dict IF ( ASSOCIATED ( self % infoDictionary_ )) CALL releaseMemberDictionary ( self ) self % infoDictionary_ => dict CALL self % infoDictionary_ % retain () END SUBROUTINE setInfoDictionary ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseMemberDictionary ( self ) IMPLICIT NONE CLASS ( FTException ) :: self CLASS ( FTObject ), POINTER :: obj IF ( ASSOCIATED ( self % infoDictionary_ )) THEN obj => self % infoDictionary_ CALL releaseFTObject ( self = obj ) IF (. NOT . ASSOCIATED ( obj )) self % infoDictionary_ => NULL () END IF END SUBROUTINE releaseMemberDictionary ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION infoDictionary ( self ) ! ! --------------------------------------------- !>Returns the exception's infoDictionary. Does !>not transfer ownership/reference count is !>unchanged. ! --------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ) :: self CLASS ( FTDictionary ), POINTER :: infoDictionary infoDictionary => self % infoDictionary_ END FUNCTION infoDictionary ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION exceptionName ( self ) ! ! --------------------------------------------- !>Returns the string representing the name set !>for the exception. ! --------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ) :: self CHARACTER ( LEN = ERROR_MSG_STRING_LENGTH ) :: exceptionName exceptionName = self % exceptionName_ END FUNCTION exceptionName ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION severity ( self ) ! ! --------------------------------------------- !>Returns the severity level of the exception. ! --------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ) :: self severity = self % severity_ END FUNCTION severity ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE printFTExceptionDescription ( self , iUnit ) ! ! ---------------------------------------------- !>A basic printing of the exception and the info !>held in the infoDicitonary. ! ---------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ) :: self INTEGER :: iUnit CLASS ( FTDictionary ), POINTER :: dict => NULL () !        WRITE(iUnit,*) \"-------------\" WRITE ( iUnit , * ) \" \" WRITE ( iUnit , * ) \"Exception Named: \" , TRIM ( self % exceptionName ()) dict => self % infoDictionary () IF ( ASSOCIATED ( dict )) CALL dict % printDescription ( iUnit ) END SUBROUTINE printFTExceptionDescription ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE castToException ( obj , cast ) ! ! ----------------------------------------------------- !>Cast the base class FTObject to the FTException class ! ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTException ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTException ) cast => e CLASS DEFAULT END SELECT END SUBROUTINE castToException ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION exceptionFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTException ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTException ) cast => e CLASS DEFAULT END SELECT END FUNCTION exceptionFromObject ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTException\") !> FUNCTION exceptionClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTException ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTException\" IF ( self % refCount () >= 0 ) CONTINUE !Quiet unused variable warnings END FUNCTION exceptionClassName END Module FTExceptionClass ! !//////////////////////////////////////////////////////////////////////// ! !@mark - Module SharedExceptionManagerModule !> !>All exceptions are posted to the SharedExceptionManagerModule. !> !>To use exceptions,first initialize it !>        CALL initializeFTExceptions !>From that point on, all exceptions will be posted there. Note that the !>FTTestSuiteManager class will initialize the SharedExceptionManagerModule, !>so there is no need to do the initialization separately if the FTTestSuiteManager !>class has been initialized. !> !>The exceptions are posted to a stack. To access the exceptions they will be !>peeked or popped from that stack. !> !>###Initialization !>        CALL initializeFTExceptions !>###Finalization !>        CALL destructFTExceptions !>###Throwing an exception !>         CALL throw(exception) !>###Getting the number of exceptions !>         n = errorCount() !>###Getting the maximum exception severity !>         s = maximumErrorSeverity() !>###Catching all exceptions !>         IF(catch())     THEN !>            Do something with the exceptions !>         END IF !>###Getting the named exception caught !>         CLASS(FTException), POINTER :: e !>         e => errorObject() !>###Popping the top exception !>         e => popLastException() !>###Peeking the top exception !>         e => peekLastException() !>###Catching an exception with a given name !>         IF(catch(name))   THEN !>            !Do something with the exception, e.g. !>            e              => errorObject() !>            d              => e % infoDictionary() !>            userDictionary => valueDictionaryFromDictionary(dict = d) !>            msg = userDictionary % stringValueForKey(\"message\",FTDICT_KWD_STRING_LENGTH) !>         END IF !>###Printing all exceptions !>      call printAllExceptions !> USE FTExceptionClass IMPLICIT NONE ! !     -------------------- !     Global error stack !     -------------------- ! TYPE ( FTStack ) , POINTER , PRIVATE :: errorStack => NULL () TYPE ( FTException ), POINTER , PRIVATE :: currentError_ => NULL () INTEGER , PRIVATE :: maxErrorLevel INTERFACE catch MODULE PROCEDURE catchAll MODULE PROCEDURE catchErrorWithName END INTERFACE catch PRIVATE :: catchAll , catchErrorWithName ! !     ======== CONTAINS !     ======== ! ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initializeFTExceptions ! !>Called at start of execution. Will be called automatically if an !>exception is thrown. ! IMPLICIT NONE IF ( . NOT . ASSOCIATED ( errorStack ) ) THEN ALLOCATE ( errorStack ) CALL errorStack % init () currentError_ => NULL () END IF maxErrorLevel = FT_ERROR_NONE END SUBROUTINE initializeFTExceptions ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructFTExceptions ! !>Called at the end of execution. This procedure will announce if there !>are uncaught exceptions raised and print them. ! IMPLICIT NONE CLASS ( FTObject ), POINTER :: obj ! !        -------------------------------------------------- !        First see if there are any uncaught exceptions and !        report them if there are. !        -------------------------------------------------- ! IF ( catch () ) THEN PRINT * PRINT * , \"   ***********************************\" IF ( errorStack % COUNT () == 1 ) THEN PRINT * , \"   An uncaught exception was raised:\" ELSE PRINT * , \"   Uncaught exceptions were raised:\" END IF PRINT * , \"   ***********************************\" PRINT * CALL errorStack % printDescription ( iUnit = 6 ) END IF ! !        ----------------------- !        Destruct the exceptions !        ----------------------- ! obj => errorStack CALL releaseFTObject ( self = obj ) IF (. NOT . ASSOCIATED ( obj )) errorStack => NULL () CALL releaseCurrentError END SUBROUTINE destructFTExceptions ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE throw ( exceptionToThrow ) ! !>Throws the exception: exceptionToThrow ! IMPLICIT NONE TYPE ( FTException ), POINTER :: exceptionToThrow CLASS ( FTObject ) , POINTER :: ptr => NULL () IF ( . NOT . ASSOCIATED ( errorStack ) ) THEN CALL initializeFTExceptions END IF ptr => exceptionToThrow CALL errorStack % push ( ptr ) maxErrorLevel = MAX ( maxErrorLevel , exceptionToThrow % severity ()) END SUBROUTINE throw ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION catchAll () ! ! ------------------------------------------- !>Returns .TRUE. if there are any exceptions. ! ------------------------------------------- ! IMPLICIT NONE IF ( . NOT . ASSOCIATED ( errorStack ) ) THEN catchAll = . FALSE . RETURN END IF catchAll = . false . IF ( errorStack % count () > 0 ) THEN catchAll = . true . END IF CALL releaseCurrentError END FUNCTION catchAll ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION errorCount () ! ! ------------------------------------------ !>Returns the number of exceptions that have !>been thrown. ! ------------------------------------------ ! IMPLICIT NONE IF ( . NOT . ASSOCIATED ( errorStack ) ) THEN CALL initializeFTExceptions END IF errorCount = errorStack % count () END FUNCTION ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION maximumErrorSeverity () ! ! ----------------------------------------------- !>Returns the maxSeverity of exceptions that have !>been thrown. ! ----------------------------------------------- ! IMPLICIT NONE IF ( . NOT . ASSOCIATED ( errorStack ) ) THEN CALL initializeFTExceptions END IF maximumErrorSeverity = maxErrorLevel END FUNCTION maximumErrorSeverity ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION catchErrorWithName ( exceptionName ) ! ! -------------------------------------------- !>Returns .TRUE. if there is an exception with !>the requested name. If so, it pops the !>exception and saves the pointer to it so that !>it can be accessed with the currentError() !>function. ! -------------------------------------------- ! IMPLICIT NONE CHARACTER ( LEN =* ) :: exceptionName TYPE ( FTLinkedListIterator ) :: iterator CLASS ( FTLinkedList ), POINTER :: ptr => NULL () CLASS ( FTObject ) , POINTER :: obj => NULL () CLASS ( FTException ) , POINTER :: e => NULL () catchErrorWithName = . false . IF ( . NOT . ASSOCIATED ( errorStack ) ) THEN CALL initializeFTExceptions RETURN END IF IF ( errorStack % COUNT () == 0 ) THEN RETURN END IF ptr => errorStack CALL iterator % initWithFTLinkedList ( ptr ) CALL iterator % setToStart () DO WHILE (. NOT . iterator % isAtEnd ()) obj => iterator % object () CALL cast ( obj , e ) IF ( e % exceptionName () == exceptionName ) THEN CALL setCurrentError ( e ) catchErrorWithName = . true . CALL errorStack % remove ( obj ) EXIT END IF CALL iterator % moveToNext () END DO END FUNCTION catchErrorWithName ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION errorObject () ! ! ------------------------------------------- !>Returns a pointer to the current exception. ! ------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ), POINTER :: errorObject IF ( . NOT . ASSOCIATED ( errorStack ) ) THEN CALL initializeFTExceptions END IF errorObject => currentError_ END FUNCTION errorObject ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE setCurrentError ( e ) IMPLICIT NONE CLASS ( FTException ) , POINTER :: e ! !        -------------------------------------------------------------- !        Check first to see if there is a current error. Since it !        is retained, the current one must be released before resetting !        the pointer. !        -------------------------------------------------------------- ! CALL releaseCurrentError ! !        ------------------------------------ !        Set the pointer and retain ownership !        ------------------------------------ ! currentError_ => e CALL currentError_ % retain () END SUBROUTINE setCurrentError ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION popLastException () ! ! ---------------------------------------------------------------- !>Get the last exception posted. This is popped from the stack. !>The caller is responsible for releasing the object after popping ! ---------------------------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ), POINTER :: popLastException CLASS ( FTObject ) , POINTER :: obj => NULL () obj => NULL () popLastException => NULL () IF ( . NOT . ASSOCIATED ( errorStack ) ) THEN CALL initializeFTExceptions ELSE CALL errorStack % pop ( obj ) IF ( ASSOCIATED ( obj )) CALL cast ( obj , popLastException ) END IF END FUNCTION popLastException ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION peekLastException () ! ! ---------------------------------------------------------------- !>Get the last exception posted. This is NOT popped from the stack. !>The caller does not own the object. ! ---------------------------------------------------------------- ! IMPLICIT NONE CLASS ( FTException ), POINTER :: peekLastException CLASS ( FTObject ) , POINTER :: obj => NULL () IF ( . NOT . ASSOCIATED ( errorStack ) ) THEN CALL initializeFTExceptions END IF peekLastException => NULL () obj => errorStack % peek () CALL cast ( obj , peekLastException ) END FUNCTION peekLastException ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE printAllExceptions IMPLICIT NONE TYPE ( FTLinkedListIterator ) :: iterator CLASS ( FTLinkedList ), POINTER :: list => NULL () CLASS ( FTObject ) , POINTER :: objectPtr => NULL () CLASS ( FTException ) , POINTER :: e => NULL () list => errorStack CALL iterator % initWithFTLinkedList ( list ) ! !       ---------------------------------------------------- !       Write out the descriptions of each of the exceptions !       ---------------------------------------------------- ! CALL iterator % setToStart DO WHILE (. NOT . iterator % isAtEnd ()) objectPtr => iterator % object () CALL cast ( objectPtr , e ) CALL e % printDescription ( 6 ) CALL iterator % moveToNext () END DO END SUBROUTINE printAllExceptions ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseCurrentError IMPLICIT NONE CLASS ( FTObject ), POINTER :: obj IF ( ASSOCIATED ( currentError_ ) ) THEN obj => currentError_ CALL releaseFTObject ( self = obj ) IF (. NOT . ASSOCIATED ( obj )) currentError_ => NULL () END IF END SUBROUTINE releaseCurrentError END MODULE SharedExceptionManagerModule","tags":"","loc":"sourcefile/ftexceptionclass.f90.html"},{"title":"FTObjectClass.f90 – FTObjectLibrary","text":"Files dependent on this one sourcefile~~ftobjectclass.f90~~AfferentGraph sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftdataclass.f90 FTDataClass.f90 sourcefile~ftdataclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftmultiindextable.f90 FTMultiIndexTable.f90 sourcefile~ftmultiindextable.f90->sourcefile~ftobjectclass.f90 sourcefile~ftmultiindextable.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftobjectclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftsparsematrixclass.f90 FTSparseMatrixClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftsparsematrixclass.f90 sourcefile~ftvalueclass.f90 FTValueClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvalueclass.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 sourcefile~ftstackclass.f90 FTStackClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftstackclass.f90 sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftsparsematrixclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftsparsematrixclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftstringsetclass.f90 FTStringSetClass.f90 sourcefile~ftstringsetclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftstringsetclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvalueclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftstackclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftstackclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftvalueclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTObjectClass Source Code FTObjectClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! ! ! !>FTObject is the root class for all object types. !> !>Overview !>-------- !> !>FTObject defines the basic methods that are essential for reference counted objects. !> !>FTObject is generally not going to be instantiated by itself, but rather it will !>be subclassed and one will work with instances of the subclasses. !>Otherwise, pointers of type FTObject that point to instances of subclasses !>will be stored in the container classes. !> !> !>Tasks !>----- !> !> !>- init() !> !>     Initializes an object and any memory that it needs to allocate, etc. !>     Should be orrerrided in subclasses.The base class implementation does nothing but !>     increase the reference count of the object. !> !>- destruct() !> !>     Destructor of the object, which releases and deallocates owned objects and memory. !>     Should be overrided in subclasses. The base class implementation does nothing but !>     decrease the reference count of the object. !> !>- printDescription(iUnit) !> !>     Prints a description of the object to a specified file unit. The base class implementation !>     does nothing but print \"FTObject\" !> !>- copy() !> !>     Creates a copy (pointer) to the object of CLASS(FTObject) sourced with the object. !> !>- retain() !> !>     Increases the reference count of the object. Any procedure or object that retain()'s !>     an object gains an ownership stake in that object. This procedure is not overridable. !> !>- release() !> !>     Decreases the reference count of an object. To be called only by objects or procedures !>     that have ownership in an object pointer, i.e., for which init() or retain() have been called. !>     Override this procedure in subclasses for releasing the actual type. !> !>- isUnreferenced() !> !>     Test to see if there are no more owners of an object. !> !>- refCount() !> !>     Returns the number of owners of an object. Usually this is of interest only for debugging purposes. !>     This procedure is not overridable. !> !> !>Subclassing FTObject !>-------------------- !> !>In general, subclasses of FTObject override !> !>- init() !>- destruct() !>- printDescription() !>- release() !> !>They should also provide a cast() subroutine to convert from the base class to a subclass. !>The cast() routine can look something like !> !>     SUBROUTINE castToSubclass(obj,cast) !>        IMPLICIT NONE !>        CLASS(FTObject), POINTER :: obj !>        CLASS(SubClass), POINTER :: cast !> !>        cast => NULL() !>        SELECT TYPE (e => obj) !>           TYPE is (SubClass) !>              cast => e !>           CLASS DEFAULT !> !>        END SELECT !> !>     END SUBROUTINE castToSubclass !> !> !>## Subclassing init !> !>The init() procedure performs subclass specific operations to initialize an object. !> !>Subclasses that override init() must include !>a call to the super class method. For example, overriding init looks like !> !>     SUBROUTINE initSubclass(self) !>        IMPLICIT NONE !>        CLASS(Subclass) :: self !> !>        CALL self % FTObject % init() !>        Allocate and initialize all member objects !>        ... Other Subclass specific code !>     END SUBROUTINE initSubclass !> !>## Subclassing destruct !> !>The destruct() procedure reverses the operations done in the init() procedure. It releases and !>deallocates any pointers that it owns.  Subclasses that override destruct() must include !>a call to the super class method. For example, overriding destruct looks like !> !>     SUBROUTINE destructSubclass(self) !>        IMPLICIT NONE !>        CLASS(Subclass) :: self !> !>        Release and deallocate (if necessary) all member objects !> !>     END SUBROUTINE destructSubclass !> !>## Subclassing printDescription(iUnit) !> !>printDescription is a method whose existence is to support debugging. Call printDescription(iUnit) !>on any objects owned by self for a cascading of what is stored in the object. !> !> !>## Casting an object from the base to a subclass !> !>Container classes and the copy function return pointers to a CLASS(FTObject). To use !>any subclass features one must \"cast\" to the subclass. We like to have a specific !>cast routine to do this as painlessly as possible. Each subclass should include a !>SUBROUTINE like this: !> !>     SUBROUTINE castToSubclass(obj,cast) !>        IMPLICIT NONE !>        CLASS(FTObject), POINTER :: obj !>        CLASS(Subclass), POINTER :: cast !>        cast => NULL() !>        SELECT TYPE (e => obj) !>           TYPE is (Subclass) !>              cast => e !>           CLASS DEFAULT !>        END SELECT !>     END SUBROUTINE castToValue !>## Subclassing className !> !>The className() procedure returns the name of the class. !> !>Subclasses should override className() !> !> !>Created: January 7, 2013 11:30 AM !>@author !>David A. Kopriva ! Module FTObjectClass IMPLICIT NONE ! !     --------- !     Constants !     --------- ! ! Until all compilers can do allocatables INTEGER , PARAMETER :: DESCRIPTION_CHARACTER_LENGTH = 1024 INTEGER , PARAMETER :: CLASS_NAME_CHARACTER_LENGTH = 32 ! !     -------------------------- !     Derived type for the class !     -------------------------- ! TYPE FTObject INTEGER , PRIVATE :: refCount_ ! !        ======== CONTAINS !        ======== ! PROCEDURE :: init => initFTObject PROCEDURE :: description => FTObjectDescription PROCEDURE :: printDescription => printFTObjectDescription PROCEDURE :: className PROCEDURE , NON_OVERRIDABLE :: copy => copyFTObject PROCEDURE , NON_OVERRIDABLE :: retain => retainFTObject PROCEDURE , NON_OVERRIDABLE :: isUnreferenced PROCEDURE , NON_OVERRIDABLE :: refCount FINAL :: destructFTObject END TYPE FTObject PRIVATE :: copyFTObject INTERFACE release MODULE PROCEDURE :: releaseFTObject END INTERFACE release ! !     ===================== CONTAINS ! Procedures !     ===================== ! ! !//////////////////////////////////////////////////////////////////////// ! ! !     -------------------------------------------------------------- !>   Generic Name: init() !> !>   Initializes the object. The base class initialization does !>   nothing but set the reference count to one. !     -------------------------------------------------------------- ! SUBROUTINE initFTObject ( self ) IMPLICIT NONE CLASS ( FTObject ) :: self self % refCount_ = 1 END SUBROUTINE initFTObject ! !//////////////////////////////////////////////////////////////////////// ! ! !     -------------------------------------------------------------------- !>   Generic Name: destruct() !> !>   The destructor for the class. The base class destructor does nothing. !     -------------------------------------------------------------------- ! SUBROUTINE destructFTObject ( self ) IMPLICIT NONE type ( FTObject ) :: self IF ( self % refCount () >= 0 ) CONTINUE END SUBROUTINE destructFTObject ! !//////////////////////////////////////////////////////////////////////// ! ! !      ----------------------------------------------------------------- !> Retain increases the reference count by one and implies ownership !>  to the caller. !>  ### Usage: !>        CALL obj\\ % retain() !      ----------------------------------------------------------------- ! SUBROUTINE retainFTObject ( self ) IMPLICIT NONE CLASS ( FTObject ) :: self self % refCount_ = self % refCount_ + 1 END SUBROUTINE retainFTObject ! !//////////////////////////////////////////////////////////////////////// ! ! !      --------------------------------------------------------------------------- !>     releaseFTObject decreases the reference count by one and implies !>     relinquishing ownership by the caller. Call this if control !>     over the existence of an object pointer is no longer desired by the caller. !>     When the reference count goes to zero, the destructor of the object !>     is called automatically and the object is deallocated. !      --------------------------------------------------------------------------- ! RECURSIVE SUBROUTINE releaseFTObject ( self ) IMPLICIT NONE CLASS ( FTObject ), POINTER :: self IF (. NOT . ASSOCIATED ( self )) RETURN self % refCount_ = self % refCount_ - 1 IF ( self % refCount_ < 0 ) THEN PRINT * , \"Attempt to release object with refCount = 0\" CALL self % printDescription ( 6 ) PRINT * , \"--------------------------------------------\" PRINT * , \" \" RETURN END IF IF ( self % refCount_ == 0 ) THEN IF ( ASSOCIATED ( self )) DEALLOCATE ( self ) self => NULL () END IF END SUBROUTINE releaseFTObject ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTObject\") !> !      ----------------------------------------------------------------- ! FUNCTION className ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTObject ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTObject\" IF ( self % refCount () >= 0 ) CONTINUE END FUNCTION className ! !//////////////////////////////////////////////////////////////////////// ! ! !     ----------------------------------------------------------------------- !>    Owners of objects should call isUnreferenced after releasing a !>     pointer object. If true, the object should be deallocated and then !>     set to point to NULL() !> !>     ### Usage: ### !> !>          IF ( v % isUnreferenced() )     THEN !>             DEALLOCATE(v) !>             v => NULL() !>          END IF !> !     ----------------------------------------------------------------------- ! LOGICAL FUNCTION isUnreferenced ( self ) IMPLICIT NONE CLASS ( FTObject ) :: self IF ( self % refCount_ == 0 ) THEN isUnreferenced = . true . ELSE isUnreferenced = . false . END IF END FUNCTION isUnreferenced ! !//////////////////////////////////////////////////////////////////////// ! ! !     ----------------------------------------------------------------- !>   Returns the reference count for the object. Normally this is done !>    only for debugging purposes. !< !     ----------------------------------------------------------------- ! INTEGER FUNCTION refCount ( self ) IMPLICIT NONE CLASS ( FTObject ) :: self refCount = self % refCount_ END FUNCTION refCount ! !//////////////////////////////////////////////////////////////////////// ! ! !     ---------------------------------------------------------------------- !>   Returns a character string of length DESCRIPTION_CHARACTER_LENGTH that !>    represents the object. the base class implementation returns an empty !>    string. Note that if the description is too long, the expected string !>    will be trunctated. In general, one wants to use printDescription. !< !     ---------------------------------------------------------------------- ! FUNCTION FTObjectDescription ( self ) IMPLICIT NONE CLASS ( FTObject ) :: self CHARACTER ( LEN = DESCRIPTION_CHARACTER_LENGTH ) :: FTObjectDescription FTObjectDescription = \" \" IF ( self % refCount () >= 0 ) CONTINUE END FUNCTION FTObjectDescription ! !//////////////////////////////////////////////////////////////////////// ! ! !     ------------------------------------------------------------------------------------ !>   Generic Name: printDescription() !> !>   Prints a string to unit iUnit that represents the contents of the object. FTObject's !>    description simply prints its name. Override this in subclasses to print something !>    useful. !< !     ------------------------------------------------------------------------------------ ! SUBROUTINE printFTObjectDescription ( self , iUnit ) IMPLICIT NONE CLASS ( FTObject ) :: self INTEGER :: iUnit WRITE ( iUnit , * ) \"FTObject\" IF ( self % refCount () >= 0 ) CONTINUE END SUBROUTINE printFTObjectDescription ! !//////////////////////////////////////////////////////////////////////// ! ! !     -------------------------------------------------------------------- !>   Base class implemetation of the assignment function. Call this from !>    within any subclasses copy assignment function. All FTObject's !>    implementation does is set !>    the reference count to one, implying no additional ownwership to the !>    caller that is creating the copy. !< !     -------------------------------------------------------------------- ! FUNCTION copyFTObject ( self ) RESULT ( copy ) IMPLICIT NONE CLASS ( FTObject ), INTENT ( IN ) :: self CLASS ( FTObject ), POINTER :: copy ALLOCATE ( copy ) CALL initFTObject ( self = copy ) IF ( self % refCount () >= 0 ) CONTINUE END FUNCTION copyFTObject END MODULE FTObjectClass","tags":"","loc":"sourcefile/ftobjectclass.f90.html"},{"title":"FTValueDictionaryClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftvaluedictionaryclass.f90~~EfferentGraph sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvalueclass.f90 FTValueClass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftvalueclass.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectclass.f90 sourcefile~hash.f90 Hash.f90 sourcefile~ftdictionaryclass.f90->sourcefile~hash.f90 sourcefile~ftvalueclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftolconstants.f90 FTOLConstants.f90 sourcefile~ftvalueclass.f90->sourcefile~ftolconstants.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ftvaluedictionaryclass.f90~~AfferentGraph sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTValueDictionaryClass Source Code FTValueDictionaryClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      FTValueDictionary.f90 !      Created: February 6, 2013 8:54 AM !      By: David Kopriva ! !> !> The FTValueDictionary subclass of FTDictionary adds convenient methods !> to easily add fundamental (Real, integer,…) values to a dictionary. !> !> As a subclass, all other methods are still available. !> !>#Usage: !>#Adding a value !> !>     CALL dict % addValueForKey(1,\"integer\") !>     CALL dict % addValueForKey(3.14,\"real\") !>     CALL dict % addValueForKey(98.6d0,\"double\") !>     CALL dict % addValueForKey(.true.,\"logical\") !>     CALL dict % addValueForKey(\"Hello World\",\"string\") !>#Accessing a value !>     i = dict % integerValueForKey(\"integer\") !>     r = dict % realValueForKey(\"real\") !>     d = dict % doublePrecisionValueForKey(\"double\") !>     l = dict % logicalValueForKey(\"logical\") !>     s = dict % stringValueForKey(\"string\",15) !>#Converting an FTDictionary to an FTValueDictionary !>            valueDict => valueDictionaryFromDictionary(dict) !>#Converting an FTObject to an FTValueDictionary !>            valueDict => valueDictionaryFromObject(obj) !>#Destruction !>      call releaseFTValueDictionary(dict) [Pointers] ! !//////////////////////////////////////////////////////////////////////// ! Module FTValueDictionaryClass USE ISO_FORTRAN_ENV USE FTDictionaryClass USE FTValueClass IMPLICIT NONE TYPE , EXTENDS ( FTDictionary ) :: FTValueDictionary ! !        -------- CONTAINS !        -------- ! !        ------- !        Setters !        ------- ! PROCEDURE , PRIVATE :: addRealValueForKey PROCEDURE , PRIVATE :: addDoublePrecisionValueForKey PROCEDURE , PRIVATE :: addIntegerValueForKey PROCEDURE , PRIVATE :: addStringValueForKey PROCEDURE , PRIVATE :: addLogicalValueForKey GENERIC , PUBLIC :: addValueForKey => addRealValueForKey , & addDoublePrecisionValueForKey , & addIntegerValueForKey , & addStringValueForKey , & addLogicalValueForKey #ifdef _has_Quad PROCEDURE , PRIVATE :: addQuadValueForKey GENERIC , PUBLIC :: addValueForKey => addQuadValueForKey #endif ! !        ------- !        Getters !        ------- ! PROCEDURE :: realValueForKey PROCEDURE :: doublePrecisionValueForKey #ifdef _has_Quad PROCEDURE :: quadValueForKey #endif PROCEDURE :: integerValueForKey PROCEDURE :: stringValueForKey PROCEDURE :: logicalValueForKey ! !        ------------- !        Introspection !        ------------- ! PROCEDURE :: className => valueDictionaryClassName END TYPE FTValueDictionary ! CONTAINS !@mark - ! !------------------------------------------------ !> Public, generic name: release(self) !> !> Call release(self) on an object to release control !> of an object. If its reference count is zero, then !> it is deallocated. !------------------------------------------------ ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTValueDictionary ( self ) IMPLICIT NONE TYPE ( FTValueDictionary ) , POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL releaseFTObject ( self = obj ) IF ( . NOT . ASSOCIATED ( obj ) ) THEN self => NULL () END IF END SUBROUTINE releaseFTValueDictionary ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addIntegerValueForKey ( self , i , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self INTEGER :: i CHARACTER ( LEN =* ) :: key CLASS ( FTValue ), POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () ALLOCATE ( v ) CALL v % initWithValue ( i ) obj => v CALL self % addObjectforKey ( obj , key ) CALL release ( obj ) END SUBROUTINE addIntegerValueForKey ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addRealValueForKey ( self , r , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self REAL :: r CHARACTER ( LEN =* ) :: key CLASS ( FTValue ), POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () ALLOCATE ( v ) CALL v % initWithValue ( r ) obj => v CALL self % addObjectforKey ( obj , key ) CALL release ( obj ) END SUBROUTINE addRealValueForKey ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addDoublePrecisionValueForKey ( self , r , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self DOUBLE PRECISION :: r CHARACTER ( LEN =* ) :: key CLASS ( FTValue ), POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () ALLOCATE ( v ) CALL v % initWithValue ( r ) obj => v CALL self % addObjectforKey ( obj , key ) CALL release ( obj ) END SUBROUTINE addDoublePrecisionValueForKey ! !//////////////////////////////////////////////////////////////////////// ! #ifdef _has_Quad SUBROUTINE addQuadValueForKey ( self , r , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self REAL ( KIND = SELECTED_REAL_KIND ( QUAD_DIGITS )) :: r CHARACTER ( LEN =* ) :: key CLASS ( FTValue ), POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () ALLOCATE ( v ) CALL v % initWithValue ( r ) obj => v CALL self % addObjectforKey ( obj , key ) CALL release ( v ) END SUBROUTINE addQuadValueForKey #endif ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addStringValueForKey ( self , s , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self CHARACTER ( LEN =* ) :: s CHARACTER ( LEN =* ) :: key CLASS ( FTValue ), POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () ALLOCATE ( v ) CALL v % initWithValue ( s ) obj => v CALL self % addObjectforKey ( obj , key ) CALL release ( obj ) END SUBROUTINE addStringValueForKey ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addLogicalValueForKey ( self , l , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self LOGICAL :: l CHARACTER ( LEN =* ) :: key CLASS ( FTValue ), POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () ALLOCATE ( v ) CALL v % initWithValue ( l ) obj => v CALL self % addObjectforKey ( obj , key ) CALL release ( obj ) END SUBROUTINE addLogicalValueForKey !@mark - ! !//////////////////////////////////////////////////////////////////////// ! REAL FUNCTION realValueForKey ( self , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self CHARACTER ( LEN =* ) :: key CLASS ( FTValue ) , POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () obj => self % objectForKey ( key ) IF ( ASSOCIATED ( obj ) ) THEN v => valueFromObject ( obj ) realValueForKey = v % realValue () ELSE realValueForKey = HUGE ( realValueForKey ) END IF END FUNCTION realValueForKey ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION integerValueForKey ( self , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self CHARACTER ( LEN =* ) :: key CLASS ( FTValue ) , POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () obj => self % objectForKey ( key ) IF ( ASSOCIATED ( obj ) ) THEN v => valueFromObject ( obj ) integerValueForKey = v % integerValue () ELSE integerValueForKey = HUGE ( integerValueForKey ) END IF END FUNCTION integerValueForKey ! !//////////////////////////////////////////////////////////////////////// ! DOUBLE PRECISION FUNCTION doublePrecisionValueForKey ( self , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self CHARACTER ( LEN =* ) :: key CLASS ( FTValue ) , POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () obj => self % objectForKey ( key ) IF ( ASSOCIATED ( obj ) ) THEN v => valueFromObject ( obj ) doublePrecisionValueForKey = v % doublePrecisionValue () ELSE doublePrecisionValueForKey = HUGE ( doublePrecisionValueForKey ) END IF END FUNCTION doublePrecisionValueForKey ! !//////////////////////////////////////////////////////////////////////// ! #ifdef _has_Quad REAL ( KIND = SELECTED_REAL_KIND ( QUAD_DIGITS )) FUNCTION quadValueForKey ( self , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self CHARACTER ( LEN =* ) :: key CLASS ( FTValue ) , POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () obj => self % objectForKey ( key ) IF ( ASSOCIATED ( obj ) ) THEN v => valueFromObject ( obj ) quadValueForKey = v % quadValue () ELSE quadValueForKey = HUGE ( quadValueForKey ) END IF END FUNCTION quadValueForKey #endif ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION logicalValueForKey ( self , key ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self CHARACTER ( LEN =* ) :: key CLASS ( FTValue ) , POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () obj => self % objectForKey ( key ) IF ( ASSOCIATED ( obj ) ) THEN v => valueFromObject ( obj ) logicalValueForKey = v % logicalValue () ELSE logicalValueForKey = . FALSE . END IF END FUNCTION logicalValueForKey ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION stringValueForKey ( self , key , requestedLength ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self CHARACTER ( LEN =* ) :: key INTEGER :: requestedLength CHARACTER ( LEN = requestedLength ) :: stringValueForKey CLASS ( FTValue ) , POINTER :: v => NULL () CLASS ( FTObject ), POINTER :: obj => NULL () obj => self % objectForKey ( key ) IF ( ASSOCIATED ( obj ) ) THEN v => valueFromObject ( obj ) stringValueForKey = v % stringValue ( requestedLength ) ELSE stringValueForKey = \"\" END IF END FUNCTION stringValueForKey !@mark - ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE castDictionaryToValueDictionary ( dict , valueDict ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTDictionary ) , POINTER :: dict CLASS ( FTValueDictionary ), POINTER :: valueDict valueDict => NULL () SELECT TYPE ( dict ) TYPE is ( FTValueDictionary ) valueDict => dict CLASS DEFAULT END SELECT END SUBROUTINE castDictionaryToValueDictionary ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE castObjectToValueDictionary ( obj , valueDict ) ! !     ----------------------------------------------------------- !     Cast the base class FTObject to the FTValueDictionary class !     ----------------------------------------------------------- ! IMPLICIT NONE CLASS ( FTValueDictionary ), POINTER :: valueDict CLASS ( FTObject ) , POINTER :: obj obj => NULL () SELECT TYPE ( obj ) TYPE is ( FTValueDictionary ) valueDict => obj CLASS DEFAULT END SELECT END SUBROUTINE castObjectToValueDictionary ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION valueDictionaryFromDictionary ( dict ) RESULT ( valueDict ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTDictionary ) , POINTER :: dict CLASS ( FTValueDictionary ), POINTER :: valueDict valueDict => NULL () SELECT TYPE ( dict ) TYPE is ( FTValueDictionary ) valueDict => dict CLASS DEFAULT END SELECT END FUNCTION valueDictionaryFromDictionary ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION valueDictionaryFromObject ( obj ) RESULT ( valueDict ) ! !     ----------------------------------------------------------- !     Cast the base class FTObject to the FTValueDictionary class !     ----------------------------------------------------------- ! IMPLICIT NONE CLASS ( FTValueDictionary ), POINTER :: valueDict CLASS ( FTObject ) , POINTER :: obj valueDict => NULL () SELECT TYPE ( obj ) TYPE is ( FTValueDictionary ) valueDict => obj CLASS DEFAULT END SELECT END FUNCTION valueDictionaryFromObject ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTValueDictionary\") !> FUNCTION valueDictionaryClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTValueDictionary ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTValueDictionary\" IF ( self % refCount () >= 0 ) CONTINUE END FUNCTION valueDictionaryClassName END Module FTValueDictionaryClass","tags":"","loc":"sourcefile/ftvaluedictionaryclass.f90.html"},{"title":"FTDictionaryClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftdictionaryclass.f90~~EfferentGraph sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectclass.f90 sourcefile~hash.f90 Hash.f90 sourcefile~ftdictionaryclass.f90->sourcefile~hash.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ftdictionaryclass.f90~~AfferentGraph sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftstringsetclass.f90 FTStringSetClass.f90 sourcefile~ftstringsetclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftdictionaryclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTKeyObjectPairClass FTDictionaryClass Source Code FTDictionaryClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      FTDictionary.f90 !      Created: January 28, 2013 2:00 PM !      By: David Kopriva ! !//////////////////////////////////////////////////////////////////////// ! !>The FTKeyObjectPairClass is for use by the FTDictionary Class and will !>generally not be interacted with by the user. !> Module FTKeyObjectPairClass USE FTObjectClass IMPLICIT NONE ! !    ----------------- !    Module constants: !    ----------------- ! INTEGER , PARAMETER , PUBLIC :: FTDICT_KWD_STRING_LENGTH = 64 ! !        ---------- !        Class type !        ---------- ! TYPE , EXTENDS ( FTObject ) :: FTKeyObjectPair CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) :: keyString CLASS ( FTObject ) , POINTER :: valueObject => NULL () ! !           -------- CONTAINS !           -------- ! PROCEDURE :: initWithObjectAndKey FINAL :: destructFTKeyObjectPair PROCEDURE :: description => FTKeyObjectPairDescription PROCEDURE :: printDescription => printFTKeyObjectPairDescription PROCEDURE :: key PROCEDURE :: object END TYPE FTKeyObjectPair ! !        ======== CONTAINS !        ======== ! !@mark - ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithObjectAndKey ( self , v , key ) IMPLICIT NONE CLASS ( FTKeyObjectPair ) :: self CHARACTER ( LEN =* ) :: key CLASS ( FTObject ) , POINTER :: v CALL self % FTObject % init () self % keyString = key self % valueObject => v IF ( ASSOCIATED ( v )) CALL self % valueObject % retain () END SUBROUTINE initWithObjectAndKey ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTKeyObjectPair ( self ) IMPLICIT NONE TYPE ( FTKeyObjectPair ) , POINTER :: self CLASS ( FTObject ), POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTKeyObjectPair ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructFTKeyObjectPair ( self ) IMPLICIT NONE TYPE ( FTKeyObjectPair ) :: self self % keyString = \"\" CALL releaseFTObject ( self % valueObject ) END SUBROUTINE destructFTKeyObjectPair ! !//////////////////////////////////////////////////////////////////////// ! CHARACTER ( LEN = DESCRIPTION_CHARACTER_LENGTH ) FUNCTION FTKeyObjectPairDescription ( self ) IMPLICIT NONE CLASS ( FTKeyObjectPair ) :: self WRITE ( FTKeyObjectPairDescription , * ) \"(\" , TRIM ( self % keyString ) , \",\" & , TRIM ( self % valueObject % description ()) , \")\" END FUNCTION FTKeyObjectPairDescription ! !//////////////////////////////////////////////////////////////////////// ! RECURSIVE SUBROUTINE printFTKeyObjectPairDescription ( self , iUnit ) IMPLICIT NONE CLASS ( FTKeyObjectPair ) :: self INTEGER :: iUnit WRITE ( iUnit , * ) \"{\" IF ( ASSOCIATED ( self % valueObject )) THEN WRITE ( iUnit , '(6x,A,A3)' , ADVANCE = \"NO\" ) TRIM ( self % keyString ) , \" = \" CALL self % valueObject % printDescription ( iUnit ) ELSE WRITE ( iUnit , '(6x,A,A)' ) TRIM ( self % keyString ) , \" = NULL\" END IF WRITE ( iUnit , * ) \"}\" END SUBROUTINE printFTKeyObjectPairDescription ! !//////////////////////////////////////////////////////////////////////// ! CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) FUNCTION key ( self ) IMPLICIT NONE CLASS ( FTKeyObjectPair ) :: self key = self % keyString END FUNCTION key ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION object ( self ) IMPLICIT NONE CLASS ( FTKeyObjectPair ) :: self CLASS ( FTObject ), POINTER :: object object => self % valueObject END FUNCTION object END Module FTKeyObjectPairClass ! !//////////////////////////////////////////////////////////////////////// ! !@mark - !> !>A dictionary is a special case of a hash table that stores key-value pairs. !> !>It is an !>example of what is called an ``associative container''. In the implementation of FTObjectLibrary, !>the value can be any subclass of FTObject and the key is a character variable. The library !>includes the base dictionary that can store and retrieve any subclass of FTObject. It also includes a !>subclass that is designed to store and retrieve FTValue objects. !> !>FTDictionary (Inherits from FTObject) !> !>###Initialization !> !>         CLASS(FTDictionary), POINTER :: dict !>         ALLOCATE(dict) !>         CALL dict % initWithSize(N) ! N = size of dictionary. Should be power of two !> !>###Adding entries !> !>         CLASS(FTDictionary), POINTER :: dict !>         CLASS(FTObject)    , POINTER :: obj !>         CHARACTER(LEN=N)             :: key !>         obj => r                            ! r is subclass of FTObject !>         CALL dict % addObjectForKey(obj,key) !> !>###Accessing entries !> !>         obj => dict % objectForKey(key) !>         CALL cast(obj,v) ! v is the type of object to be extracted !> !>###Destruction !> !>         CALL releaseFTDictionary(dict) [Pointer] !>###Accessing an object !> !>           TYPE(FTObject) :: obj !>           obj => dict % objectForKey(key) !> !>###Converting a base class pointer to a dictionary !>           dict =>  dictionaryFromObject(obj) !> !>###Getting all of the keys !>           CHARACTER(LEN=FTDICT_KWD_STRING_LENGTH), POINTER :: keys(:) !>           keys =>  dict % allKeys() !>(The target of the pointer must be deallocated by the caller) !>###Getting all of the objects !>           CLASS(FTMutableObjectArray), POINTER :: objectArray !>           objectArray =>  dict % allObjects() ! The array is owned by the caller. !>(The target of the pointer must be released by the caller) !> Module FTDictionaryClass USE HashModule USE FTKeyObjectPairClass USE FTLinkedListClass USE FTLinkedListIteratorClass USE FTMutableObjectArrayClass IMPLICIT NONE TYPE , EXTENDS ( FTObject ) :: FTDictionary INTEGER :: numberOfEntries LOGICAL :: isCaseSensitive TYPE ( FTLinkedList ), DIMENSION (:), POINTER :: entries => NULL () ! !           -------- CONTAINS !           -------- ! PROCEDURE :: initWithSize PROCEDURE :: init PROCEDURE :: allKeys PROCEDURE :: allObjects FINAL :: destructFTDictionary PROCEDURE :: addObjectForKey PROCEDURE :: description => FTDictionaryDescription PROCEDURE :: printDescription => printFTDictionaryDescription PROCEDURE :: objectForKey PROCEDURE :: containsKey PROCEDURE :: className => dictionaryClassName PROCEDURE :: COUNT END TYPE FTDictionary INTERFACE cast MODULE PROCEDURE castToDictionary END INTERFACE cast ! !        ======== CONTAINS !        ======== ! ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE init ( self ) IMPLICIT NONE CLASS ( FTDictionary ) :: self CALL initWithSize ( self , 16 ) END SUBROUTINE init ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithSize ( self , sze ) ! !           ---------------------- !           Designated initializer !           ---------------------- ! IMPLICIT NONE CLASS ( FTDictionary ) :: self INTEGER , INTENT ( in ) :: sze INTEGER :: i CALL self % FTObject % init () self % isCaseSensitive = . true . self % numberOfEntries = 0 ! !           -------------------------------- !           Create the array of linked lists !           -------------------------------- ! ALLOCATE ( self % entries ( sze )) DO i = 1 , sze CALL self % entries ( i ) % init () END DO END SUBROUTINE initWithSize ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTDictionary ( self ) IMPLICIT NONE TYPE ( FTDictionary ) , POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTDictionary ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructFTDictionary ( self ) IMPLICIT NONE TYPE ( FTDictionary ) :: self DEALLOCATE ( self % entries ) self % entries => NULL () END SUBROUTINE destructFTDictionary ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION COUNT ( self ) IMPLICIT NONE CLASS ( FTDictionary ) :: self COUNT = self % numberOfEntries END FUNCTION COUNT ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addObjectForKey ( self , object , key ) IMPLICIT NONE CLASS ( FTDictionary ) :: self CLASS ( FTObject ) , POINTER :: object CHARACTER ( LEN =* ) :: key CLASS ( FTKeyObjectPair ), POINTER :: pair => NULL () CLASS ( FTObject ) , POINTER :: ptr => NULL () INTEGER :: h h = b3hs_hash_key_jenkins ( key , SIZE ( self % entries )) ALLOCATE ( pair ) CALL pair % initWithObjectAndKey ( object , key ) ptr => pair CALL self % entries ( h ) % add ( ptr ) CALL release ( self = ptr ) self % numberOfEntries = self % numberOfEntries + 1 END SUBROUTINE addObjectForKey ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION objectForKey ( self , key ) IMPLICIT NONE CLASS ( FTDictionary ) :: self CHARACTER ( LEN =* ) :: key CLASS ( FTObject ) , POINTER :: objectForKey INTEGER :: h CLASS ( FTLinkedListRecord ) , POINTER :: listRecordPtr => NULL () CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) :: keyString objectForKey => NULL () IF ( self % COUNT () == 0 ) RETURN ! !           ------------- !           Find the hash !           ------------- ! h = b3hs_hash_key_jenkins ( key , SIZE ( self % entries )) IF ( self % entries ( h ) % COUNT () > 0 ) THEN ! !              ----------------------- !              Search through the list !              ----------------------- ! listRecordPtr => self % entries ( h ) % head DO WHILE ( ASSOCIATED ( listRecordPtr )) ! !                 -------------------------------------------- !                 The list's recordObject is a FTKeyObjectPair !                 -------------------------------------------- ! SELECT TYPE ( pair => listRecordPtr % recordObject ) TYPE is ( FTKeyObjectPair ) keyString = pair % keyString IF ( TRIM ( keyString ) == TRIM ( key ) . AND . & ASSOCIATED ( pair % valueObject ) ) THEN objectForKey => pair % valueObject EXIT END IF CLASS DEFAULT END SELECT listRecordPtr => listRecordPtr % next END DO END IF END FUNCTION ObjectForKey ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION containsKey ( self , key ) RESULT ( r ) IMPLICIT NONE CLASS ( FTDictionary ) :: self CHARACTER ( LEN =* ) :: key LOGICAL :: r IF ( ASSOCIATED ( self % objectForKey ( key )) ) THEN r = . TRUE . ELSE r = . FALSE . END IF END FUNCTION containsKey ! !//////////////////////////////////////////////////////////////////////// ! CHARACTER ( LEN = DESCRIPTION_CHARACTER_LENGTH ) FUNCTION FTDictionaryDescription ( self ) IMPLICIT NONE CLASS ( FTDictionary ) :: self CHARACTER ( LEN = DESCRIPTION_CHARACTER_LENGTH ) :: s INTEGER :: i FTDictionaryDescription = \"\" IF ( SELF % COUNT () == 0 ) RETURN DO i = 1 , SIZE ( self % entries ) s = self % entries ( i ) % description () IF ( LEN_TRIM ( s ) > 0 ) THEN FTDictionaryDescription = TRIM ( FTDictionaryDescription ) // & TRIM ( self % entries ( i ) % description ()) // & CHAR ( 13 ) END IF END DO END FUNCTION FTDictionaryDescription ! !//////////////////////////////////////////////////////////////////////// ! RECURSIVE SUBROUTINE printFTDictionaryDescription ( self , iUnit ) IMPLICIT NONE CLASS ( FTDictionary ) :: self INTEGER :: iUnit INTEGER :: i IF ( SELF % COUNT () == 0 ) THEN WRITE ( iUnit , * ) \"Empty Dictionary\" END IF DO i = 1 , SIZE ( self % entries ) CALL self % entries ( i ) % printDescription ( iUnit ) END DO END SUBROUTINE printFTDictionaryDescription ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION AllObjects ( self ) RESULT ( objectArray ) IMPLICIT NONE ! !           --------- !           Arguments !           --------- ! CLASS ( FTDictionary ) :: self CLASS ( FTMutableObjectArray ), POINTER :: objectArray ! !           --------------- !           Local Variables !           --------------- ! INTEGER :: i CLASS ( FTLinkedListRecord ) , POINTER :: listRecordPtr => NULL () CLASS ( FTObject ) , POINTER :: obj => NULL () CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) :: keyString ! !           -------------------------------------------- !           Allocate a pointer to the object array to be !           returned with refCount = 1 !           -------------------------------------------- ! ALLOCATE ( objectArray ) CALL objectArray % initWithSize ( arraySize = self % COUNT ()) DO i = 1 , SIZE ( self % entries ) listRecordPtr => self % entries ( i ) % head DO WHILE ( ASSOCIATED ( listRecordPtr )) ! !                 -------------------------------------------- !                 The list's recordObject is a FTKeyObjectPair !                 -------------------------------------------- ! SELECT TYPE ( pair => listRecordPtr % recordObject ) TYPE is ( FTKeyObjectPair ) keyString = pair % key () obj => pair % object () CALL objectArray % addObject ( obj ) CLASS DEFAULT END SELECT listRecordPtr => listRecordPtr % next END DO END DO END FUNCTION AllObjects ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION AllKeys ( self ) RESULT ( keys ) IMPLICIT NONE ! !           --------- !           Arguments !           --------- ! CLASS ( FTDictionary ) :: self CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ), POINTER :: keys (:) ! !           --------------- !           Local Variables !           --------------- ! INTEGER :: i , c CLASS ( FTLinkedListRecord ) , POINTER :: listRecordPtr => NULL () CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) :: keyString ! !           --------------------------------------- !           Allocate a pointer array to be returned !           --------------------------------------- ! ALLOCATE ( keys ( self % COUNT ())) c = 1 DO i = 1 , SIZE ( self % entries ) listRecordPtr => self % entries ( i ) % head DO WHILE ( ASSOCIATED ( listRecordPtr )) ! !                 -------------------------------------------- !                 The list's recordObject is a FTKeyObjectPair !                 -------------------------------------------- ! SELECT TYPE ( pair => listRecordPtr % recordObject ) TYPE is ( FTKeyObjectPair ) keyString = pair % key () keys ( c ) = keyString CLASS DEFAULT END SELECT c = c + 1 listRecordPtr => listRecordPtr % next END DO END DO END FUNCTION AllKeys ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE castToDictionary ( obj , cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTDictionary ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTDictionary ) cast => e CLASS DEFAULT END SELECT END SUBROUTINE castToDictionary ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION dictionaryFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTDictionary ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTDictionary ) cast => e CLASS DEFAULT END SELECT END FUNCTION dictionaryFromObject ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTDictionary\") !> FUNCTION dictionaryClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTDictionary ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTDictionary\" IF ( self % refCount () >= 0 ) CONTINUE ! No op To silence unused vsariable warnings END FUNCTION dictionaryClassName END Module FTDictionaryClass","tags":"","loc":"sourcefile/ftdictionaryclass.f90.html"},{"title":"FTValueClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftvalueclass.f90~~EfferentGraph sourcefile~ftvalueclass.f90 FTValueClass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftvalueclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftolconstants.f90 FTOLConstants.f90 sourcefile~ftvalueclass.f90->sourcefile~ftolconstants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ftvalueclass.f90~~AfferentGraph sourcefile~ftvalueclass.f90 FTValueClass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvalueclass.f90 sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftvalueclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTValueClass Source Code FTValueClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! ! !> A not completely F2003/2008 version of an immutable class !> to store primitive values: integer, real, double precision, logical, !> character. (To Add: complex) !> !> This version does not use CLASS(*) or deferred length strings !> so that it can be used with gfortran 4.7/4.8 !> !> Usage: !> ------ !> !> - Initialization !> !>            TYPE(FTValue) :: r, i, s, l, d !> !>            CALL r % initValue(3.14) !>            CALL i % initValue(6) !>            CALL d % initValue(3.14d0) !>            CALL l % initValue(.true.) !>            CALL s % initValue(\"A string\") !> !> - Destruction !> !>            call releaseFTValue(r) [Pointers] !> !> - Accessors !> !>            real = r % realValue() !>            int  = i % integerValue() !>            doub = d % doublePrecisionValue() !>            logc = l % logicalValue() !>            str  = s % stringValue(nChars) !> !> - Description !> !>            str = v % description() !>            call v % printDescription(unit) !> !> - Casting !> !>            CLASS(FTVALUE) , POINTER :: v !>            CLASS(FTObject), POINTER :: obj !>            call cast(obj,v) !> !> The class will attempt to convert between the different types: !> !>            CALL r % initWithReal(3.14) !>            print *, r % stringValue(8) !> !>            Logical variables rules: !> !>            real, doublePrecision, integer values !>               logicalValue = .FALSE. if input = 0 !>               logicalValue = .TRUE.  if input /= 0 !> !> String values can be converted to numeric types. If the string is !> not a numeric, Huge(1) will be returned, for integers and NaN for reals. !> !< ! FTValueClass.f90 ! Created: January 9, 2013 12:20 PM !> @author David Kopriva !< ! !//////////////////////////////////////////////////////////////////////// ! Module FTValueClass USE IEEE_ARITHMETIC USE ISO_FORTRAN_ENV USE FTOLConstants USE FTObjectClass IMPLICIT NONE ! !     ---------------- !     Public constants !     ---------------- ! INTEGER , PARAMETER :: FTVALUE_NOT_INTEGER = HUGE ( 1 ) REAL , PARAMETER :: FTVALUE_NOT_REAL = HUGE ( 1.0 ) DOUBLE PRECISION , PARAMETER :: FTVALUE_NOT_DOUBLEPRECISION = HUGE ( 1.0D0 ) INTEGER , PARAMETER :: FTVALUE_STRING_LENGTH = 512 ! Until vary length strings are available. INTEGER , PARAMETER :: FT_REAL_KIND = SELECTED_REAL_KIND ( 6 ) INTEGER , PARAMETER :: FT_DOUBLE_PRECISION_KIND = SELECTED_REAL_KIND ( 15 ) ! !     ----------------- !     Private constants !     ----------------- ! INTEGER , PARAMETER , PRIVATE :: FTVALUECLASS_INTEGER = 1 , FTVALUECLASS_REAL = 2 , & FTVALUECLASS_DOUBLE = 3 , FTVALUECLASS_STRING = 4 , & FTVALUECLASS_LOGICAL = 5 , FTVALUECLASS_QUAD = 6 ! !     --------------------- !     Class type definition !     --------------------- ! TYPE , EXTENDS ( FTObject ) :: FTValue PRIVATE INTEGER :: valueType CHARACTER ( LEN = 1 ), ALLOCATABLE :: valueStorage (:) ! !        ======== CONTAINS !        ======== ! !        -------------- !        Initialization !        -------------- ! PROCEDURE , PRIVATE :: initWithReal PROCEDURE , PRIVATE :: initWithDoublePrecision PROCEDURE , PRIVATE :: initWithString PROCEDURE , PRIVATE :: initWithLogical PROCEDURE , PRIVATE :: initWithInteger GENERIC , PUBLIC :: initWithValue => initWithReal , initWithDoublePrecision , & initWithString , initWithLogical , & initWithInteger #ifdef _has_Quad PROCEDURE , PRIVATE :: initWithQuad GENERIC , PUBLIC :: initWithValue => initWithQuad #endif ! !        ----------- !        Destruction !        ----------- ! FINAL :: destructValue ! !        ------- !        Getters !        ------- ! PROCEDURE :: realValue PROCEDURE :: doublePrecisionValue #ifdef _has_Quad PROCEDURE :: quadValue #endif PROCEDURE :: stringValue PROCEDURE :: logicalValue PROCEDURE :: integerValue ! !        ----------- !        Description !        ----------- ! PROCEDURE :: description => FTValueDescription PROCEDURE :: printDescription => printValueDescription PROCEDURE :: className => valueClassName ! !        ---------- !        Comparison !        ---------- ! !         PROCEDURE, PRIVATE :: isEqualTo => isEqualToFTValue END TYPE FTValue INTERFACE cast MODULE PROCEDURE castToValue END INTERFACE cast !     ---------- !     Procedures !     ---------- ! CONTAINS !@mark - ! ! !------------------------------------------------ !> Public, generic name: initwithValue() !> !> Initialize the value object with a real number !------------------------------------------------ ! ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithReal ( self , v ) IMPLICIT NONE CLASS ( FTValue ) :: self REAL :: v INTEGER :: dataLength CALL self % FTObject % init () dataLength = SIZE ( TRANSFER ( v , self % valueStorage )) ALLOCATE ( self % valueStorage ( dataLength )) self % valueStorage = TRANSFER ( v , self % valueStorage ) self % valueType = FTVALUECLASS_REAL END SUBROUTINE initWithReal ! !----------------------------------------------- !> Public, generic name: initwithValue() !> !> Initialize the value object with a double !> precision number !----------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithDoublePrecision ( self , v ) IMPLICIT NONE CLASS ( FTValue ) :: self DoublePrecision :: v INTEGER :: dataLength CALL self % FTObject % init dataLength = SIZE ( TRANSFER ( v , self % valueStorage )) ALLOCATE ( self % valueStorage ( dataLength )) self % valueStorage = TRANSFER ( v , self % valueStorage ) self % valueType = FTVALUECLASS_DOUBLE END SUBROUTINE initWithDoublePrecision ! !--------------------------------------------------- !> Public, generic name: initwithValue() !> !> Initialize the value object with a quad precision !> number !--------------------------------------------------- ! ! !//////////////////////////////////////////////////////////////////////// ! #ifdef _has_Quad SUBROUTINE initWithQuad ( self , v ) IMPLICIT NONE CLASS ( FTValue ) :: self REAL ( KIND = SELECTED_REAL_KIND ( QUAD_DIGITS )) :: v INTEGER :: dataLength CALL self % FTObject % init () dataLength = SIZE ( TRANSFER ( v , self % valueStorage )) ALLOCATE ( self % valueStorage ( dataLength )) self % valueStorage = TRANSFER ( v , self % valueStorage ) self % valueType = FTVALUECLASS_QUAD END SUBROUTINE initWithQuad #endif ! !----------------------------------------------- !> Public, generic name: initwithValue() !> !> Initialize the value object with an !> integer number !----------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithInteger ( self , v ) IMPLICIT NONE CLASS ( FTValue ) :: self INTEGER :: v INTEGER :: dataLength CALL self % FTObject % init dataLength = SIZE ( TRANSFER ( v , self % valueStorage )) ALLOCATE ( self % valueStorage ( dataLength )) self % valueStorage = TRANSFER ( v , self % valueStorage ) self % valueType = FTVALUECLASS_INTEGER END SUBROUTINE initWithInteger ! !----------------------------------------------- !> Public, generic name: initwithValue() !> !> Initialize the value object with a logical !----------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithLogical ( self , v ) IMPLICIT NONE CLASS ( FTValue ) :: self LOGICAL :: v INTEGER :: dataLength CALL self % FTObject % init dataLength = SIZE ( TRANSFER ( v , self % valueStorage )) ALLOCATE ( self % valueStorage ( dataLength )) self % valueStorage = TRANSFER ( v , self % valueStorage ) self % valueType = FTVALUECLASS_LOGICAL END SUBROUTINE initWithLogical ! !----------------------------------------------- !> Public, generic name: initwithValue() !> !> Initialize the value object with a string !----------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initWithString ( self , v ) IMPLICIT NONE CLASS ( FTValue ) :: self CHARACTER ( LEN =* ) :: v INTEGER :: dataLength CALL self % FTObject % init dataLength = LEN_TRIM ( v ) ALLOCATE ( self % valueStorage ( dataLength )) self % valueStorage = TRANSFER ( trim ( v ), self % valueStorage ) self % valueType = FTVALUECLASS_STRING END SUBROUTINE initWithString !@mark - ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTValue ( self ) IMPLICIT NONE TYPE ( FTValue ) , POINTER :: self CLASS ( FTObject ), POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTValue ! !------------------------------------------------ !> Public, generic name: destruct() !> !> Destructor for the class. !------------------------------------------------ ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE destructValue ( self ) IMPLICIT NONE TYPE ( FTValue ) :: self IF ( ALLOCATED ( self % valueStorage )) DEALLOCATE ( self % valueStorage ) END SUBROUTINE destructValue ! !@mark - ! !--------------------------------------------------------------- !> Get the real value stored in the object, or convert the value !> in the object to a real if it is of a different type. !--------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! REAL FUNCTION realValue ( self ) IMPLICIT NONE CLASS ( FTValue ) :: self INTEGER :: iErr INTEGER :: i DOUBLE PRECISION :: d LOGICAL :: l CHARACTER ( LEN = FTVALUE_STRING_LENGTH ) :: s , tmpString SELECT CASE ( self % valueType ) CASE ( FTVALUECLASS_INTEGER ) i = TRANSFER ( self % valueStorage , i ) realValue = REAL ( i ) CASE ( FTVALUECLASS_DOUBLE ) d = TRANSFER ( self % valueStorage , d ) realValue = REAL ( d ) CASE ( FTVALUECLASS_REAL ) realValue = TRANSFER ( self % valueStorage , realValue ) CASE ( FTVALUECLASS_STRING ) tmpString = TRANSFER ( self % valueStorage , tmpString ) s = tmpString ( 1 : SIZE ( self % valueStorage )) READ ( s , * , IOSTAT = iErr ) realValue IF ( iErr /= 0 ) THEN realValue = IEEE_VALUE ( realValue , IEEE_QUIET_NAN ) END IF CASE ( FTVALUECLASS_LOGICAL ) l = TRANSFER ( self % valueStorage , l ) IF ( l ) THEN realValue = 1.0 ELSE realValue = 0.0 END IF END SELECT END FUNCTION realValue ! !--------------------------------------------------------------------------- !> Get the double precision value stored in the object, or convert the value !> in the object to a double precision if it is of a different type. !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! DOUBLE PRECISION FUNCTION doublePrecisionValue ( self ) IMPLICIT NONE CLASS ( FTValue ) :: self INTEGER :: iErr REAL :: r INTEGER :: i LOGICAL :: l CHARACTER ( LEN = FTVALUE_STRING_LENGTH ) :: s , tmpString SELECT CASE ( self % valueType ) CASE ( FTVALUECLASS_INTEGER ) i = TRANSFER ( self % valueStorage , i ) doublePrecisionValue = DBLE ( i ) CASE ( FTVALUECLASS_REAL ) r = TRANSFER ( self % valueStorage , r ) doublePrecisionValue = DBLE ( r ) CASE ( FTVALUECLASS_DOUBLE ) doublePrecisionValue = TRANSFER ( self % valueStorage , doublePrecisionValue ) CASE ( FTVALUECLASS_STRING ) tmpString = TRANSFER ( self % valueStorage , tmpString ) s = tmpString ( 1 : SIZE ( self % valueStorage )) READ ( s , * , IOSTAT = iErr ) doublePrecisionValue IF ( iErr /= 0 ) THEN doublePrecisionValue = IEEE_VALUE ( doublePrecisionValue , IEEE_QUIET_NAN ) END IF CASE ( FTVALUECLASS_LOGICAL ) l = TRANSFER ( self % valueStorage , l ) IF ( l ) THEN doublePrecisionValue = 1.0d0 ELSE doublePrecisionValue = 0.0d0 END IF END SELECT END FUNCTION doublePrecisionValue ! !--------------------------------------------------------------------------- !> Get the double precision value stored in the object, or convert the value !> in the object to a double precision if it is of a different type. !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! #ifdef _has_Quad DOUBLE PRECISION FUNCTION quadValue ( self ) IMPLICIT NONE CLASS ( FTValue ) :: self INTEGER :: iErr REAL :: r INTEGER :: i LOGICAL :: l CHARACTER ( LEN = FTVALUE_STRING_LENGTH ) :: s , tmpString SELECT CASE ( self % valueType ) CASE ( FTVALUECLASS_INTEGER ) i = TRANSFER ( self % valueStorage , i ) quadValue = REAL ( A = i , KIND = SELECTED_REAL_KIND ( QUAD_DIGITS )) CASE ( FTVALUECLASS_REAL ) r = TRANSFER ( self % valueStorage , r ) quadValue = REAL ( A = r , KIND = SELECTED_REAL_KIND ( QUAD_DIGITS )) CASE ( FTVALUECLASS_DOUBLE ) quadValue = TRANSFER ( self % valueStorage , quadValue ) CASE ( FTVALUECLASS_STRING ) tmpString = TRANSFER ( self % valueStorage , tmpString ) s = tmpString ( 1 : SIZE ( self % valueStorage )) READ ( s , * , IOSTAT = iErr ) quadValue IF ( iErr /= 0 ) THEN quadValue = IEEE_VALUE ( quadValue , IEEE_QUIET_NAN ) END IF CASE ( FTVALUECLASS_LOGICAL ) l = TRANSFER ( self % valueStorage , l ) IF ( l ) THEN quadValue = 1.0 ELSE quadValue = 0.0 END IF END SELECT END FUNCTION quadValue #endif ! !--------------------------------------------------------------------------- !> Get the integer value stored in the object, or convert the value !> in the object to an integer if it is of a different type. !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION integerValue ( self ) IMPLICIT NONE CLASS ( FTValue ) :: self INTEGER :: iErr REAL :: r INTEGER :: i DOUBLE PRECISION :: d LOGICAL :: l CHARACTER ( LEN = FTVALUE_STRING_LENGTH ) :: s , tmpString SELECT CASE ( self % valueType ) CASE ( FTVALUECLASS_INTEGER ) integerValue = TRANSFER ( self % valueStorage , i ) CASE ( FTVALUECLASS_DOUBLE ) d = TRANSFER ( self % valueStorage , d ) integerValue = INT ( d ) CASE ( FTVALUECLASS_REAL ) r = TRANSFER ( self % valueStorage , r ) integerValue = INT ( r ) CASE ( FTVALUECLASS_STRING ) tmpString = TRANSFER ( self % valueStorage , tmpString ) s = tmpString ( 1 : SIZE ( self % valueStorage )) READ ( s , * , IOSTAT = iErr ) integerValue IF ( iErr /= 0 ) THEN integerValue = HUGE ( 1 ) END IF CASE ( FTVALUECLASS_LOGICAL ) l = TRANSFER ( self % valueStorage , l ) IF ( l ) THEN integerValue = 1 ELSE integerValue = 0 END IF END SELECT END FUNCTION integerValue ! !--------------------------------------------------------------------------- !> Get the logical value stored in the object, or convert the value !> in the object to a logical if it is of a different type. !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION logicalValue ( self ) IMPLICIT NONE CLASS ( FTValue ) :: self REAL :: r INTEGER :: i DOUBLE PRECISION :: d LOGICAL :: l CHARACTER ( LEN = FTVALUE_STRING_LENGTH ) :: s , tmpString SELECT CASE ( self % valueType ) CASE ( FTVALUECLASS_INTEGER ) i = TRANSFER ( self % valueStorage , i ) IF ( i /= 0 ) THEN logicalValue = . true . ELSE logicalValue = . false . END IF CASE ( FTVALUECLASS_DOUBLE ) d = TRANSFER ( self % valueStorage , d ) IF ( d /= 0.0d0 ) THEN logicalValue = . true . ELSE logicalValue = . false . END IF CASE ( FTVALUECLASS_REAL ) r = TRANSFER ( self % valueStorage , r ) IF ( r /= 0.0 ) THEN logicalValue = . true . ELSE logicalValue = . false . END IF CASE ( FTVALUECLASS_STRING ) tmpString = TRANSFER ( self % valueStorage , tmpString ) s = tmpString ( 1 : SIZE ( self % valueStorage )) IF ( TRIM ( s ) == \".true.\" . OR . TRIM ( s ) == \".false.\" . OR . & TRIM ( s ) == \".TRUE.\" . OR . TRIM ( s ) == \".FALSE.\" ) THEN READ ( s , * ) logicalValue ELSE logicalValue = . false . END IF CASE ( FTVALUECLASS_LOGICAL ) logicalValue = TRANSFER ( self % valueStorage , l ) END SELECT END FUNCTION logicalValue ! !--------------------------------------------------------------------------- !> Get the string value of length requestedLength stored in the object, or !> convert the value !> in the object to a string of that length if it is of a different type. !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION stringValue ( self , requestedLength ) RESULT ( s ) IMPLICIT NONE CLASS ( FTValue ) :: self INTEGER :: requestedLength CHARACTER ( LEN = requestedLength ) :: s CHARACTER ( LEN = FTVALUE_STRING_LENGTH ) :: tmpString REAL :: r INTEGER :: i DOUBLE PRECISION :: d LOGICAL :: l SELECT CASE ( self % valueType ) CASE ( FTVALUECLASS_INTEGER ) i = TRANSFER ( self % valueStorage , i ) WRITE ( tmpString , * ) i s = TRIM ( ADJUSTL ( tmpString )) CASE ( FTVALUECLASS_DOUBLE ) d = TRANSFER ( self % valueStorage , d ) WRITE ( tmpString , * ) d s = TRIM ( ADJUSTL ( tmpString )) CASE ( FTVALUECLASS_REAL ) r = TRANSFER ( self % valueStorage , r ) WRITE ( tmpString , * ) r s = TRIM ( ADJUSTL ( tmpString )) CASE ( FTVALUECLASS_STRING ) tmpString = TRANSFER ( self % valueStorage , tmpString ) s = tmpString ( 1 : SIZE ( self % valueStorage )) CASE ( FTVALUECLASS_LOGICAL ) l = TRANSFER ( self % valueStorage , l ) IF ( l ) THEN s = \"TRUE\" ELSE s = \"FALSE\" END IF END SELECT END FUNCTION stringValue !@mark - ! !--------------------------------------------------------------------------- !> Returns the description of the value. In this case, it returns the !> stringValue() of the object. !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION FTValueDescription ( self ) IMPLICIT NONE CLASS ( FTValue ) :: self CHARACTER ( LEN = DESCRIPTION_CHARACTER_LENGTH ) :: FTValueDescription FTValueDescription = self % stringValue ( DESCRIPTION_CHARACTER_LENGTH ) END FUNCTION FTValueDescription ! !--------------------------------------------------------------------------- !> Prints the description of the value to unit iUnit. In this case, it prints !> the stringValue() of the object. !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE printValueDescription ( self , iUnit ) IMPLICIT NONE CLASS ( FTValue ) :: self INTEGER :: iUnit WRITE ( iUnit , * ) TRIM ( self % description ()) END SUBROUTINE printValueDescription ! !--------------------------------------------------------------------------- !> Generic Name: cast !> !> Cast a pointer to the base class to an FTValue pointer !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE castToValue ( obj , cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTValue class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ), POINTER :: obj CLASS ( FTValue ) , POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTValue ) cast => e CLASS DEFAULT END SELECT END SUBROUTINE castToValue ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION valueFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTValue class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ), POINTER :: obj CLASS ( FTValue ) , POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTValue ) cast => e CLASS DEFAULT END SELECT END FUNCTION valueFromObject ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTValue\") !> FUNCTION valueClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTValue ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTValue\" IF ( self % refCount () >= 0 ) CONTINUE END FUNCTION valueClassName END MODULE FTValueClass","tags":"","loc":"sourcefile/ftvalueclass.f90.html"},{"title":"FTStringSetClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftstringsetclass.f90~~EfferentGraph sourcefile~ftstringsetclass.f90 FTStringSetClass.f90 sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftstringsetclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftstringsetclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~hash.f90 Hash.f90 sourcefile~ftdictionaryclass.f90->sourcefile~hash.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTStringSetClass Source Code FTStringSetClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      FTStringSet.f90 ! !>FTStringSet is a class for an unordered collection of strings. Use a FTStringSet !>to store strings as an alternative to arrays when the order is not important, but !>testing for membership is. !> !>##Definition !>           TYPE(FTStringSet) :: varName !>#Usage !>##Initialization !>       CLASS(FTStringSet)  :: FTStringSet !>       integer             :: N = 11 !>       logical             :: cs = .true. !>       CALL FTStringSet % initFTStringSet(N,cs) !> !>       CLASS(FTStringSet)  :: FTStringSet !>       CHARACTER(LEN=*)    :: strings(:) !>       CALL FTStringSet % initWithStrings(strings) !> !>#Destruction !>      CALL FTStringSet  %  destuct() [Non Pointers] !>      CALL releaseFTStringSet(stringSet) [Pointers] !>#Adding Strings !>         CALL set % addString(str) !>#Testing membership: !>      if(set % containsString(str))     THEN !>#Getting an array of members !>      CHARACTER(LEN=FTDICT_KWD_STRING_LENGTH) ,DIMENSION(:), POINTER :: s !>      s => set % strings !>      ... do something ... !>      DEALLOCATE(s) !>#Set operations, union, intersection, difference !>      newSet => set1 % unionWithSet(set2) !>      ... do something ... !>      call releaseFTStringSet(newSet) !> !>      newSet => set1 % intersectionWithSet(set2) !>      ... do something ... !>      call releaseFTStringSet(newSet) !> !>      newSet => set1 % setFromDifference(set2) !>      ... do something ... !>      call releaseFTStringSet(newSet) ! ! !//////////////////////////////////////////////////////////////////////// ! MODULE FTStringSetClass USE FTObjectClass USE FTDictionaryClass IMPLICIT NONE TYPE , EXTENDS ( FTObject ) :: FTStringSet TYPE ( FTDictionary ), PRIVATE :: dict ! !        -------- CONTAINS !        -------- ! PROCEDURE , PUBLIC :: initFTStringSet PROCEDURE , PUBLIC :: initWithStrings FINAL :: destructFTStringSet PROCEDURE , PUBLIC :: addString PROCEDURE , PUBLIC :: containsString PROCEDURE , PUBLIC :: strings PROCEDURE , PUBLIC :: unionWithSet PROCEDURE , PUBLIC :: intersectionWithSet !         PROCEDURE, PUBLIC :: setIsCaseSensitive !         PROCEDURE, PUBLIC :: isCaseSensitive PROCEDURE , PUBLIC :: setFromDifference PROCEDURE , PUBLIC :: isEmpty PROCEDURE , PUBLIC :: count => stringCount PROCEDURE , PUBLIC :: printDescription => printFTStringSet PROCEDURE , PUBLIC :: className => FTStringSetClassName ! END TYPE !      INTERFACE cast !         MODULE PROCEDURE castToFTStringSet !      END INTERFACE cast ! !     ======== CONTAINS !     ======== ! ! !//////////////////////////////////////////////////////////////////////// ! !> !> Designated initializer. Initializes the amount of storage, but !> the FTStringSet remains empty. !> !> *Usage !>       CLASS(FTStringSet)  :: FTStringSet !>       integer             :: N = 11 !>       logical             :: cs = .true. !>       CALL FTStringSet % initFTStringSet(N) !> SUBROUTINE initFTStringSet ( self , FTStringSetSize ) IMPLICIT NONE CLASS ( FTStringSet ) :: self INTEGER :: FTStringSetSize CALL self % FTObject % init () CALL self % dict % initWithSize ( sze = FTStringSetSize ) !         self % dict % isCaseSensitive = caseSensitive END SUBROUTINE initFTStringSet ! !//////////////////////////////////////////////////////////////////////// ! !> !>  initializer. Initializes the amount of storage from the strings passed !> *Usage !>       CLASS(FTStringSet)  :: FTStringSet !>       CHARACTER(LEN=*)    :: strings(:) !>       CALL FTStringSet % initWithStrings(strings) !> SUBROUTINE initWithStrings ( self , strings ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTStringSet ) :: self CHARACTER ( LEN =* ) :: strings (:) ! !        --------------- !        Local variables !        --------------- ! INTEGER :: stringCount , i , dictSize stringCount = SIZE ( strings ) dictSize = 2 ** EXPONENT ( REAL ( stringCount )) ! Makes it a factor of two CALL self % initFTStringSet ( FTStringSetSize = dictSize ) DO i = 1 , stringCount CALL self % addString ( str = STRINGs ( i )) END DO END SUBROUTINE initWithStrings ! !//////////////////////////////////////////////////////////////////////// ! !> !> Destructor for the class. This is called automatically when the !> reference count reaches zero. Do not call this yourself on pointers !> SUBROUTINE destructFTStringSet ( self ) IMPLICIT NONE TYPE ( FTStringSet ) :: self END SUBROUTINE destructFTStringSet ! !------------------------------------------------ !> Public, generic name: release(self) !> !> Call release(self) on an object to release control !> of an object. If its reference count is zero, then !> it is deallocated. !------------------------------------------------ ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTStringSet ( self ) IMPLICIT NONE TYPE ( FTStringSet ) , POINTER :: self CLASS ( FTObject ) , POINTER :: obj obj => self CALL release ( self = obj ) IF ( . NOT . ASSOCIATED ( obj ) ) THEN NULLIFY ( self ) END IF END SUBROUTINE releaseFTStringSet ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION stringCount ( self ) IMPLICIT NONE CLASS ( FTStringSet ) :: self stringCount = self % dict % COUNT () END FUNCTION stringCount ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> AddString adds a string to the set if it is not already present !> !>### Usage: !>        CALL set % addString(str) !> SUBROUTINE AddString ( self , str ) IMPLICIT NONE CLASS ( FTStringSet ) :: self CHARACTER ( LEN =* ) :: str CLASS ( FTObject ) , POINTER :: obj IF ( self % dict % containsKey ( key = str )) RETURN ALLOCATE ( obj ) CALL obj % init () CALL self % dict % addObjectForKey ( object = obj , key = str ) CALL release ( obj ) END SUBROUTINE AddString ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> containsString returns .TRUE. if the set contains the string, .FALSE. !> otherwise. !> !>### Usage: !>        if(set % containsString(str)) !> LOGICAL FUNCTION containsString ( self , str ) IMPLICIT NONE CLASS ( FTStringSet ) :: self CHARACTER ( LEN =* ) :: str containsString = self % dict % containsKey ( key = str ) END FUNCTION containsString ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> strings returns a pointer to an array of strings that are in the set. !> Deallocate this array when done with it. !> !>### Usage: !> !>      CHARACTER(LEN=FTDICT_KWD_STRING_LENGTH) ,DIMENSION(:), POINTER :: s !>      s => set % strings !>      ... do something ... !>      DEALLOCATE(s) !> FUNCTION strings ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTStringSet ) :: self CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) , DIMENSION (:), POINTER :: s s => self % dict % allKeys () END FUNCTION strings ! !//////////////////////////////////////////////////////////////////////// ! !> unionWithSet returns a pointer to a new set that is the union of two sets. !> the new set has reference count of 1. Release when done. !> !>### Usage: !> !>      newSet => set1 % unionWithSet(set2) !>      ... do something ... !>      call releaseFTStringSet(newSet) ! FUNCTION unionWithSet ( self , set ) RESULT ( newSet ) IMPLICIT NONE CLASS ( FTStringSet ) :: self , set CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) , DIMENSION (:), POINTER :: s1 , s2 INTEGER :: i TYPE ( FTStringSet ), POINTER :: newSet ALLOCATE ( newSet ) s1 => self % strings () CALL newSet % initWithStrings ( strings = s1 ) DEALLOCATE ( s1 ) s2 => set % strings () DO i = 1 , SIZE ( s2 ) CALL newSet % addString ( str = s2 ( i )) END DO DEALLOCATE ( s2 ) END FUNCTION unionWithSet ! !//////////////////////////////////////////////////////////////////////// ! !> intersectionWithSet returns a pointer to a new set that is the intersection of two sets. !> the new set has reference count of 1. Release when done. !> !>### Usage: !> !>      newSet => set1 % intersectionWithSet(set2) !>      ... do something ... !>      call releaseFTStringSet(newSet) ! FUNCTION intersectionWithSet ( self , set ) RESULT ( newSet ) IMPLICIT NONE CLASS ( FTStringSet ) :: self , set CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) , DIMENSION (:), POINTER :: strArray INTEGER :: i TYPE ( FTStringSet ), POINTER :: newSet ALLOCATE ( newSet ) CALL newSet % initFTStringSet ( FTStringSetSize = 16 ) strArray => self % strings () IF (. NOT . ASSOCIATED ( strArray )) RETURN DO i = 1 , SIZE ( strArray ) IF ( set % containsString ( str = strArray ( i )) ) THEN CALL newSet % addString ( str = strArray ( i )) END IF END DO DEALLOCATE ( strArray ) END FUNCTION intersectionWithSet ! !//////////////////////////////////////////////////////////////////////// ! !> setFromDifference returns a pointer to a new set that is the difference of two sets. !> A - B = \\{x: x \\in A \\;\\rm{ and }\\; x\\notin B\\} !> the new set has reference count of 1. Release when done. !> !>### Usage: !> !>      newSet => set1 % setFromDifference(set2) !>      ... do something ... !>      call releaseFTStringSet(newSet) ! FUNCTION setFromDifference ( self , set ) RESULT ( newSet ) IMPLICIT NONE CLASS ( FTStringSet ) :: self , set CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ) , DIMENSION (:), POINTER :: strArray INTEGER :: i TYPE ( FTStringSet ), POINTER :: newSet ALLOCATE ( newSet ) CALL newSet % initFTStringSet ( FTStringSetSize = MAX ( self % count (), 8 )) IF ( self % count () == 0 ) RETURN strArray => self % strings () IF (. NOT . ASSOCIATED ( strArray )) RETURN DO i = 1 , SIZE ( strArray ) IF ( . NOT . set % containsString ( str = strArray ( i )) ) THEN CALL newSet % addString ( str = strArray ( i )) END IF END DO DEALLOCATE ( strArray ) END FUNCTION setFromDifference ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isEmpty ( self ) IMPLICIT NONE CLASS ( FTStringSet ) :: self isEmpty = . TRUE . IF ( self % count () > 0 ) isEmpty = . FALSE . END FUNCTION isEmpty ! !//////////////////////////////////////////////////////////////////////// ! !      SUBROUTINE setIsCaseSensitive(self,sensitive) !         IMPLICIT NONE !         CLASS(FTStringSet) :: self !         LOGICAL            :: sensitive !         self % dict % isCaseSensitive = sensitive !      END SUBROUTINE setIsCaseSensitive ! !//////////////////////////////////////////////////////////////////////// ! !      LOGICAL FUNCTION isCaseSensitive(self) !         IMPLICIT NONE !         CLASS(FTStringSet) :: self !         isCaseSensitive = self % dict % isCaseSensitive !      END FUNCTION isCaseSensitive ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE printFTStringSet ( self , iUnit ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTStringSet ) :: self INTEGER :: iUnit ! !        --------------- !        Local Variables !        --------------- ! INTEGER :: i CHARACTER ( LEN = FTDICT_KWD_STRING_LENGTH ), POINTER :: keys (:) keys => self % dict % allKeys () DO i = 1 , SIZE ( keys ) PRINT * , TRIM ( keys ( i )) END DO DEALLOCATE ( keys ) END SUBROUTINE printFTStringSet ! !--------------------------------------------------------------------------- !> Generic Name: cast !> !> Cast a pointer to the base class to an FTStringSet pointer !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION FTStringSetFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTStringSet ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTStringSet ) cast => e CLASS DEFAULT END SELECT END FUNCTION FTStringSetFromObject ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTStringSet\") !> FUNCTION FTStringSetClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTStringSet ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s s = \"FTStringSet\" END FUNCTION FTStringSetClassName END MODULE FTStringSetClass","tags":"","loc":"sourcefile/ftstringsetclass.f90.html"},{"title":"FTObjectArrayClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~ftobjectarrayclass.f90~~EfferentGraph sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftobjectclass.f90 FTObjectClass.f90 sourcefile~ftobjectarrayclass.f90->sourcefile~ftobjectclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ftobjectarrayclass.f90~~AfferentGraph sourcefile~ftobjectarrayclass.f90 FTObjectArrayClass.f90 sourcefile~ftdictionaryclass.f90 FTDictionaryClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftlinkedlistclass.f90 FTLinkedListClass.f90 sourcefile~ftdictionaryclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftlinkedlistclass.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftobjectarrayclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 sourcefile~ftsparsematrixclass.f90 FTSparseMatrixClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftsparsematrixclass.f90 sourcefile~ftstackclass.f90 FTStackClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftstackclass.f90 sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftstackclass.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~ftmultiindextable.f90 FTMultiIndexTable.f90 sourcefile~ftmultiindextable.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftsparsematrixclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftstackclass.f90->sourcefile~ftlinkedlistclass.f90 sourcefile~ftstringsetclass.f90 FTStringSetClass.f90 sourcefile~ftstringsetclass.f90->sourcefile~ftdictionaryclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftdictionaryclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTMutableObjectArrayClass Source Code FTObjectArrayClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      FTMutableObjectArray.f90 !      Created: February 7, 2013 3:24 PM !      By: David Kopriva ! !>FTMutableObjectArray is a mutable array class to which objects !>can be added, removed, replaced and accessed according to their !>index in the array. !> !>Fortran has pointers to arrays, but not arrays of pointers. To do the latter, one creates !>a wrapper derived type and creates an array of that wrapper type. Fortran arrays are great, but !>they are of fixed length, and they don't easily implement reference counting to keep track of !>memory. For that, we have the FTMutableObjectArray. Performance reasons dictate that you !>will use regular arrays for numeric types and the like, but for generic objects we would use !>an Object Array. !> !>You initialize a FTMutableObjectArray with the number of objects that you expect it to hold. !>However, it can re-size itself if necessary. To be efficient, it adds more than one entry at a time !>given by the ``chunkSize'', which you can choose for yourself. (The default is 10.) !>##Definition !>           TYPE(FTMutableObjectArray) :: array !>#Usage !>##Initialization !>      CLASS(FTMutableObjectArray)  :: array !>      INTEGER                      :: N = 11 !>      CALL array % initWithSize(N) !>#Destruction !>           CALL array  %  destuct() [Non Pointers] !>           call releaseFTMutableObjectArray(array) [Pointers] !>#Adding an Object !>           TYPE(FTObject) :: obj !>           obj => r1 !>           CALL array % addObject(obj) !>#Removing an Object !>           TYPE(FTObject) :: obj !>           CALL array % removeObjectAtIndex(i) !>#Accessing an Object !>           TYPE(FTObject) :: obj !>           obj => array % objectAtIndex(i) !>#Replacing an Object !>           TYPE(FTObject) :: obj !>           obj => r1 !>           CALL array % replaceObjectAtIndexWithObject(i,obj) !>#Setting the Chunk Size !>           CALL array % setChunkSize(size) !>#Finding The Number Of Items In The Array !>           n =  array % count() !>#Finding The Actual Allocated Size Of The Array !>           n =  array % allocatedSize() ! !//////////////////////////////////////////////////////////////////////// ! MODULE FTMutableObjectArrayClass USE FTObjectClass IMPLICIT NONE TYPE FTObjectPointerWrapper CLASS ( FTObject ), POINTER :: object => NULL () END TYPE FTObjectPointerWrapper PRIVATE :: FTObjectPointerWrapper PRIVATE :: increaseArraysize TYPE , EXTENDS ( FTObject ) :: FTMutableObjectArray INTEGER , PRIVATE :: count_ TYPE ( FTObjectPointerWrapper ), DIMENSION (:), POINTER , PRIVATE :: array => NULL () INTEGER , PRIVATE :: chunkSize_ = 10 ! !        -------- CONTAINS !        -------- ! PROCEDURE , PUBLIC :: initWithSize => initObjectArrayWithSize FINAL :: destructObjectArray PROCEDURE , PUBLIC :: addObject => addObjectToArray PROCEDURE , PUBLIC :: replaceObjectAtIndexWithObject PROCEDURE , PUBLIC :: removeObjectAtIndex PROCEDURE , PUBLIC :: objectAtIndex PROCEDURE , PUBLIC :: printDescription => printArray PROCEDURE , PUBLIC :: className => arrayClassName ! PROCEDURE , PUBLIC :: setChunkSize PROCEDURE , PUBLIC :: chunkSize PROCEDURE , PUBLIC :: COUNT => numberOfItems PROCEDURE , PUBLIC :: allocatedSize END TYPE INTERFACE cast MODULE PROCEDURE castToMutableObjectArray END INTERFACE cast ! !     ======== CONTAINS !     ======== ! ! !//////////////////////////////////////////////////////////////////////// ! !> !> Designated initializer. Initializes the amount of storage, but !> the array remains empty. !> !> *Usage !> !>       CLASS(FTMutableObjectArray)  :: array !>       integer                      :: N = 11 !>       CALL array % initWithSize(N) !> SUBROUTINE initObjectArrayWithSize ( self , arraySize ) IMPLICIT NONE CLASS ( FTMutableObjectArray ) :: self INTEGER :: arraySize INTEGER :: i CALL self % FTObject % init () ALLOCATE ( self % array ( arraySize ) ) DO i = 1 , arraySize self % array ( i ) % object => NULL () END DO self % count_ = 0 END SUBROUTINE initObjectArrayWithSize ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE releaseFTMutableObjectArray ( self ) IMPLICIT NONE TYPE ( FTMutableObjectArray ), POINTER :: self CLASS ( FTObject ) , POINTER :: obj IF (. NOT . ASSOCIATED ( self )) RETURN obj => self CALL release ( obj ) IF (. NOT . ASSOCIATED ( obj )) self => NULL () END SUBROUTINE releaseFTMutableObjectArray ! !//////////////////////////////////////////////////////////////////////// ! !> !> Destructor for the class. This is called automatically when the !> reference count reaches zero. Do not call this yourself. !> RECURSIVE SUBROUTINE destructObjectArray ( self ) IMPLICIT NONE TYPE ( FTMutableObjectArray ) :: self CLASS ( FTObject ), POINTER :: obj => NULL () INTEGER :: i DO i = 1 , self % count_ obj => self % array ( i ) % object IF ( ASSOCIATED ( obj ) ) CALL releaseFTObject ( self = obj ) END DO DEALLOCATE ( self % array ) self % array => NULL () self % count_ = 0 END SUBROUTINE destructObjectArray ! !//////////////////////////////////////////////////////////////////////// ! !> !> Add an object to the end of the array !> !> *Usage !> !>       CLASS(FTMutableObjectArray)      :: array !>       CLASS(FTObject)        , POINTER :: obj !>       CLASS(FTObjectSubclass), POINTER :: p !>       obj => p !>       CALL array % addObject(obj) !> SUBROUTINE addObjectToArray ( self , obj ) IMPLICIT NONE CLASS ( FTMutableObjectArray ) :: self CLASS ( FTObject ), POINTER :: obj self % count_ = self % count_ + 1 IF ( self % count_ > SIZE ( self % array ) ) THEN CALL increaseArraysize ( self , self % count_ ) END IF self % array ( self % count_ ) % object => obj CALL obj % retain () END SUBROUTINE addObjectToArray ! !//////////////////////////////////////////////////////////////////////// ! !> !> Remove an object at the index indx !> !> *Usage !> !>       CLASS(FTMutableObjectArray) :: array !>       INTEGER                     :: indx !>       CALL array % removeObjectAtIndex(indx) !> SUBROUTINE removeObjectAtIndex ( self , indx ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTMutableObjectArray ) :: self INTEGER :: indx ! !        --------------- !        Local variables !        --------------- ! INTEGER :: i CLASS ( FTObject ), POINTER :: obj => NULL () obj => self % array ( indx ) % object IF ( ASSOCIATED ( obj ) ) THEN CALL releaseFTObject ( self = obj ) END IF DO i = indx , self % count_ - 1 self % array ( i ) % object => self % array ( i + 1 ) % object END DO self % array ( self % count_ ) % object => NULL () self % count_ = self % count_ - 1 END SUBROUTINE removeObjectAtIndex ! !//////////////////////////////////////////////////////////////////////// ! !> !> Replace an object at the index indx !> !> Usage !> ----- !> !>       CLASS(FTMutableObjectArray) :: array !>       INTEGER                     :: indx !>       CALL array % replaceObjectAtIndexWithObject(indx) !> SUBROUTINE replaceObjectAtIndexWithObject ( self , indx , replacement ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTMutableObjectArray ) :: self INTEGER :: indx CLASS ( FTObject ), POINTER :: replacement ! !        --------------- !        Local variables !        --------------- ! CLASS ( FTObject ), POINTER :: obj => NULL () obj => self % array ( indx ) % object CALL releaseFTObject ( obj ) self % array ( indx ) % object => replacement CALL replacement % retain () END SUBROUTINE replaceObjectAtIndexWithObject ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE printArray ( self , iUnit ) IMPLICIT NONE CLASS ( FTMutableObjectArray ) :: self INTEGER :: iUnit INTEGER :: i CLASS ( FTObject ), POINTER :: obj => NULL () DO i = 1 , self % count_ obj => self % array ( i ) % object CALL obj % printDescription ( iUnit ) END DO END SUBROUTINE printArray ! !//////////////////////////////////////////////////////////////////////// ! !> !> Access the object at the index indx !> !> *Usage !> !>       CLASS(FTMutableObjectArray) :: array !>       INTEGER                     :: indx !>       CLASS(FTObject), POINTER    :: obj !>       obj => array % objectAtIndex(indx) !> FUNCTION objectAtIndex ( self , indx ) RESULT ( obj ) IMPLICIT NONE CLASS ( FTMutableObjectArray ) :: self INTEGER :: indx CLASS ( FTObject ), POINTER :: obj IF ( indx > self % count_ . OR . indx < 1 ) THEN obj => NULL () ELSE obj => self % array ( indx ) % object END IF END FUNCTION objectAtIndex ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE increaseArraySize ( self , n ) IMPLICIT NONE ! !        --------- !        Arguments !        --------- ! CLASS ( FTMutableObjectArray ) :: self INTEGER :: n ! !        --------------- !        Local Variables !        --------------- ! TYPE ( FTObjectPointerWrapper ), DIMENSION (:), POINTER :: newArray INTEGER :: i , m IF ( n <= SIZE ( self % array ) ) THEN RETURN END IF m = ( n - SIZE ( self % array )) / self % chunkSize_ + 1 ALLOCATE ( newArray ( SIZE ( self % array ) + m * self % chunkSize_ ) ) DO i = 1 , SIZE ( self % array ) newArray ( i ) % object => self % array ( i ) % object END DO DO i = SIZE ( self % array ) + 1 , SIZE ( newArray ) newArray ( i ) % object => NULL () END DO DEALLOCATE ( self % array ) self % array => newArray END SUBROUTINE increaseArraySize ! !//////////////////////////////////////////////////////////////////////// ! !> !> Set the number of items to be added when the array needs to be re-sized !> !> *Usage !> !>       CLASS(FTMutableObjectArray) :: array !>       INTEGER                     :: sze = 42 !>       CALL array % setChunkSize(sze) !> SUBROUTINE setChunkSize ( self , chunkSize ) IMPLICIT NONE CLASS ( FTMutableObjectArray ) :: self INTEGER :: chunkSize self % chunkSize_ = chunkSize END SUBROUTINE setChunkSize ! !//////////////////////////////////////////////////////////////////////// ! !> !> Returns the number of items to be added when the array needs to be re-sized !> !> *Usage !> !>       CLASS(FTMutableObjectArray) :: array !>       INTEGER                     :: sze !>       sze =  array % chunkSize !> INTEGER FUNCTION chunkSize ( self ) IMPLICIT NONE CLASS ( FTMutableObjectArray ) :: self chunkSize = self % chunkSize_ END FUNCTION chunkSize ! !//////////////////////////////////////////////////////////////////////// ! !> !> Generic name: count !> !> Returns the acutal number of items in the array. !> !> *Usage !> !>       CLASS(FTMutableObjectArray) :: array !>       INTEGER                     :: sze !>       sze =  array % count() !> INTEGER FUNCTION numberOfItems ( self ) IMPLICIT NONE CLASS ( FTMutableObjectArray ) :: self numberOfItems = self % count_ END FUNCTION numberOfItems ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION allocatedSize ( self ) IMPLICIT NONE CLASS ( FTMutableObjectArray ) :: self IF ( ASSOCIATED ( self % array ) ) THEN allocatedSize = SIZE ( self % array ) ELSE allocatedSize = 0 END IF END FUNCTION allocatedSize ! !--------------------------------------------------------------------------- !> Generic Name: cast !> !> Cast a pointer to the base class to an FTMutableObjectArray pointer !--------------------------------------------------------------------------- ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION objectArrayFromObject ( obj ) RESULT ( cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTMutableObjectArray ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTMutableObjectArray ) cast => e CLASS DEFAULT END SELECT END FUNCTION objectArrayFromObject ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE castToMutableObjectArray ( obj , cast ) ! !     ----------------------------------------------------- !     Cast the base class FTObject to the FTException class !     ----------------------------------------------------- ! IMPLICIT NONE CLASS ( FTObject ) , POINTER :: obj CLASS ( FTMutableObjectArray ), POINTER :: cast cast => NULL () SELECT TYPE ( e => obj ) TYPE is ( FTMutableObjectArray ) cast => e CLASS DEFAULT END SELECT END SUBROUTINE castToMutableObjectArray ! !//////////////////////////////////////////////////////////////////////// ! !      ----------------------------------------------------------------- !> Class name returns a string with the name of the type of the object !> !>  ### Usage: !> !>        PRINT *,  obj % className() !>        if( obj % className = \"FTMutableObjectArray\") !> FUNCTION arrayClassName ( self ) RESULT ( s ) IMPLICIT NONE CLASS ( FTMutableObjectArray ) :: self CHARACTER ( LEN = CLASS_NAME_CHARACTER_LENGTH ) :: s IF ( self % COUNT () . ge . 0 ) CONTINUE s = \"FTMutableObjectArray\" END FUNCTION arrayClassName END Module FTMutableObjectArrayClass","tags":"","loc":"sourcefile/ftobjectarrayclass.f90.html"},{"title":"FTOLConstants.f90 – FTObjectLibrary","text":"Files dependent on this one sourcefile~~ftolconstants.f90~~AfferentGraph sourcefile~ftolconstants.f90 FTOLConstants.f90 sourcefile~assert.f90 Assert.f90 sourcefile~assert.f90->sourcefile~ftolconstants.f90 sourcefile~comparisons.f90 Comparisons.f90 sourcefile~assert.f90->sourcefile~comparisons.f90 sourcefile~comparisons.f90->sourcefile~ftolconstants.f90 sourcefile~ftvalueclass.f90 FTValueClass.f90 sourcefile~ftvalueclass.f90->sourcefile~ftolconstants.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~assert.f90 sourcefile~ftobjectlibrary.f90->sourcefile~comparisons.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvalueclass.f90 sourcefile~ftvaluedictionaryclass.f90 FTValueDictionaryClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftvaluedictionaryclass.f90 sourcefile~testsuitemanagerclass.f90 TestSuiteManagerClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~testsuitemanagerclass.f90 sourcefile~ftexceptionclass.f90 FTExceptionClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~ftexceptionclass.f90 sourcefile~ftvaluedictionaryclass.f90->sourcefile~ftvalueclass.f90 sourcefile~testsuitemanagerclass.f90->sourcefile~assert.f90 sourcefile~ftexceptionclass.f90->sourcefile~ftvaluedictionaryclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTOLConstants Source Code FTOLConstants.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      Constants.f90 !      Created: June 12, 2013 2:54 PM !      By: David Kopriva ! !//////////////////////////////////////////////////////////////////////// ! !> Defines constants to be used by the library ! Module FTOLConstants IMPLICIT NONE INTEGER , PARAMETER :: FT_ORDERED_ASCENDING = 1 , FT_ORDERED_DESCENDING = - 1 , FT_ORDERED_SAME = 0 INTEGER , PARAMETER :: QUAD_DIGITS = 30 END Module FTOLConstants","tags":"","loc":"sourcefile/ftolconstants.f90.html"},{"title":"TestSuiteManagerClass.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~testsuitemanagerclass.f90~~EfferentGraph sourcefile~testsuitemanagerclass.f90 TestSuiteManagerClass.f90 sourcefile~assert.f90 Assert.f90 sourcefile~testsuitemanagerclass.f90->sourcefile~assert.f90 sourcefile~comparisons.f90 Comparisons.f90 sourcefile~assert.f90->sourcefile~comparisons.f90 sourcefile~ftolconstants.f90 FTOLConstants.f90 sourcefile~assert.f90->sourcefile~ftolconstants.f90 sourcefile~comparisons.f90->sourcefile~ftolconstants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~testsuitemanagerclass.f90~~AfferentGraph sourcefile~testsuitemanagerclass.f90 TestSuiteManagerClass.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~testsuitemanagerclass.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules TestSuiteManagerClass Source Code TestSuiteManagerClass.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      TestSuiteModule.f90 !      Created: February 21, 2013 11:21 AM !      By: David Kopriva ! !> The TestSuiteManager class defines methods to easily !> put together and run a suite of unit tests. !> !> !> The tests are managed by an instance of the !>**TestSuiteManager** class. It is designed to be used with minimal fuss. You !> !>- Initialize the test suite !>- Add test subroutines !>- Have the testSuiteManager perform the tests !>- Finalize the test suite manager !> !># Usage: # !> !>##Definition !> !>      TYPE(TestSuiteManager) :: testSuite !> !>##Initialization !>         call testSuite % init() !> !>##Creating a test ### !> !>   A test is a subroutine with interface !> !>         ABSTRACT INTERFACE !>            SUBROUTINE testSuiteSubroutine() !>               CHARACTER(LEN=1), POINTER, OPTIONAL :: optData(:) !>            END SUBROUTINE testSuiteSubroutine !>         END INTERFACE !> !>   that (typically) includes unit test calls. You add !>   a test suite function by the add subroutine !> !>         CALL testSuite % addTestSubroutineWithName(SubroutineName, description) !> !>   where !> !> - SubroutineName = a subroutine with the interface as above, and !> - description = a CHARACTER(LEN=128) character string that names the test !> !> Alternately optional data acan be added to the call !> !>   CALL testSuite % addTestSubroutineWithName(SubroutineName, description, optData) !> !> where OptData is !> !>     CHARACTER(LEN=1), POINTER :: optData(:) !> !> The optional data can contain anything if it is encoded using the TRANSFER function. This is a standard !> trick in fortran. !> !>##Setting the output location ### !>   Set the unit to which the output is written by !> !>         CALL testSuite % setOutputUnit(iUnit) !> !>##Running tests ### !>   To run the tests call !> !>         CALL testSuite % performTests() OR !>         CALL testSuite % performTests(numFailed) !> !>##Finalizing the test suite ### !>   When done, call !> !>         CALL finalizeSharedAssertionsManager ! !//////////////////////////////////////////////////////////////////////// ! Module TestSuiteManagerClass USE FTAssertions IMPLICIT NONE PRIVATE ABSTRACT INTERFACE SUBROUTINE testSuiteFunction ( optData ) CHARACTER ( LEN = 1 ), POINTER , OPTIONAL :: optData (:) END SUBROUTINE testSuiteFunction END INTERFACE TYPE TestCaseRecord LOGICAL :: passed CHARACTER ( LEN = 128 ) :: testName TYPE ( FTAssertionsManager ) , POINTER :: assertionsManager PROCEDURE ( testSuiteFunction ), POINTER , NOPASS :: TestSubroutine CHARACTER ( LEN = 1 ), POINTER :: optData (:) TYPE ( TestCaseRecord ), POINTER :: next END TYPE TestCaseRecord TYPE , PUBLIC :: TestSuiteManager INTEGER :: numberOfTests INTEGER :: stdOut = 6 TYPE ( TestCaseRecord ), POINTER :: testCasesHead => NULL () TYPE ( TestCaseRecord ), POINTER :: testCasesTail => NULL () CONTAINS PROCEDURE :: init => initializeTestSuiteManager FINAL :: finalizeTestSuiteManager PROCEDURE :: addTestSubroutineWithName PROCEDURE :: performTests PROCEDURE :: setOutputUnit END TYPE TestSuiteManager ! !     ======== CONTAINS !     ======== ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initializeTestSuiteManager ( self ) IMPLICIT NONE CLASS ( TestSuiteManager ) :: self self % testCasesHead => NULL () self % testCasesTail => NULL () self % numberOfTests = 0 END SUBROUTINE initializeTestSuiteManager ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE setOutputUnit ( self , iUnit ) IMPLICIT NONE CLASS ( TestSuiteManager ) :: self INTEGER :: iUnit self % stdOut = iUnit END SUBROUTINE setOutputUnit ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addTestSubroutineWithName ( self , testSubroutine , testName , optData ) IMPLICIT NONE CLASS ( TestSuiteManager ) :: self EXTERNAL :: testSubroutine CHARACTER ( LEN =* ) :: testName CHARACTER ( LEN = 1 ), POINTER , OPTIONAL :: optData (:) TYPE ( TestCaseRecord ), POINTER :: newTestCase INTERFACE SUBROUTINE testSubroutine ( optData ) CHARACTER ( LEN = 1 ), POINTER , OPTIONAL :: optData (:) END SUBROUTINE testSubroutine END INTERFACE ALLOCATE ( newTestCase ) newTestCase % testName = TRIM ( ADJUSTL ( testName )) newTestCase % TestSubroutine => testSubroutine IF ( PRESENT ( optData ) ) THEN newTestCase % optData => optData ELSE newTestCase % optData => NULL () END IF newTestCase % next => NULL () newTestCase % passed = . TRUE . self % numberOfTests = self % numberOfTests + 1 IF ( ASSOCIATED ( self % testCasesHead ) ) THEN self % testCasesTail % next => newTestCase self % testCasesTail => newTestCase ELSE self % testCasesHead => newTestCase self % testCasesTail => newTestCase END IF END SUBROUTINE addTestSubroutineWithName ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE finalizeTestSuiteManager ( self ) IMPLICIT NONE TYPE ( TestSuiteManager ) :: self TYPE ( TestCaseRecord ), POINTER :: next , current IF ( . NOT . ASSOCIATED ( self % testCasesHead ) ) THEN RETURN END IF current => self % testCasesHead DO WHILE ( ASSOCIATED ( current )) next => current % next IF ( ASSOCIATED ( current % assertionsManager )) THEN DEALLOCATE ( current % assertionsManager ) END IF IF ( ASSOCIATED ( current % optData )) THEN DEALLOCATE ( current % optData ) END IF DEALLOCATE ( current ) current => next END DO self % testCasesHead => NULL () self % testCasesTail => NULL () self % numberOfTests = 0 END SUBROUTINE finalizeTestSuiteManager ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE performTests ( self , numberOfFailedTestsRet ) IMPLICIT NONE ! !         --------- !         Arguments !         --------- ! CLASS ( TestSuiteManager ) :: self INTEGER , OPTIONAL :: numberOfFailedTestsRet ! !         --------------- !         Local variables !         --------------- ! TYPE ( TestCaseRecord ) , POINTER :: current TYPE ( FTAssertionsManager ), POINTER :: sharedManager INTEGER :: maxMessageLength , numberOfFailedTests numberOfFailedTests = 0 maxMessageLength = 0 WRITE ( self % stdOut , * ) WRITE ( self % stdOut , * ) \"                   ////////////////////////////////\" WRITE ( self % stdOut , * ) \"                   ////    Begin Test Suites   ////\" WRITE ( self % stdOut , * ) \"                   ////////////////////////////////\" WRITE ( self % stdOut , * ) current => self % testCasesHead DO WHILE ( ASSOCIATED ( current )) CALL initializeSharedAssertionsManager sharedManager => sharedAssertionsManager () current % assertionsManager => sharedManager IF ( ASSOCIATED ( current % optData ) ) THEN CALL current % TestSubroutine ( current % optData ) ELSE CALL current % TestSubroutine END IF IF ( sharedManager % numberOfAssertionFailures () /= 0 ) THEN numberOfFailedTests = numberOfFailedTests + 1 current % passed = . FALSE . END IF CALL sharedManager % SummarizeAssertions ( current % testName , self % stdOut ) CALL detachSharedAssertionsManager maxMessageLength = MAX ( maxMessageLength , LEN_TRIM ( current % testName )) current => current % next END DO WRITE ( self % stdOut , * ) WRITE ( self % stdOut , * ) \"   **********************************************************\" WRITE ( self % stdOut , * ) \"                     Summary of failed test suites:\" WRITE ( self % stdOut , '(i6,A,i3)' ) numberOfFailedTests , \" suite(s) failed out of \" , self % numberOfTests WRITE ( self % stdOut , * ) \"   **********************************************************\" WRITE ( self % stdOut , * ) WRITE ( self % stdOut , * ) \"                   ////////////////////////////////////\" WRITE ( self % stdOut , * ) \"                   ////    Test Suites Completed   ////\" WRITE ( self % stdOut , * ) \"                   ////////////////////////////////////\" WRITE ( self % stdOut , * ) ! !         ------------------ !         Test matrix output !         ------------------ ! WRITE ( self % stdOut , * ) WRITE ( self % stdOut , * ) \"////////////////////////////////\" WRITE ( self % stdOut , * ) \"////   Test Status Matrix   ////\" WRITE ( self % stdOut , * ) \"////////////////////////////////\" WRITE ( self % stdOut , * ) current => self % testCasesHead DO WHILE ( ASSOCIATED ( current )) IF ( current % passed ) THEN WRITE ( self % stdOut , * ) current % testName ( 1 : maxMessageLength ), \" ... Passed\" ELSE WRITE ( self % stdOut , * ) current % testName ( 1 : maxMessageLength ), \" ... F A I L E D\" END IF current => current % next END DO IF ( PRESENT ( numberOfFailedTestsRet )) numberOfFailedTestsRet = numberOfFailedTests END SUBROUTINE performTests END Module TestSuiteManagerClass","tags":"","loc":"sourcefile/testsuitemanagerclass.f90.html"},{"title":"Assert.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~assert.f90~~EfferentGraph sourcefile~assert.f90 Assert.f90 sourcefile~comparisons.f90 Comparisons.f90 sourcefile~assert.f90->sourcefile~comparisons.f90 sourcefile~ftolconstants.f90 FTOLConstants.f90 sourcefile~assert.f90->sourcefile~ftolconstants.f90 sourcefile~comparisons.f90->sourcefile~ftolconstants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~assert.f90~~AfferentGraph sourcefile~assert.f90 Assert.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~assert.f90 sourcefile~testsuitemanagerclass.f90 TestSuiteManagerClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~testsuitemanagerclass.f90 sourcefile~testsuitemanagerclass.f90->sourcefile~assert.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules FTAssertions Source Code Assert.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! ! Assert.f90 ! Created: February 21, 2013 2:34 PM ! By: David Kopriva ! !> Assertions are functions that return true or false !> that can be placed in a program to test whether !> a predicate is true. !> !> To use the assertions module, it must be initialized, !> usually in the main program. When it is no longer needed, !> it is finalized. Assertions are posted to the module as they !> are called, and can be summarized later at an appropriate time. !> !>### Initialization ### !> !>      CALL initializeSharedAssertionsManager !> !>### Finalization ### !> !>      CALL finalizeSharedAssertionsManager !> !>### Asserting ### !> !>      CALL FTAssertEqual(expectedValue,resultValue,message) !> !>### Summarizing Assertions ### !> !>      CALL SummarizeFTAssertions(title,unit) !> !>### Additional enquiry functions ### !> !>      INTEGER :: nf, nA !>       nF = numberOfAssertionFailures() !>       nA = numberOfAssertions() ! ! !//////////////////////////////////////////////////////////////////////// ! Module FTAssertions USE ComparisonsModule USE FTOLConstants USE ISO_FORTRAN_ENV IMPLICIT NONE PRIVATE ! !     ------ !     Public !     ------ ! INTEGER , PARAMETER , PUBLIC :: FT_ASSERTION_STRING_LENGTH = 128 TYPE FTAssertionsManager PRIVATE INTEGER :: numberOfTests_ INTEGER :: numberOfAssertionFailures_ TYPE ( FTAssertionFailureRecord ), POINTER :: failureListHead => NULL () TYPE ( FTAssertionFailureRecord ), POINTER :: failureListTail => NULL () ! !        ======== CONTAINS !        ======== ! PROCEDURE , PUBLIC :: init PROCEDURE , PUBLIC :: finalize PROCEDURE , PUBLIC :: numberOfAssertionFailures PROCEDURE , PUBLIC :: numberOfAssertions PROCEDURE , PUBLIC :: summarizeAssertions END TYPE FTAssertionsManager PUBLIC :: FTAssertionsManager INTERFACE FTAssertEqual MODULE PROCEDURE assertEqualTwoIntegers MODULE PROCEDURE assertEqualTwoIntegerArrays1D MODULE PROCEDURE assertEqualTwoIntegerArrays2D MODULE PROCEDURE assertWithinToleranceTwoReal MODULE PROCEDURE assertWithinToleranceTwoRealArrays1D MODULE PROCEDURE assertWithinToleranceTwoRealArrays2D MODULE PROCEDURE assertWithinToleranceTwoDouble MODULE PROCEDURE assertWithinToleranceTwoDoubleArrays1D MODULE PROCEDURE assertWithinToleranceTwoDoubleArrays2D #ifdef _has_Quad MODULE PROCEDURE assertWithinToleranceTwoQuad #endif MODULE PROCEDURE assertEqualTwoLogicals MODULE PROCEDURE assertEqualString END INTERFACE FTAssertEqual PUBLIC :: FTAssertEqual #ifdef _has_Quad PUBLIC :: assertWithinToleranceTwoQuad #endif PUBLIC :: initializeSharedAssertionsManager , finalizeSharedAssertionsManager PUBLIC :: FTAssert , sharedAssertionsManager , numberOfAssertionFailures , numberOfAssertions PUBLIC :: detachSharedAssertionsManager ! !     ------- !     Private !     ------- ! TYPE FTAssertionFailureRecord CHARACTER ( LEN = FT_ASSERTION_STRING_LENGTH ) :: msg , expected , actual CHARACTER ( LEN = FT_ASSERTION_STRING_LENGTH ) :: assertionType TYPE ( FTAssertionFailureRecord ), POINTER :: next END TYPE FTAssertionFailureRecord ! !     ------------------------- !     Shared Assertions manager !     ------------------------- ! TYPE ( FTAssertionsManager ), POINTER , PRIVATE :: sharedManager ! !     ======== CONTAINS !     ======== !@mark - ! !//////////////////////////////////////////////////////////////////////// ! FUNCTION sharedAssertionsManager () IMPLICIT NONE TYPE ( FTAssertionsManager ), POINTER :: sharedAssertionsManager sharedAssertionsManager => sharedManager END FUNCTION sharedAssertionsManager ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE detachSharedAssertionsManager IMPLICIT NONE ! !     -------------------------------------------------------------------------- !     To create a new sharedAssertionsManager, !     call this procedure after storing a pointer to the sharedAssertionsManager !     and before initializing again. !     -------------------------------------------------------------------------- ! sharedManager => NULL () END SUBROUTINE detachSharedAssertionsManager ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION numberOfAssertions ( self ) IMPLICIT NONE CLASS ( FTAssertionsManager ) :: self numberOfAssertions = self % numberOfTests_ END FUNCTION numberOfAssertions ! !//////////////////////////////////////////////////////////////////////// ! INTEGER FUNCTION numberOfAssertionFailures ( self ) IMPLICIT NONE CLASS ( FTAssertionsManager ) :: self numberOfAssertionFailures = self % numberOfAssertionFailures_ END FUNCTION numberOfAssertionFailures ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE init ( self ) IMPLICIT NONE CLASS ( FTAssertionsManager ) :: self self % numberOfTests_ = 0 self % numberOfAssertionFailures_ = 0 NULLIFY ( self % failureListHead , self % failureListTail ) END SUBROUTINE init ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE finalize ( self ) IMPLICIT NONE CLASS ( FTAssertionsManager ) :: self TYPE ( FTAssertionFailureRecord ), POINTER :: tmp , current IF ( . NOT . ASSOCIATED ( self % failureListHead ) ) RETURN ! !        ------------------------------ !        Delete linked list of failures !        ------------------------------ ! current => self % failureListHead tmp => current % next DO WHILE ( ASSOCIATED ( tmp )) tmp => current % next DEALLOCATE ( current ) current => tmp END DO self % numberOfTests_ = 0 self % numberOfAssertionFailures_ = 0 NULLIFY ( self % failureListHead , self % failureListTail ) END SUBROUTINE finalize ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE initializeSharedAssertionsManager IMPLICIT NONE ! !        -------------------------------------------------- !        The manager is allowed only once to be initialized !        per run. !        -------------------------------------------------- ! IF ( ASSOCIATED ( sharedManager ) ) RETURN ALLOCATE ( sharedManager ) CALL sharedManager % init () END SUBROUTINE initializeSharedAssertionsManager ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE finalizeSharedAssertionsManager IMPLICIT NONE IF ( ASSOCIATED ( sharedManager )) CALL sharedManager % finalize () END SUBROUTINE finalizeSharedAssertionsManager ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE addAssertionFailureForParameters ( msg , expected , actual , assertionType ) IMPLICIT NONE CHARACTER ( LEN =* ) :: msg , expected , actual , assertionType TYPE ( FTAssertionFailureRecord ), POINTER :: newFailure ALLOCATE ( newFailure ) newFailure % msg = TRIM ( msg ) newFailure % expected = TRIM ( ADJUSTL ( expected )) newFailure % actual = TRIM ( ADJUSTL ( actual )) newFailure % assertionType = assertionType newFailure % next => NULL () IF ( ASSOCIATED ( sharedManager % failureListTail ) ) THEN sharedManager % failureListTail % next => newFailure sharedManager % failureListTail => sharedManager % failureListTail % next ELSE sharedManager % failureListHead => newFailure sharedManager % failureListTail => newFailure END IF sharedManager % numberOfAssertionFailures_ = sharedManager % numberOfAssertionFailures_ + 1 END SUBROUTINE addAssertionFailureForParameters ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE summarizeAssertions ( self , title , iUnit ) IMPLICIT NONE CLASS ( FTAssertionsManager ) :: self CHARACTER ( LEN =* ) :: title INTEGER :: iUnit TYPE ( FTAssertionFailureRecord ), POINTER :: current WRITE ( iUnit , * ) \"   -------------------------------------------------------------\" WRITE ( iUnit , * ) \"   Summary of failed tests for test suite: \" , TRIM ( title ) WRITE ( iUnit , '(3x,i3,A,i5,A)' ) self % numberOfAssertionFailures (), \" failures out of \" , & self % numberOfAssertions (), \" assertions.\" WRITE ( iUnit , * ) \"   -------------------------------------------------------------\" current => self % failureListHead DO WHILE ( ASSOCIATED ( current )) WRITE ( iUnit , * ) \"   \" , TRIM ( current % assertionType ) WRITE ( iUnit , * ) \"      \" , TRIM ( current % msg ) WRITE ( iUnit , * ) \"      \" , \"Expected [\" , TRIM ( current % expected ),& \"], Got [\" , TRIM ( current % actual ), \"]\" current => current % next END DO END SUBROUTINE summarizeAssertions !@mark - ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE FTAssert ( test , msg ) IMPLICIT NONE CHARACTER ( LEN =* ), OPTIONAL :: msg LOGICAL :: test IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . test ) THEN IF ( PRESENT ( msg ) ) THEN CALL addAssertionFailureForParameters ( msg , \"True\" , \"False\" , \"Logical assertion failed: \" ) ELSE CALL addAssertionFailureForParameters ( \"\" , \"True\" , \"False\" , \"Logical assertion failed: \" ) END IF END IF END SUBROUTINE FTAssert !@mark - ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertEqualTwoIntegers ( expectedValue , actualValue , msg ) IMPLICIT NONE INTEGER , INTENT ( in ) :: expectedValue , actualValue CHARACTER ( LEN =* ), OPTIONAL :: msg CHARACTER ( LEN = FT_ASSERTION_STRING_LENGTH ) :: expected , actual IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue ) ) THEN WRITE ( expected , * ) expectedValue WRITE ( actual , * ) actualValue IF ( PRESENT ( msg ) ) THEN CALL addAssertionFailureForParameters ( msg , expected , actual , \"Integer equality failed: \" ) ELSE CALL addAssertionFailureForParameters ( \"\" , expected , actual , \"Integer equality failed: \" ) END IF END IF END SUBROUTINE assertEqualTwoIntegers ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertEqualTwoIntegerArrays1D ( expectedValue , actualValue ) IMPLICIT NONE INTEGER , INTENT ( in ) , DIMENSION (:) :: expectedValue , actualValue IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue ) ) THEN PRINT * , \"assertEqualTwoIntegerArrays1D not implemented\" END IF END SUBROUTINE assertEqualTwoIntegerArrays1D ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertEqualTwoIntegerArrays2D ( expectedValue , actualValue ) IMPLICIT NONE INTEGER , INTENT ( in ) , DIMENSION (:,:) :: expectedValue , actualValue IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue ) ) THEN PRINT * , \"assertEqualTwoIntegerArrays2D not implemented\" END IF END SUBROUTINE assertEqualTwoIntegerArrays2D !@mark - ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertWithinToleranceTwoReal ( expectedValue , actualValue , tol , msg ) IMPLICIT NONE REAL , INTENT ( in ) :: expectedValue , actualValue , tol CHARACTER ( LEN =* ), OPTIONAL :: msg CHARACTER ( LEN = FT_ASSERTION_STRING_LENGTH ) :: expectedS , actualS IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue , tol ) ) THEN WRITE ( expectedS , * ) expectedValue WRITE ( actualS , * ) actualValue IF ( PRESENT ( msg ) ) THEN CALL addAssertionFailureForParameters ( msg , expectedS , actualS , \"Real equality failed: \" ) ELSE CALL addAssertionFailureForParameters ( \"\" , expectedS , actualS , \"Real equality failed: \" ) END IF END IF END SUBROUTINE assertWithinToleranceTwoReal ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertWithinToleranceTwoRealArrays1D ( expectedValue , actualValue , tol , msg ) IMPLICIT NONE REAL , INTENT ( IN ), DIMENSION (:) :: expectedValue , actualValue REAL , INTENT ( IN ) :: tol CHARACTER ( LEN =* ), OPTIONAL :: msg INTEGER :: k CHARACTER ( LEN = FT_ASSERTION_STRING_LENGTH ) :: expected , actual IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue , tol ) ) THEN DO k = 1 , SIZE ( expectedValue ) WRITE ( expected , * ) expectedValue ( k ) WRITE ( actual , * ) actualValue ( k ) IF ( PRESENT ( msg ) ) THEN CALL addAssertionFailureForParameters ( msg , expected , actual , \"Real Array equality failed: \" ) ELSE CALL addAssertionFailureForParameters ( \"\" , expected , actual , \"Real Array equality failed: \" ) END IF END DO END IF END SUBROUTINE assertWithinToleranceTwoRealArrays1D ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertWithinToleranceTwoRealArrays2D ( expectedValue , actualValue , tol ) IMPLICIT NONE REAL , INTENT ( IN ), DIMENSION (:,:) :: expectedValue , actualValue REAL , INTENT ( IN ) :: tol IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue , tol ) ) THEN PRINT * , \"assertWithinToleranceTwoRealArrays2D not implemented\" END IF END SUBROUTINE assertWithinToleranceTwoRealArrays2D !@mark - ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertWithinToleranceTwoDouble ( expectedValue , actualValue , tol , msg ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( in ) :: expectedValue , actualValue , tol CHARACTER ( LEN =* ), OPTIONAL :: msg CHARACTER ( LEN = FT_ASSERTION_STRING_LENGTH ) :: expected , actual IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue , tol ) ) THEN WRITE ( expected , * ) expectedValue WRITE ( actual , * ) actualValue IF ( PRESENT ( msg ) ) THEN CALL addAssertionFailureForParameters ( msg , expected , actual , \"Double Precision equality failed: \" ) ELSE CALL addAssertionFailureForParameters ( \"\" , expected , actual , \"Double Precision equality failed: \" ) END IF END IF END SUBROUTINE assertWithinToleranceTwoDouble ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertWithinToleranceTwoDoubleArrays1D ( expectedValue , actualValue , tol , msg ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ), DIMENSION (:) :: expectedValue , actualValue DOUBLE PRECISION , INTENT ( IN ) :: tol CHARACTER ( LEN =* ), OPTIONAL :: msg INTEGER :: code INTEGER :: k CHARACTER ( LEN = FT_ASSERTION_STRING_LENGTH ) :: expected , actual , eMsg IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue , tol , code ) ) THEN IF ( PRESENT ( msg ) ) THEN eMsg = TRIM ( msg ) // \"---\" // TRIM ( compareCodeStrings ( code )) ELSE eMsg = \"---\" // TRIM ( compareCodeStrings ( code )) END IF DO k = 1 , SIZE ( expectedValue ) WRITE ( expected , * ) expectedValue ( k ) WRITE ( actual , * ) actualValue ( k ) CALL addAssertionFailureForParameters ( eMsg , expected , actual , \"Double Precision 1D Array equality failed: \" ) END DO END IF END SUBROUTINE assertWithinToleranceTwoDoubleArrays1D ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertWithinToleranceTwoDoubleArrays2D ( expectedValue , actualValue , tol ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ), DIMENSION (:,:) :: expectedValue , actualValue DOUBLE PRECISION , INTENT ( IN ) :: tol INTEGER :: code IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue , tol , code ) ) THEN PRINT * , \"assertWithinToleranceTwoDoubleArrays2D not implemented\" END IF END SUBROUTINE assertWithinToleranceTwoDoubleArrays2D !@mark - #ifdef _has_Quad ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertWithinToleranceTwoQuad ( expectedValue , actualValue , tol , msg ) IMPLICIT NONE REAL ( KIND = SELECTED_REAL_KIND ( QUAD_DIGITS )), INTENT ( in ) :: expectedValue , actualValue , tol CHARACTER ( LEN =* ) , OPTIONAL :: msg CHARACTER ( LEN = FT_ASSERTION_STRING_LENGTH ) :: expectedS , actualS IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue , tol ) ) THEN WRITE ( expectedS , * ) expectedValue WRITE ( actualS , * ) actualValue IF ( PRESENT ( msg ) ) THEN CALL addAssertionFailureForParameters ( msg , expectedS , actualS , \"Quad equality failed: \" ) ELSE CALL addAssertionFailureForParameters ( \"\" , expectedS , actualS , \"Quad equality failed: \" ) END IF END IF END SUBROUTINE assertWithinToleranceTwoQuad #endif !@mark - ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertEqualString ( expectedValue , actualValue , msg ) IMPLICIT NONE CHARACTER ( LEN =* ) :: expectedValue , actualValue CHARACTER ( LEN =* ), OPTIONAL :: msg IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT . isEqual ( expectedValue , actualValue ) ) THEN IF ( PRESENT ( msg ) ) THEN CALL addAssertionFailureForParameters ( msg , expectedValue , actualValue , \"String equality failed: \" ) ELSE CALL addAssertionFailureForParameters ( \"\" , expectedValue , actualValue , \"String equality failed: \" ) END IF END IF END SUBROUTINE assertEqualString !@mark - ! !//////////////////////////////////////////////////////////////////////// ! SUBROUTINE assertEqualTwoLogicals ( expectedValue , actualValue , msg ) IMPLICIT NONE LOGICAL , INTENT ( in ) :: expectedValue , actualValue CHARACTER ( LEN =* ), OPTIONAL :: msg CHARACTER ( LEN = FT_ASSERTION_STRING_LENGTH ) :: expected , actual IF (. NOT . ASSOCIATED ( sharedManager )) THEN CALL initializeSharedAssertionsManager END IF sharedManager % numberOfTests_ = sharedManager % numberOfTests_ + 1 IF ( . NOT .( expectedValue . EQV . actualValue ) ) THEN WRITE ( expected , * ) expectedValue WRITE ( actual , * ) actualValue IF ( PRESENT ( msg ) ) THEN CALL addAssertionFailureForParameters ( msg , expected , actual , \"Logical equality failed: \" ) ELSE CALL addAssertionFailureForParameters ( msg , expected , actual , \"Logical equality failed: \" ) END IF END IF END SUBROUTINE assertEqualTwoLogicals END Module FTAssertions","tags":"","loc":"sourcefile/assert.f90.html"},{"title":"Comparisons.f90 – FTObjectLibrary","text":"This file depends on sourcefile~~comparisons.f90~~EfferentGraph sourcefile~comparisons.f90 Comparisons.f90 sourcefile~ftolconstants.f90 FTOLConstants.f90 sourcefile~comparisons.f90->sourcefile~ftolconstants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~comparisons.f90~~AfferentGraph sourcefile~comparisons.f90 Comparisons.f90 sourcefile~assert.f90 Assert.f90 sourcefile~assert.f90->sourcefile~comparisons.f90 sourcefile~ftobjectlibrary.f90 FTObjectLibrary.f90 sourcefile~ftobjectlibrary.f90->sourcefile~comparisons.f90 sourcefile~ftobjectlibrary.f90->sourcefile~assert.f90 sourcefile~testsuitemanagerclass.f90 TestSuiteManagerClass.f90 sourcefile~ftobjectlibrary.f90->sourcefile~testsuitemanagerclass.f90 sourcefile~testsuitemanagerclass.f90->sourcefile~assert.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules ComparisonsModule Source Code Comparisons.f90 Source Code ! MIT License ! ! Copyright (c) 2010-present David A. Kopriva and other contributors: AUTHORS.md ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! FTObjectLibrary contains code that, to the best of our knowledge, has been released as ! public domain software: ! * `b3hs_hash_key_jenkins`: originally by Rich Townsend, ! https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 ! ! --- End License ! !//////////////////////////////////////////////////////////////////////// ! !      Assert.f90 !      Created: February 21, 2013 10:02 AM !      By: David Kopriva ! !//////////////////////////////////////////////////////////////////////// ! !> Defines procedures that test equality of different kinds of arguments. !> Procedures defined here are USEd by the FTAssertions Module. ! Module ComparisonsModule USE ISO_FORTRAN_ENV USE FTOLConstants IMPLICIT NONE PRIVATE INTEGER , PARAMETER , PUBLIC :: ASSERT_SUCCESS = 0 , ASSERT_SIZE_DIFFERS = 1 INTEGER , PARAMETER , PUBLIC :: ASSERT_VALUES_DIFFER = 2 CHARACTER ( LEN = 21 ), PARAMETER :: ASSERT_SIZE_DIFFERS_NAME = \"Array sizes differ\" CHARACTER ( LEN = 21 ), PARAMETER :: ASSERT_VALUES_DIFFERS_NAME = \"Array elements differ\" CHARACTER ( LEN = 21 ), PARAMETER :: ASSERT_VALUES_OK_NAME = \"Arrays match\" CHARACTER ( LEN = 21 ), PARAMETER , PUBLIC :: compareCodeStrings ( 0 : 2 ) = [ ASSERT_VALUES_OK_NAME , & ASSERT_SIZE_DIFFERS_NAME ,& ASSERT_VALUES_DIFFERS_NAME ] INTERFACE isEqual MODULE PROCEDURE isEqualTwoIntegers MODULE PROCEDURE isEqualTwoIntegerArrays1D MODULE PROCEDURE isEqualTwoIntegerArrays2D MODULE PROCEDURE isWithinToleranceTwoReal MODULE PROCEDURE isWithinToleranceTwoRealArrays1D MODULE PROCEDURE isWithinToleranceTwoRealArrays2D MODULE PROCEDURE isWithinToleranceTwoDouble MODULE PROCEDURE isWithinToleranceTwoDoubleArrays1D MODULE PROCEDURE isWithinToleranceTwoDoubleArrays2D MODULE PROCEDURE isEqualString #ifdef _has_Quad MODULE PROCEDURE isWithinToleranceTwoQuad #endif END INTERFACE isEqual TYPE assertInfoArray1D CHARACTER ( LEN = 128 ) :: failureName INTEGER :: failureType LOGICAL , DIMENSION (:), ALLOCATABLE :: locations END TYPE assertInfoArray1D TYPE assertInfoArray2D CHARACTER ( LEN = 128 ) :: failureName INTEGER :: failureType LOGICAL , DIMENSION (:,:), ALLOCATABLE :: locations END TYPE assertInfoArray2D PUBLIC :: isEqual , assertInfoArray1D , assertInfoArray2D ! !     ======== CONTAINS !     ======== ! !@mark - ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isTrue ( condition ) IMPLICIT NONE LOGICAL :: condition IF ( condition ) THEN isTrue = . true . ELSE isTrue = . false . END IF END FUNCTION isTrue ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isFalse ( condition ) IMPLICIT NONE LOGICAL :: condition IF ( . NOT . condition ) THEN isFalse = . true . ELSE isFalse = . false . END IF END FUNCTION isFalse !@mark - ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isEqualTwoIntegers ( i , j ) IMPLICIT NONE INTEGER , INTENT ( in ) :: i , j IF ( i == j ) THEN isEqualTwoIntegers = . true . ELSE isEqualTwoIntegers = . false . END IF END FUNCTION isEqualTwoIntegers ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isEqualTwoIntegerArrays1D ( a , b , info ) IMPLICIT NONE INTEGER , INTENT ( in ) , DIMENSION (:) :: a , b TYPE ( assertInfoArray1D ), INTENT ( INOUT ), OPTIONAL :: info isEqualTwoIntegerArrays1D = . true . IF ( PRESENT ( info )) THEN info % failureType = ASSERT_SUCCESS info % failureName = ASSERT_VALUES_OK_NAME END IF IF ( SIZE ( a ) /= SIZE ( b ) ) THEN isEqualTwoIntegerArrays1D = . false . IF ( PRESENT ( info )) THEN info % failureType = ASSERT_SIZE_DIFFERS info % failureName = ASSERT_SIZE_DIFFERS_NAME END IF ELSE IF ( ANY ( a /= b )) THEN isEqualTwoIntegerArrays1D = . false . IF ( PRESENT ( info )) THEN info % failureType = ASSERT_VALUES_DIFFER info % failureName = ASSERT_VALUES_DIFFERS_NAME ALLOCATE ( info % locations ( SIZE ( a ))) info % locations = . true . WHERE ( a /= b ) info % locations = . false . END IF END IF END FUNCTION isEqualTwoIntegerArrays1D ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isEqualTwoIntegerArrays2D ( a , b , info ) IMPLICIT NONE INTEGER , INTENT ( in ) , DIMENSION (:,:) :: a , b TYPE ( assertInfoArray2D ), INTENT ( INOUT ), OPTIONAL :: info isEqualTwoIntegerArrays2D = . true . IF ( PRESENT ( info )) THEN info % failureType = ASSERT_SUCCESS info % failureName = ASSERT_VALUES_OK_NAME END IF IF ( SIZE ( a ) /= SIZE ( b ) ) THEN isEqualTwoIntegerArrays2D = . false . IF ( PRESENT ( info )) THEN info % failureType = ASSERT_SIZE_DIFFERS info % failureName = ASSERT_SIZE_DIFFERS_NAME END IF ELSE IF ( ANY ( a /= b )) THEN isEqualTwoIntegerArrays2D = . false . IF ( PRESENT ( info )) THEN info % failureType = ASSERT_VALUES_DIFFER info % failureName = ASSERT_VALUES_DIFFERS_NAME ALLOCATE ( info % locations ( SIZE ( a , 1 ), SIZE ( a , 2 ))) info % locations = . true . WHERE ( a /= b ) info % locations = . false . END IF END IF END FUNCTION isEqualTwoIntegerArrays2D !@mark - ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isWithinToleranceTwoReal ( x , y , tol ) IMPLICIT NONE REAL , INTENT ( in ) :: x , y , tol LOGICAL :: test IF ( x == 0.0e0 ) THEN test = ABS ( x - y ) <= tol ELSE test = ABS ( x - y ) <= tol * MAX ( ABS ( x ), ABS ( y )) END IF IF ( test ) THEN isWithinToleranceTwoReal = . true . ELSE isWithinToleranceTwoReal = . false . END IF END FUNCTION isWithinToleranceTwoReal ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isWithinToleranceTwoRealArrays1D ( a , b , tol , code ) IMPLICIT NONE REAL , INTENT ( IN ), DIMENSION (:) :: a , b REAL , INTENT ( IN ) :: tol INTEGER , INTENT ( OUT ), OPTIONAL :: code isWithinToleranceTwoRealArrays1D = . true . IF ( PRESENT ( code )) code = ASSERT_SUCCESS IF ( SIZE ( a ) /= SIZE ( b ) ) THEN isWithinToleranceTwoRealArrays1D = . false . IF ( PRESENT ( code )) code = ASSERT_SIZE_DIFFERS ELSE IF ( ANY ( ABS ( a - b ) > tol * MAX ( ABS ( a ), ABS ( b )))) THEN isWithinToleranceTwoRealArrays1D = . false . IF ( PRESENT ( code )) code = ASSERT_VALUES_DIFFER END IF END FUNCTION isWithinToleranceTwoRealArrays1D ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isWithinToleranceTwoRealArrays2D ( a , b , tol , code ) IMPLICIT NONE REAL , INTENT ( IN ), DIMENSION (:,:) :: a , b REAL , INTENT ( IN ) :: tol INTEGER , INTENT ( OUT ), OPTIONAL :: code isWithinToleranceTwoRealArrays2D = . true . IF ( PRESENT ( code )) code = ASSERT_SUCCESS IF ( SIZE ( a ) /= SIZE ( b ) ) THEN isWithinToleranceTwoRealArrays2D = . false . IF ( PRESENT ( code )) code = ASSERT_SIZE_DIFFERS ELSE IF ( ANY ( ABS ( a - b ) > tol * MAX ( ABS ( a ), ABS ( b )))) THEN isWithinToleranceTwoRealArrays2D = . false . IF ( PRESENT ( code )) code = ASSERT_VALUES_DIFFER END IF END FUNCTION isWithinToleranceTwoRealArrays2D !@mark - ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isWithinToleranceTwoDouble ( x , y , tol ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( in ) :: x , y , tol LOGICAL :: test IF ( x == 0.0d0 ) THEN test = ABS ( x - y ) <= tol ELSE test = ABS ( x - y ) <= tol * MAX ( ABS ( x ), ABS ( y )) END IF IF ( test ) THEN isWithinToleranceTwoDouble = . true . ELSE isWithinToleranceTwoDouble = . false . END IF END FUNCTION isWithinToleranceTwoDouble ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isWithinToleranceTwoDoubleArrays1D ( a , b , tol , code ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ), DIMENSION (:) :: a , b DOUBLE PRECISION , INTENT ( IN ) :: tol INTEGER , INTENT ( OUT ), OPTIONAL :: code isWithinToleranceTwoDoubleArrays1D = . true . IF ( PRESENT ( code )) code = ASSERT_SUCCESS IF ( SIZE ( a ) /= SIZE ( b ) ) THEN isWithinToleranceTwoDoubleArrays1D = . false . IF ( PRESENT ( code )) code = ASSERT_SIZE_DIFFERS ELSE IF ( ANY ( ABS ( a - b ) > tol * MAX ( ABS ( a ), ABS ( b )))) THEN isWithinToleranceTwoDoubleArrays1D = . false . IF ( PRESENT ( code )) code = ASSERT_VALUES_DIFFER END IF END FUNCTION isWithinToleranceTwoDoubleArrays1D ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isWithinToleranceTwoDoubleArrays2D ( a , b , tol , code ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ), DIMENSION (:,:) :: a , b DOUBLE PRECISION , INTENT ( IN ) :: tol INTEGER , INTENT ( OUT ), OPTIONAL :: code isWithinToleranceTwoDoubleArrays2D = . true . code = ASSERT_SUCCESS IF ( SIZE ( a ) /= SIZE ( b ) ) THEN isWithinToleranceTwoDoubleArrays2D = . false . IF ( PRESENT ( code )) code = ASSERT_SIZE_DIFFERS ELSE IF ( ANY ( ABS ( a - b ) > tol * MAX ( ABS ( a ), ABS ( b )))) THEN isWithinToleranceTwoDoubleArrays2D = . false . IF ( PRESENT ( code )) code = ASSERT_VALUES_DIFFER END IF END FUNCTION isWithinToleranceTwoDoubleArrays2D !@mark - #ifdef _has_Quad ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isWithinToleranceTwoQuad ( x , y , tol ) IMPLICIT NONE REAL ( KIND = SELECTED_REAL_KIND ( QUAD_DIGITS )), INTENT ( in ) :: x , y , tol LOGICAL :: test IF ( x == 0.0d0 ) THEN test = ABS ( x - y ) <= tol ELSE test = ABS ( x - y ) <= tol * MAX ( ABS ( x ), ABS ( y )) END IF IF ( test ) THEN isWithinToleranceTwoQuad = . true . ELSE isWithinToleranceTwoQuad = . false . END IF END FUNCTION isWithinToleranceTwoQuad #endif !@mark - ! !//////////////////////////////////////////////////////////////////////// ! LOGICAL FUNCTION isEqualString ( s1 , s2 ) IMPLICIT NONE CHARACTER ( LEN =* ) :: s1 , s2 isEqualString = . true . IF ( TRIM ( s1 ) /= TRIM ( s2 ) ) THEN isEqualString = . false . END IF END FUNCTION isEqualString END Module ComparisonsModule","tags":"","loc":"sourcefile/comparisons.f90.html"}]}